

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Gond">
  <meta name="keywords" content="">
  
    <meta name="description" content="记不住系列指针&amp;（取地址）和*（根据地址取值） 12345678910111213type MyInt inttype User1 struct &amp;#123;    IdOrName any   &#96;json:&quot;idOrName&quot;&#96;    M        MyInt &#96;json:&quot;m&quot;&#96;&amp;#125;func main() &amp;#123;    str">
<meta property="og:type" content="article">
<meta property="og:title" content="语法笔记">
<meta property="og:url" content="http://gondmhd.github.io/2024/12/10/go/%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Gond">
<meta property="og:description" content="记不住系列指针&amp;（取地址）和*（根据地址取值） 12345678910111213type MyInt inttype User1 struct &amp;#123;    IdOrName any   &#96;json:&quot;idOrName&quot;&#96;    M        MyInt &#96;json:&quot;m&quot;&#96;&amp;#125;func main() &amp;#123;    str">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-10T09:36:28.539Z">
<meta property="article:modified_time" content="2024-12-10T09:36:28.539Z">
<meta property="article:author" content="Gond">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>语法笔记 - Gond</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gondmhd.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Gond</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="语法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-10 17:36" pubdate>
          2024年12月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          186 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">语法笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="记不住系列"><a href="#记不住系列" class="headerlink" title="记不住系列"></a>记不住系列</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong><code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>    IdOrName any   <span class="hljs-string">`json:&quot;idOrName&quot;`</span><br>    M        MyInt <span class="hljs-string">`json:&quot;m&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">&quot;nihao&quot;</span><br>    u := User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// u 是 User1 类型的变量</span><br><br>    <span class="hljs-comment">// 若要声明一个 User1 类型的指针，应如下所示：</span><br>    uPtr := &amp;User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// uPtr 是 *User1 类型的指针变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，<code>u</code> 是 <code>User1</code> 结构体的一个实例，直接存储结构体的值；而如果声明一个指针变量，应该使用取址运算符 <code>&amp;</code>，如 <code>uPtr</code> 示例所示。指针变量存储的是结构体实例的内存地址，而不是结构体的值本身。</p>
<p>在 Go 语言中，当你修改一个指针类型地址指向的值时，实际上是在修改指针所指向的内存区域中的值；而当你直接修改一个变量的值时，是在修改该变量所在内存区域的值。下面是两者的区别：</p>
<ol>
<li><p><strong>修改指针类型地址指向的值：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> ptrToM *MyInt = &amp;m <span class="hljs-comment">// 创建一个指向 m 的指针</span><br><br><span class="hljs-comment">// 修改指针指向的值</span><br>*ptrToM = <span class="hljs-number">20</span> <span class="hljs-comment">// 此时，m 的值变为 20，因为 ptrToM 指向 m 的内存地址</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure>

<p>在这里，<code>ptrToM</code> 是一个指向 <code>MyInt</code> 类型变量 <code>m</code> 的指针。通过 <code>*ptrToM = 20</code>，我们改变了 <code>ptrToM</code> 所指向内存区域的值，也就是变量 <code>m</code> 的值。</p>
</li>
<li><p><strong>直接修改变量的值</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 直接修改变量的值</span><br>m = <span class="hljs-number">20</span> <span class="hljs-comment">// 直接将 m 的值改为 20</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure>

<p>在这里，我们直接操作变量 <code>m</code>，将其值设为 20，这是对变量自身内存区域的修改。</p>
</li>
</ol>
<p>简而言之，指针修改的是它指向的内存位置的值，而直接修改变量则是修改变量自身的内存位置的值。使用指针可以在不复制大量数据的情况下修改大型数据结构，还可以实现对函数内部局部变量的修改（通过传递指针作为参数），从而达到引用传递的效果。</p>
<ol>
<li><strong>内存地址</strong>：内存地址是计算机内存中每个存储位置的编号，用来唯一标识内存中的一个存储单元。程序运行时，变量、数据结构、指令等都会被加载到内存中，并且每个都有对应的内存地址。</li>
<li><strong>指针（Pointer）</strong>：在编程语言中，指针是一种数据类型，它存储的就是这样一个内存地址。通过指针，程序能够直接访问和修改内存中的数据。例如，在go中，声明一个整型指针变量 <code>int *p;</code>，通过赋值 <code>p = &amp;x;</code>（其中x为一个整型变量），指针p就存储了x变量的内存地址，进而可以使用 <code>*</code>p &#x3D; 10;&#96; 来改变x的值。</li>
</ol>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在Go语言中，<code>map</code> 类型相当于Python中的 <code>dict</code>（字典）类型。两者都是关联数组或哈希表的实现，提供了通过键（key）来访问和存储值（value）的能力</p>
<ul>
<li><p>在 Go 语言中声明一个 map：</p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)			<span class="hljs-comment">// 创建一个键为string类型，值为int类型的map</span><br><span class="hljs-comment">// 插入或更新元素</span><br>myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">// 如果&quot;apple&quot;这个键不存在，则插入；如果存在，则更新其值为5</span><br><span class="hljs-comment">// 删除键为&quot;apple&quot;的元素</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;apple&quot;</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>在 Python 中声明一个 dict：</p>
<p>Python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>两者都可以通过键来添加、修改、删除和查找元素，并且它们都不保证元素的迭代顺序是固定的（在Go 1.18版本之前）。此外，Go 的 map 和 Python 的 dict 都要求键必须是可比较的类型。在Go中，键通常是整数、浮点数、字符串或指针等；在Python中，键可以是不可变类型，如整数、浮点数、字符串、元组等。</p>
<h2 id="切片（Slices）"><a href="#切片（Slices）" class="headerlink" title="切片（Slices）"></a>切片（Slices）</h2><p><strong>Go语言中的切片（Slices）</strong>： 对应于Python中的<strong>列表（List）</strong>。两者都是可变长度的序列，可以动态添加、删除或修改元素。Go语言中的切片虽然基于数组实现，但提供了更灵活的接口，无需预先指定固定长度，可以自由扩展。在Python中，列表支持索引访问、切片操作以及其他丰富的内置方法，如append、extend、pop等，这些功能与Go语言切片相似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指定长度为0 </span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//或者给定预期长度</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>



<p>切片会自动扩容</p>
<p>扩容策略一般为:</p>
<ul>
<li>若原容量小于1024,新容量为原容量的2倍</li>
<li>若原容量大于或等于1024,新容量增长1.25倍</li>
</ul>
<p>影响性能不报错</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// len=5, cap=10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// len=8, cap还是10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">4</span>) <span class="hljs-comment">// 超过cap,cap增加到20,重新分配内存</span><br></code></pre></td></tr></table></figure>



<h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个长度为 n 的数组，元素类型为 T</span><br><span class="hljs-keyword">var</span> arr [n]T<br><br><span class="hljs-comment">// 示例：声明一个长度为 5 的整数数组</span><br><span class="hljs-keyword">var</span> numbers [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 或者同时初始化</span><br>numbers := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure>

<p>在某些方面类似于Python中的<strong>元组（Tuples）</strong>，特别是当它们用来表示固定长度且不可变的数据序列时。然而，Go语言中的数组与Python中的元组有几个关键区别：</p>
<ul>
<li><p>Go语言的数组是固定长度的，一旦创建后不能改变长度；</p>
</li>
<li><p>Python的元组虽然是不可变序列，但一般不强调其内部元素必须是同一类型，而Go语言的数组要求所有元素必须是同一类型；</p>
</li>
<li><p>Python中没有与Go语言数组完全一一对应的结构，因为Python的列表和元组都可以包含多种类型的元素，而且元组虽然不可变，但长度可以变化（通过组合多个元组形成新元组）。</p>
</li>
<li><p>数组长度固定，创建后不可变；切片长度可变。</p>
</li>
<li><p>数组是值类型；切片是引用类型（类似于指针）。</p>
</li>
<li><p>数组通过索引访问；切片除了索引访问外，还可以通过切片表达式创建新的切片视图。</p>
</li>
<li><p>切片是对数组的部分引用，更灵活，适用于动态变化的序列数据处理场景。</p>
</li>
</ul>
<h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><p>在Go语言中，结构体（struct）相当于Python中的类实例或命名元组（namedtuple）。结构体是用来封装多个字段的复合数据类型，每个字段都有一个名称和对应的类型</p>
<p>在Go语言中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br>p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure>

<p>在Python中，使用类定义类似的数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure>

<p>或者使用命名元组（collections.namedtuple）实现更轻量级的、不可变的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])<br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure>

<p>两者都可以用来表示具有固定属性的数据对象。不过，需要注意的是，Go语言中的结构体默认不包含方法，如果需要添加行为（如函数），可以为结构体定义方法；而Python类则通常包含了数据属性和方法，更加面向对象。</p>
<p>在Go语言中，为结构体定义方法的案例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个结构体Person</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 为Person结构体定义一个SayHello方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SayHello() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hello, my name is %s and I am %d years old.\n&quot;</span>, p.Name, p.Age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个Person实例</span><br>    alice := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">25</span>&#125;<br><br>    <span class="hljs-comment">// 调用Person实例的方法</span><br>    alice.SayHello() <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 25 years old.</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="make和new有什么区别"><a href="#make和new有什么区别" class="headerlink" title="make和new有什么区别"></a>make和new有什么区别</h2><p><strong>new 创建一个该类型的实例，并且返回指向该实例的指针。new 函数是内建函数，函数定义：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span></span> *Type<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 new 函数来分配空间</li>
<li>传递给 new 函数的是一个类型，而不是一个值</li>
<li>返回值是指向这个新分配的地址的指针</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">pInt := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)         <span class="hljs-comment">// 分配一个 int 类型的零值，并返回指向它的指针</span><br>*pInt = <span class="hljs-number">42</span>               <span class="hljs-comment">// 解引用指针，给 int 类型的值赋值</span><br>pSlice := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)     <span class="hljs-comment">// 分配一个切片的零值，也就是 nil，但通常不这么用</span><br></code></pre></td></tr></table></figure>



<p><strong>make 的作用是为 slice, map or chan 的初始化 然后返回引用make 函数是内建函数，函数定义：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(Type, size IntegerType)</span></span> Type<br></code></pre></td></tr></table></figure>

<ul>
<li>make(T, args)函数的目的和 new(T)不同 仅仅用于创建 slice, map,channel 而且返回类型是实例</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)     <span class="hljs-comment">// 创建一个长度为5的切片，初始化为零值</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">// 创建一个空的映射</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)   <span class="hljs-comment">// 创建一个带缓冲的通道</span><br></code></pre></td></tr></table></figure>



<h2 id="接口类型（interface）"><a href="#接口类型（interface）" class="headerlink" title="接口类型（interface）"></a>接口类型（interface）</h2><p>在 Go 语言中，<code>interface&#123;&#125;</code> 类型被称为“空接口”，它不包含任何方法签名。由于任何类型都至少实现了零个方法（即不实现任何方法），所以任何 Go 语言中的类型都能赋值给 <code>interface&#123;&#125;</code> 类型的变量。这使得 <code>interface&#123;&#125;</code> 成为了一个通用的类型容器，能够在不知道具体类型的情况下存储任意类型的值，从而起到解耦类型的作用，增强了代码的灵活性和扩展性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br>any = <span class="hljs-string">&quot;Hello, World!&quot;</span>  <span class="hljs-comment">// 字符串类型</span><br>any = <span class="hljs-number">42</span>               <span class="hljs-comment">// 整数类型</span><br>any = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;       <span class="hljs-comment">// 空结构体类型</span><br>any = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;        <span class="hljs-comment">// 函数类型</span><br><br><span class="hljs-comment">// 在运行时，可通过类型断言或类型 switches 来确定并操作 any 中的实际类型</span><br>value, ok := any.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，虽然 <code>interface&#123;&#125;</code> 可以存储任何类型的值，但在取出值后，如果不做类型断言还原成具体的类型，就无法访问该类型的任何方法或字段。此外，Go 语言直到 Go 1.18 版本才引入了真正的泛型支持，而在此之前，<code>interface&#123;&#125;</code> 一直是 Go 语言实现泛型编程能力的一种有限方式。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>泛型允许你在函数、方法或类型定义中使用类型参数，这样就可以编写可以工作在多种类型上的代码，而无需为每种类型重复定义代码。</li>
<li>类型参数 (Type Parameters)<ul>
<li><strong><code>T</code></strong>: 一般用于泛型函数或类型中，表示一个通用的类型参数，可以代表任何类型，只要该类型满足泛型定义中的约束条件。</li>
<li><strong><code>V</code></strong>: 常用于表示泛型结构体或接口中的第二个类型参数，特别是在涉及键值对或者多个类型的组合时。</li>
<li><strong><code>K</code></strong>: 通常用于表示映射(Map)中的键类型，与 <code>V</code> 一起使用，其中 <code>V</code> 表示映射的值类型。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>约束 (Constraints)</strong>:</p>
<ul>
<li><p>泛型中的类型参数可以带有约束，这意味着你可以指定类型参数必须满足的条件，例如实现特定的接口。这增强了类型安全性。</p>
</li>
<li><p>预定义约束</p>
<p>Go 标准库提供了几个预定义的约束接口，用于方便地指定类型参数的通用属性：</p>
<ul>
<li><strong><code>constraints.Ordered</code></strong>: 表示类型参数必须是可以排序的，例如整数、浮点数、字符串等。</li>
<li><strong><code>constraints.Integer</code></strong>: 表示类型参数必须是整数类型。</li>
<li><strong><code>constraints.Float</code></strong>: 表示类型参数必须是浮点数类型。</li>
<li><strong><code>constraints.Complex</code></strong>: 表示类型参数必须是复数类型。</li>
<li><strong><code>constraints.Signer</code></strong>: 表示类型参数必须是有符号数类型。</li>
</ul>
</li>
<li><p>自定义约束</p>
<p>定义自己的约束接口，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Printable <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在泛型声明中使用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span>[<span class="hljs-title">T</span> <span class="hljs-title">Printable</span>]<span class="hljs-params">(t T)</span></span> &#123;<br>    fmt.Println(t.String())<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实例化</strong>:</p>
<ul>
<li>当你使用泛型函数或类型时，你必须为类型参数提供具体的类型。编译器会生成针对这些具体类型的代码，这称为实例化。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从 Go 1.18 开始支持泛型</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span><br>)<br><br><span class="hljs-comment">// PrintValue 是一个泛型函数，可以打印任何实现了 fmt.Stringer 接口或基本类型（如 int, string 等）的值。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintValue</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span> | <span class="hljs-title">any</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>	fmt.Println(value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> anyVar <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, World!&quot;</span> <span class="hljs-comment">// 字符串类型</span><br>	PrintValue(anyVar)                       <span class="hljs-comment">// 输出: Hello, World!</span><br><br>	anyVar = <span class="hljs-number">42</span>                              <span class="hljs-comment">// 整数类型</span><br>	PrintValue(anyVar)                       <span class="hljs-comment">// 输出: 42</span><br><br>	anyVar = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                      <span class="hljs-comment">// 空结构体类型</span><br>	PrintValue(anyVar)                       <span class="hljs-comment">// 输出: &#123;&#125;</span><br><br>	anyFunc := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;                     <span class="hljs-comment">// 函数类型</span><br>	<span class="hljs-comment">// 注意：不能直接打印函数，这里只是为了演示泛型函数可以接收函数类型</span><br>	<span class="hljs-comment">// PrintValue(anyFunc)  // 这一行会编译失败，因为函数类型不能转换为 fmt.Stringer</span><br><br>	<span class="hljs-comment">// 使用泛型直接处理各种类型，无需通过 interface&#123;&#125; 中转</span><br>	PrintValue[<span class="hljs-type">string</span>](<span class="hljs-string">&quot;Hello, World!&quot;</span>) <span class="hljs-comment">// 输出: Hello, World!</span><br>	PrintValue[<span class="hljs-type">int</span>](<span class="hljs-number">42</span>)                <span class="hljs-comment">// 输出: 42</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>泛型函数 <code>PrintValue</code></strong>:</p>
<ul>
<li><code>PrintValue</code> 函数定义了一个类型参数 <code>T</code>，并且使用了联合约束 <code>constraints.Ordered | any</code>。这意味着 <code>T</code> 可以是任何有序类型（如整数、浮点数）或任何类型（<code>any</code>），这使得 <code>PrintValue</code> 函数可以处理非常广泛的类型。</li>
<li>函数体中，<code>PrintValue</code> 直接使用 <code>fmt.Println(value)</code> 来打印传入的值。由于 <code>value</code> 的类型是 <code>T</code>，这意味着它能够打印任何类型参数 <code>T</code> 可以表示的值。</li>
</ul>
</li>
<li><p><strong>使用 <code>interface&#123;&#125;</code></strong>:</p>
<ul>
<li>在主函数中，<code>anyVar</code> 是一个 <code>interface&#123;&#125;</code> 类型的变量，它可以接收任何类型的值。然后，我们可以将 <code>anyVar</code> 传递给 <code>PrintValue</code> 函数，这是因为 <code>PrintValue</code> 的类型参数 <code>T</code> 可以是 <code>any</code>，包含了 <code>interface&#123;&#125;</code> 的所有可能性。</li>
</ul>
</li>
<li><p><strong>直接使用泛型</strong>:</p>
<ul>
<li>在示例的最后部分，我们直接使用了泛型函数 <code>PrintValue</code> 处理具体类型的值，如字符串 <code>&quot;Hello, World!&quot;</code> 和整数 <code>42</code>。这展示了泛型函数的灵活性和类型安全性，因为你必须在调用时明确指定类型参数 <code>T</code> 的具体类型。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>接口</strong> 提供了类型间的多态性，允许你编写可以接受多种类型参数的函数，只要这些类型实现了指定的接口。</li>
<li><strong>泛型</strong> 允许你编写可以工作在多种类型上的代码，通过类型参数和约束来指定泛型函数或类型的适用范围。</li>
</ul>
<h2 id="Go语言中的init作用"><a href="#Go语言中的init作用" class="headerlink" title="Go语言中的init作用"></a>Go语言中的init作用</h2><p>在 Go 语言中，<code>init</code> 函数是一个特殊的函数，它主要用于在包被加载时自动执行初始化动作。<code>init</code> 函数有以下特性：</p>
<ol>
<li><strong>自动调用</strong>：<code>init</code> 函数没有返回值，也不需要显式调用。当一个 Go 包被导入时，该包中的所有顶级（非内嵌）<code>init</code> 函数（若有多个的话）会按照它们在源代码中出现的顺序依次执行。</li>
<li><strong>隐式执行</strong>：<code>init</code> 函数不能被其他函数调用，也无法被外部引用。</li>
<li><strong>用于初始化</strong>：通常在 <code>init</code> 函数中执行那些需要在程序运行初期完成的准备工作，例如初始化全局变量、连接数据库、设置日志系统、注册系统组件等。</li>
<li><strong>优先级</strong>：<code>init</code> 函数在 main 函数之前执行，如果一个包被导入，那么该包的 <code>init</code> 函数将在 main 包的 <code>init</code> 函数之前运行。</li>
</ol>
<p>举例说明：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;Initialized by init&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Executing init function in example package&quot;</span>)<br>    <span class="hljs-comment">// 可以在这里进行初始化操作</span><br>    <span class="hljs-comment">// 例如，设置全局变量、初始化连接、注册函数等</span><br>    globalVar = <span class="hljs-string">&quot;Updated during init&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，当导入 <code>example</code> 包时，<code>init</code> 函数会被自动执行，并输出一条消息，同时更新全局变量 <code>globalVar</code> 的值。</p>
<p><code>setup</code> 函数和 <code>init</code> 函数在 Go 语言中都用于初始化，但它们之间有明显的区别：</p>
<ol>
<li><strong>init 函数</strong>：<ul>
<li>是 Go 语言内置的特殊函数，每个包都可以有多个 <code>init</code> 函数，它们没有返回值，也没有接收者。</li>
<li><code>init</code> 函数在包被导入时自动调用，并按照它们在源码中的定义顺序执行。</li>
<li><code>init</code> 函数主要用于包内部的一些必要初始化工作，例如初始化全局变量、设置日志系统、初始化数据库连接等。</li>
<li>用户不能直接调用 <code>init</code> 函数，由 Go 语言运行时自动执行。</li>
</ul>
</li>
<li><strong>setup 函数</strong>：<ul>
<li>是用户自定义的普通函数，通常用于整个应用程序或模块的一次性初始化工作。</li>
<li><code>setup</code> 函数可以有返回值和接收者，具体取决于其实现。</li>
<li>用户需要在合适的地方主动调用 <code>setup</code> 函数来完成初始化。</li>
<li>由于 <code>setup</code> 是自定义函数，它的功能和用途更为灵活多样，可以根据应用场景自行设计。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>init</code> 函数是 Go 语言规范的一部分，用于在包加载时进行初始化，执行时机不由用户控制。</li>
<li><code>setup</code> 函数是程序员自定义的初始化逻辑，执行时机和内容完全由开发者决定，通常用于较为复杂的初始化流程或跨包的全局初始化操作。</li>
</ul>
<h2 id="单双引号"><a href="#单双引号" class="headerlink" title="单双引号"></a>单双引号</h2><ul>
<li><strong>单引号 <code>&#39;</code></strong> 用于表示单个 <code>rune</code> 类型的字符，常用于处理单个Unicode码点，不支持转义字符。</li>
<li><strong>双引号 <code>&quot;</code></strong> 用于表示 <code>string</code> 类型的字符串，可以包含多个字符及转义序列，适合处理多字符文本和需要转义的场景。</li>
</ul>
<h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>在Go语言中，&#96;&#96; 符号（通常被称为反引号或背引号）用于创建一个<strong>原生字符串字面量（raw string literal）</strong>。原生字符串字面量具有以下特点：</p>
<ol>
<li><strong>包围字符串</strong>：使用一对反引号（&#96;&#96;）来包围字符串内容，与双引号（””）或单引号（’’）包围的字符串不同。</li>
<li><strong>不支持转义字符</strong>：原生字符串内部的任何字符都不会被解析为转义序列。也就是说，即使你写了类似 <code>\n</code>、<code>\t</code> 或 <code>\&quot;</code> 这样的序列，它们也会被当作普通字符对待，不会转换成换行符、制表符或双引号。</li>
<li><strong>保留换行和空格</strong>：原生字符串中包含的所有换行符、制表符和空格都将原样保留。当你需要编写多行文本或者包含大量特殊空白字符的字符串时，原生字符串特别有用，因为无需使用转义序列来插入这些字符。</li>
<li><strong>包含特殊字符无障碍</strong>：由于不解析转义字符，原生字符串尤其适合包含需要原样输出的特殊字符、正则表达式模式、HTML代码、JSON或XML片段等，避免了因转义导致的混淆或错误。</li>
</ol>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 原生字符串字面量</span><br>sqlQuery := <span class="hljs-string">`</span><br><span class="hljs-string">    SELECT id, name, email</span><br><span class="hljs-string">    FROM users</span><br><span class="hljs-string">    WHERE active = true</span><br><span class="hljs-string">`</span><br><br>regexPattern := <span class="hljs-string">`^https?://[a-zA-Z0-9._-]+(\.[a-zA-Z]&#123;2,&#125;)+/`</span><br></code></pre></td></tr></table></figure>

<p>在上述示例中：</p>
<ul>
<li><code>sqlQuery</code> 是一个多行SQL查询语句，原生字符串确保了换行符被正确地包含在字符串中，使得查询语句格式清晰且无需手动添加 <code>\n</code> 转义序列。</li>
<li><code>regexPattern</code> 是一个正则表达式，其中的斜线（<code>/</code>）和特殊字符无需转义，直接写入原生字符串即可。</li>
</ul>
<p>总之，在Go语言中，&#96;&#96; 符号用于创建原生字符串字面量，提供了一种方便的方式来编写包含复杂或特殊字符的字符串，且无需考虑转义问题。这对于需要保留原始文本格式或包含特殊字符的场景尤为有用。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1.匿名函数 "></a>1.匿名函数<code> </code></h3><ul>
<li><p>有时候我们想要完成某一特定功能，但该功能只在一个包中用到几次，我们可以不用将其封装为包级别的函数，而是使用匿名函数</p>
</li>
<li><p>匿名函数，就是可以省略函数名的函数</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123; <span class="hljs-comment">// 匿名函数不需要函数名</span><br>		<span class="hljs-keyword">return</span> i<br>	&#125;(<span class="hljs-number">5</span>) <span class="hljs-comment">// 匿名函数通过后面的()向函数传参</span><br>	fmt.Println(r) <span class="hljs-comment">// 输出5</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>go语言是一种强类型语言，我们知道了函数的类型，就可以将其作为参数传入另一个函数,我们称这种函数为回调函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br> <br><span class="hljs-keyword">type</span> FuncType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">//先用FuncType代表有两个int型参数和有一个int型返回值的函数，不用管该函数是否存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//加法</span><br>	<span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minus</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//减法</span><br>	<span class="hljs-keyword">return</span> a - b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//乘法</span><br>	<span class="hljs-keyword">return</span> a * b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//除法</span><br>	<span class="hljs-keyword">return</span> a / b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, fType FuncType)</span></span> (result <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//fType表示一个函数类型变量</span><br>	result = fType(a, b)<br>	<span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>	fmt.Print(<span class="hljs-string">&quot;请输入两个数：&quot;</span>)<br>	fmt.Scan(&amp;x, &amp;y)<br>	fmt.Println(<span class="hljs-string">&quot;这两个数之和为：&quot;</span>, Calculate(x, y, add))<br>	fmt.Println(<span class="hljs-string">&quot;这两个数之差为：&quot;</span>, Calculate(x, y, minus))<br>	fmt.Println(<span class="hljs-string">&quot;这两个数之积为：&quot;</span>, Calculate(x, y, multiple))<br>	fmt.Println(<span class="hljs-string">&quot;这两个数之商为：&quot;</span>, Calculate(x, y, divide))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><p>在一个函数中返回值是另外一个函数，我们称之为闭包。</p>
<ul>
<li><p>闭包的理解：内部函数访问外部函数的变量</p>
</li>
<li><p>闭包的作用：改变临时变量的生命周期</p>
</li>
<li><p>闭包示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 考虑这样一种应用场景，公司其他部门的同事提供给你API,该API要求输入参数为一个func()类型(无参数无返回值)</span><br><span class="hljs-comment">// 现在你有一个func(i int)类型的函数，如何才能调用上述的API呢，这就需要用到闭包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f6</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span></span>)&#123;<br>	fmt.Println(<span class="hljs-string">&quot;I am f6()&quot;</span>)<br>	f()<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f7</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-comment">// 可以看到，该匿名函数中并没有关于变量i的声明与定义，它引用了外部f7()的变量，延长了变量i的生命周期</span><br>		fmt.Printf(<span class="hljs-string">&quot;I am f7(),i have a parameter:%v\n&quot;</span>,i)<br>	&#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    f6(f7(<span class="hljs-number">9</span>)) <span class="hljs-comment">// 输出:I am f6() \n I am f7(),i have a parameter:9</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h3><ul>
<li><p>函数在处理过程中调用自身，称之为递归。</p>
</li>
<li><p>递归必须有结束条件，否则会陷入死循环。</p>
</li>
<li><p>使用递归前，最好把问题进行数学抽象</p>
</li>
<li><p>递归示例：斐波那契数列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 首先进行数学抽象，明确该函数返回值的意义</span><br><span class="hljs-comment">// 该函数返回值是斐波那契数列中第i个位置的值</span><br><span class="hljs-comment">// 根据斐波那契数列的数学规律，我们知道第i个位置的值等于其前两个位置值之和，即fibonacci(i-1)+fibonacci(i-2)</span><br><span class="hljs-comment">// 当处于第一或第二个位置时，由于其前面不足两个元素，因此要单独考虑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>	<span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">2</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fibonacci(i<span class="hljs-number">-1</span>)+fibonacci(i<span class="hljs-number">-2</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++&#123;<br>		fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>,fibonacci(i)) <span class="hljs-comment">// 输出：1 1 2 3 5 8 13 21 34 55</span><br>	&#125;<br>	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>函数（Function）：在包级别定义，不依赖于特定的接收者（receiver），可以在任何地方调用。</p>
</li>
<li><p>方法（Method）：与一个具体类型相关联，定义在类型内部，并有一个接收者（receiver）参数，通常用来扩展类型的行为。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 赋值</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>	ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>	Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>	Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure>



<ol>
<li>var createUser DevUser	声明了一个未初始化的<code>DevUser</code>变量<code>createUser</code>，其内部所有字段的值均为各自类型的零值。</li>
<li>createUser :&#x3D; DevUser{}    使用了简短变量声明（short variable declaration）<code>:=</code>，同时完成了变量声明和初始化。这里<code>createUser</code>变量被赋予了一个<code>DevUser</code>类型的零值实例，即一个所有字段均为零值的新<code>DevUser</code>对象。<code>DevUser&#123;&#125;</code>是创建一个空结构体实例的写法，相当于调用了<code>DevUser</code>类型的零值构造函数。</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>情况一</strong>中，<code>createUser</code>变量未被初始化，其内部字段值为各自的零值。</li>
<li><strong>情况二</strong>中，<code>createUser</code>变量被初始化为一个所有字段均为零值的<code>DevUser</code>实例。</li>
</ul>
<h2 id="引用传递和值传递"><a href="#引用传递和值传递" class="headerlink" title="引用传递和值传递"></a>引用传递和值传递</h2><p><strong>值传递</strong></p>
<p>在 Go 中，当函数调用发生时，所有的参数都是按值传递的。这意味着函数接收到的是参数的值的副本，而不是原始值本身。对于基本数据类型（如 <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code> 等），这通常意味着创建一个完全独立的副本，对函数内的参数所做的任何修改都不会影响到外部的原始值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 形参为 int类型的 x</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addOne</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> &#123;<br>    x++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">10</span><br>    <span class="hljs-comment">// 实参为 n</span><br>    addOne(n)<br>    fmt.Println(n) <span class="hljs-comment">// 输出 10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>引用传递（实际上是一种共享引用）</strong></p>
<p>尽管 Go 没有真正的“引用传递”，但在处理复合类型（如切片、map、channel 和接口）时，情况有所不同。当传递这些类型时，实际上是传递了指向这些复合类型数据的引用。这意味着，虽然函数内部的操作是在局部变量上进行的，但由于这些局部变量持有原始数据的引用，所以对它们的修改会影响到外部的原始数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendItem</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>    slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">42</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    appendItem(numbers)<br>    fmt.Println(numbers) <span class="hljs-comment">// 输出 [1 2 3 42]</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>指针的使用</strong></p>
<p>为了在函数间传递引用并允许直接修改原始数据，Go 支持指针类型。当你将一个指针传递给函数时，你实际上是传递了指向某个值的地址，这允许函数直接修改那个值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">movePoint</span><span class="hljs-params">(p *Point)</span></span> &#123;<br>    p.X++<br>    p.Y++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pt := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    movePoint(&amp;pt)<br>    fmt.Println(pt) <span class="hljs-comment">// 输出 &#123;2 3&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化和没有初始化的区别主要体现在变量或对象的状态以及其在程序中的可用性方面。下面是详细的对比：</p>
<p><strong>未初始化：</strong></p>
<ol>
<li><strong>状态未知</strong>：当一个变量没有经过初始化时，它的值是不确定的。在很多编程语言中（如C、C++、Java、Go等），未初始化的变量会持有其类型的默认值（通常称为零值），如整型为0、浮点型为0.0、布尔型为false、字符串为””（空字符串）、指针为nil等。尽管这些默认值有一定的规律，但对于用户自定义类型（如结构体、类等）或特定情况下的内置类型，未初始化的值可能并不符合预期，甚至可能导致程序逻辑错误或运行时异常。</li>
<li><strong>不可靠使用</strong>：未初始化的变量值是不确定的，直接使用这样的变量会导致程序行为不可预测。例如，对未初始化的字符串进行拼接、对未初始化的数值进行计算，或者对未初始化的指针进行解引用等，都可能导致错误的结果或程序崩溃。</li>
<li><strong>资源管理问题</strong>：对于一些需要分配和管理资源（如内存、文件句柄、网络连接等）的变量（如动态分配的数组、打开的文件、创建的数据库连接等），未初始化可能导致资源泄露，因为没有明确的初始化过程来确保资源的合理分配和释放。</li>
<li><strong>编程规范与调试难度</strong>：未初始化的变量违反了良好的编程实践，使得代码难以阅读、理解和维护。未初始化的变量在调试时也更难追踪其状态变化，增加了定位问题的复杂度。</li>
</ol>
<p><strong>初始化：</strong></p>
<ol>
<li><strong>确定状态</strong>：初始化后的变量具有明确的初始值，这个值由程序员在声明变量时显式指定或通过构造函数、初始化器等机制赋予。初始化确保了变量在使用前已经有了一个预期的、有意义的值。</li>
<li><strong>可靠使用</strong>：初始化后的变量可以直接在程序中安全使用，因为它们的值是已知且符合预期的。这有助于保证程序逻辑的正确性和稳定性。</li>
<li><strong>资源有效管理</strong>：对于需要管理资源的变量，初始化过程通常会伴随着资源的正确分配和设置初始状态。这样可以避免资源泄露，确保程序资源的有效利用和正确清理。</li>
<li><strong>遵循编程规范与易于调试</strong>：初始化变量遵循了良好的编程习惯，使得代码更具可读性、可维护性。初始化的变量在调试时，其状态变化更为清晰，有助于快速识别和解决问题。</li>
</ol>
<p>总之，初始化与未初始化的主要区别在于变量是否具有明确、预期的初始值，以及由此带来的对程序行为的可预测性、资源管理的正确性、代码质量的提升以及调试难度的降低。在实际编程中，应始终确保变量在使用前得到适当的初始化。</p>
<h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><ul>
<li>range循环每个元素都会拷贝一份到变量中</li>
<li>修改变量内部值不影响原结构体</li>
<li>应使用索引直接操作原始结构体对应元素</li>
<li>这样才能实现更新原始数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, field := <span class="hljs-keyword">range</span> schemaMeta.Fields &#123;<br>		<span class="hljs-keyword">if</span> field.FieldPath == <span class="hljs-string">&quot;CSZ10&quot;</span> &#123;<br>			<span class="hljs-keyword">var</span> newTerms []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>			<span class="hljs-keyword">for</span> _, term := <span class="hljs-keyword">range</span> field.GlossaryTerms.Terms &#123;<br>				<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;urn:li:glossaryTerm:网络身份标识&quot;</span> != term[<span class="hljs-string">&quot;urn&quot;</span>] &#123;<br>					newTerms = <span class="hljs-built_in">append</span>(newTerms, term)<br>				&#125;<br>			&#125;<br>			fmt.Println(newTerms)<br>			schemaMeta.Fields[i].GlossaryTerms.Terms = newTerms<br>			<span class="hljs-comment">//field.GlossaryTerms.Terms = newTerms</span><br>			fmt.Println(schemaMeta.Fields[i].GlossaryTerms.Terms)<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="strconv包转换类型"><a href="#strconv包转换类型" class="headerlink" title="strconv包转换类型"></a>strconv包转换类型</h2><p><strong>字符串转整数：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 字符串转整数</span><br>	str := <span class="hljs-string">&quot;123&quot;</span><br>	i, err := strconv.Atoi(str)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;字符串转换为整数：&quot;</span>, i)<br>	&#125;<br><br>	<span class="hljs-comment">// 大整数转换</span><br>	bigStr := <span class="hljs-string">&quot;12345678901234567890&quot;</span><br>	bigInt, err := strconv.ParseInt(bigStr, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;大整数转换失败：&quot;</span>, err)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;大字符串转换为 int64 整数：&quot;</span>, bigInt)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>整数转字符串</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 整数转字符串</span><br>	num := <span class="hljs-number">456</span><br>	str := strconv.Itoa(num)<br>	fmt.Println(<span class="hljs-string">&quot;整数转换为字符串：&quot;</span>, str)<br><br>	<span class="hljs-comment">// int64 转字符串</span><br>	bigNum := <span class="hljs-type">int64</span>(<span class="hljs-number">12345678901234567890</span>)<br>	bigStr := strconv.FormatInt(bigNum, <span class="hljs-number">10</span>)<br>	fmt.Println(<span class="hljs-string">&quot;int64 整数转换为字符串：&quot;</span>, bigStr)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>字符串转浮点数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 字符串转浮点数</span><br>	floatStr := <span class="hljs-string">&quot;3.14&quot;</span><br>	f, err := strconv.ParseFloat(floatStr, <span class="hljs-number">64</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;字符串转换为浮点数：&quot;</span>, f)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>浮点数转字符串</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 浮点数转字符串</span><br>	pi := <span class="hljs-number">3.141592653589793238</span><br>	formatStr := strconv.FormatFloat(pi, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">64</span>) <span class="hljs-comment">// &#x27;f&#x27; 表示固定精度模式，-1 表示使用默认精度</span><br>	fmt.Println(<span class="hljs-string">&quot;浮点数转换为字符串：&quot;</span>, formatStr)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>字符串转布尔值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 字符串转布尔值</span><br>	boolStr := <span class="hljs-string">&quot;true&quot;</span><br>	b, err := strconv.ParseBool(boolStr)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;字符串转换为布尔值：&quot;</span>, b)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>布尔值转字符串</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 布尔值转字符串</span><br>	flag := <span class="hljs-literal">true</span><br>	str := strconv.FormatBool(flag)<br>	fmt.Println(<span class="hljs-string">&quot;布尔值转换为字符串：&quot;</span>, str)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="reflect打印变量类型"><a href="#reflect打印变量类型" class="headerlink" title="reflect打印变量类型"></a>reflect打印变量类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>	<span class="hljs-keyword">var</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>	<span class="hljs-keyword">var</span> c <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><br>	<span class="hljs-comment">// 打印变量 a、b 和 c 的类型</span><br>	fmt.Printf(<span class="hljs-string">&quot;a 的类型是: %s\n&quot;</span>, reflect.TypeOf(a).Name())<br>	fmt.Printf(<span class="hljs-string">&quot;b 的类型是: %s\n&quot;</span>, reflect.TypeOf(b).Name())<br>	fmt.Printf(<span class="hljs-string">&quot;c 的类型是: %s\n&quot;</span>, reflect.TypeOf(c).Name())<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在Go语言中，断言（Assertion）主要用于类型转换和接口值类型的判断。主要有以下两种形式的断言：</p>
<ol>
<li><p><strong>类型断言</strong>： 类型断言应用于接口类型变量，用于检测接口值是否具有特定类型，并可选择地将其转换为该类型。基本语法如下：</p>
<p>Go</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">value, ok := interfaceVariable.(typeName)<br></code></pre></td></tr></table></figure>

<p>其中，<code>interfaceVariable</code> 是一个接口类型的变量，<code>typeName</code> 是你希望它实际具有的类型。如果接口变量的动态类型确实与<code>typeName</code>一致，那么<code>value</code>将得到接口值对应的底层值，<code>ok</code>将被设为<code>true</code>；如果不匹配，<code>ok</code>将为<code>false</code>，且<code>value</code>的值将是相应类型的零值。</p>
<p>例如：</p>
<p>Go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, world!&quot;</span><br>s, ok := i.(<span class="hljs-type">string</span>)<br><span class="hljs-comment">// s == &quot;Hello, world!&quot;, ok == true</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>类型断言在接口间转换</strong>： 类型断言也可用于将一个接口类型转换为另一个接口类型，只要它们的底层类型能够满足转换要求。</p>
</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>简单讲：反射就是在程序运行时，可以访问自身结构并且做出修改的一种能力（审视自身）。</p>
<p>在golang中，反射是通过<code>reflect</code>包来实现</p>
<h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><p>要打印变量的类型，你可以使用<code>reflect.TypeOf()</code>函数结合<code>fmt.Println()</code>。<code>reflect.TypeOf()</code>会返回一个代表类型信息的<code>reflect.Type</code>对象，然后通过它的<code>String()</code>方法得到类型名字符串。</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> myInt <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>	<span class="hljs-keyword">var</span> myString <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span><br><br>	fmt.Println(<span class="hljs-string">&quot;myInt的类型是:&quot;</span>, reflect.TypeOf(myInt).String())<br>	fmt.Println(<span class="hljs-string">&quot;myString的类型是:&quot;</span>, reflect.TypeOf(myString).String())<br>    <span class="hljs-comment">//或者</span><br>    fmt.Printf(<span class="hljs-string">&quot;myInt的类型是:%T\n&quot;</span>, myInt)			<span class="hljs-comment">// myInt的类型是：int</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><ol>
<li><p><strong>使用<code>+</code>操作符</strong>: 这是最直接的方式，但当拼接大量字符串时可能导致性能问题，因为它会产生许多临时字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">name := <span class="hljs-string">&quot;Alice&quot;</span><br>age := <span class="hljs-number">30</span><br>result := <span class="hljs-string">&quot;My name is &quot;</span> + name + <span class="hljs-string">&quot;, and I am &quot;</span> + strconv.Itoa(age) + <span class="hljs-string">&quot; years old.&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>fmt.Sprintf</code></strong>: 更灵活，适合格式化输出，性能优于连续的<code>+</code>操作符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result := fmt.Sprintf(<span class="hljs-string">&quot;My name is %s, and I am %d years old.&quot;</span>, name, age)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>strings.Builder</code></strong>: 对于大量字符串拼接操作，<code>strings.Builder</code>提供了更好的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> builder strings.Builder<br>builder.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br>builder.WriteString(name)<br>builder.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br>builder.WriteString(strconv.Itoa(age))<br>builder.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br>result := builder.String()<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>bytes.Buffer</code></strong>: 类似于<code>strings.Builder</code>，但在处理字节层面，适用于二进制数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<br>buffer.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br>buffer.WriteString(name)<br>buffer.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br>buffer.WriteString(strconv.Itoa(age))<br>buffer.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br>result := buffer.String()<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul>
<li><code>%s</code>: 字符串（string）</li>
<li><code>%d</code>: 十进制整数（int）</li>
<li><code>%f</code>: 浮点数，默认保留小数点后6位</li>
<li><code>%e</code> 或 <code>%E</code>: 科学记数法表示的浮点数</li>
<li><code>%T</code>: 任何值的类型信息</li>
<li><code>%g</code> 或 <code>%G</code>: 简化的科学记数法或浮点数，自动根据值的大小选择</li>
<li><code>%x</code>: 十六进制表示的整数，小写字母</li>
<li><code>%X</code>: 十六进制表示的整数，大写字母</li>
<li><code>%o</code>: 八进制表示的整数</li>
<li><code>%p</code>: 指针地址，以十六进制表示并前缀<code>0x</code></li>
<li><code>%q</code>: 引号包围的字符串，任何特殊字符都会被转义</li>
<li><code>%v</code>: 默认格式，根据值的具体类型选择合适的格式化方式</li>
<li><code>%%</code>: 输出百分号自身（而非作为占位符）</li>
<li><code>%[width]</code>: 指定输出的最小宽度，不足则左补空格</li>
<li><code>%-[width]</code>: 左对齐（默认是右对齐）</li>
<li><code>%.[precision]f</code>: 对浮点数指定小数点后的位数</li>
<li><code>%[flags][width][.precision]specifier</code>: 组合使用，如<code>%05d</code>表示至少5位宽，不足前导零填充的十进制整数。</li>
</ul>
<h2 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h2><p><strong>进程（process）</strong></p>
<ul>
<li>进程是资源分配的最小单位</li>
<li>进程间不共享内存，每个进程拥有自己独立的内存</li>
<li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li>
<li>新开进程开销大，并且 CPU 切换进程成本也大</li>
<li>进程由操作系统调度</li>
<li>多进程方式比多线程更加稳定</li>
</ul>
<p><strong>线程（thread）</strong></p>
<ul>
<li>线程是程序执行流的最小单位</li>
<li>线程是来自于进程的，一个进程下面可以开多个线程</li>
<li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li>
<li>线程因为是在同一个进程内的，可以共享内存</li>
<li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li>
<li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li>
<li>某个线程发生致命错误会导致整个进程崩溃</li>
<li>线程间读写变量存在锁的问题处理起来相对麻烦</li>
</ul>
<p><strong>协程（coroutine）</strong></p>
<ul>
<li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li>
<li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li>
<li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li>
<li>协程比线程更轻量级</li>
</ul>
<h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>通道（channel）是一种用于在goroutine之间传递数据的安全方式，支持同步通信。通道可以被声明为有缓冲或无缓冲的，具体写法和使用方式如下：</p>
<h3 id="通道的声明与初始化"><a href="#通道的声明与初始化" class="headerlink" title="通道的声明与初始化"></a>通道的声明与初始化</h3><p><strong>1. 无缓冲通道</strong>：数据的发送和接收操作必须同时发生，即发送者会阻塞，直到有接收者准备好接收数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 无缓冲通道，类型为int</span><br></code></pre></td></tr></table></figure>

<p><strong>2. 有缓冲通道</strong>：可以在没有接收者立即接收的情况下发送一定数量的数据，缓冲区满后，再发送数据将会阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 有缓冲通道，类型为int，缓冲区大小为5</span><br></code></pre></td></tr></table></figure>

<h3 id="发送数据到通道"><a href="#发送数据到通道" class="headerlink" title="发送数据到通道"></a>发送数据到通道</h3><ul>
<li><p><strong>基础发送</strong>：使用<code>&lt;-&quot;channel&quot;</code>语法发送数据到通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- value <span class="hljs-comment">// 将value发送到通道ch</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="从通道接收数据"><a href="#从通道接收数据" class="headerlink" title="从通道接收数据"></a>从通道接收数据</h3><ul>
<li><p><strong>基础接收</strong>：使用<code>value := &lt;-channel</code>语法从通道接收数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">receivedValue := &lt;-ch <span class="hljs-comment">// 从通道ch接收数据并存储在receivedValue中</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>​		 多goroutines读取通道数据，取决于Go 的调度器分配，可能会出现第一个写入的数据可能被第一个读取的 goroutine读取，第二个数据可能被第二个读取的 goroutine读取</p>
<p>​	      当从一个通道进行接收操作时如果通道中没有数据可接收且通道未被关闭，该接收操作将会阻塞。这种阻塞本身并不会抛出异常或错误，而是会使当前的 goroutine 暂停执行，直到通道中有数据可用或通道被关闭。</p>
<p><strong>阻塞问题：</strong></p>
<ol>
<li><p><strong>死锁</strong>：</p>
<p>如果程序的逻辑设计不当，可能导致多个 goroutine 互相等待对方释放资源或发送&#x2F;接收数据，从而形成死锁。在这种情况下，程序将停止响应，因为没有任何 goroutine 能够继续执行。</p>
</li>
<li><p><strong>性能问题:</strong></p>
<p>过度的阻塞可能会导致性能下降，尤其是在高并发的系统中。如果大量 goroutines 因为等待通道数据而阻塞，可能会影响系统的响应时间和吞吐量。</p>
</li>
<li><p><strong>资源浪费</strong>：</p>
<p>长时间的阻塞也可能导致 CPU 时间片和其他系统资源的浪费，因为被阻塞的 goroutine 占用了调度器的注意力，而实际上它无法执行任何工作。</p>
</li>
<li><p><strong>逻辑错误</strong>：</p>
<p><strong>逻辑错误</strong>： 如果预期一个通道应该有数据可接收，但实际上没有，这可能是程序逻辑上的错误。例如，可能有 goroutine 应该向通道发送数据，但由于某种原因未能执行。</p>
</li>
</ol>
<p>为了避免这些问题，通常可以采用以下策略：</p>
<ul>
<li><strong>使用 select 语句</strong>：结合 default case 使用 select 语句可以防止无限期的阻塞，使 goroutine 在没有数据可接收时能够继续执行其他操作。</li>
<li><strong>关闭通道</strong>：当不再需要向通道发送数据时，应该关闭通道。这可以通知所有等待接收数据的 goroutines，让它们知道没有更多数据可接收，从而避免无限期的阻塞。</li>
<li><strong>超时机制</strong>：通过使用定时器或上下文（context）来限制等待时间，可以防止长时间的阻塞。</li>
</ul>
<h3 id="多路复用与默认选择"><a href="#多路复用与默认选择" class="headerlink" title="多路复用与默认选择"></a>多路复用与默认选择</h3><ul>
<li><p><strong>多路复用</strong>：在<code>select</code>语句中，可以监听多个通道上的发送或接收操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch1 &lt;- value:<br>    <span class="hljs-comment">// 发送到ch1成功</span><br><span class="hljs-keyword">case</span> ch2 &lt;- value:<br>    <span class="hljs-comment">// 发送到ch2成功</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>带default的select</strong>：用于非阻塞接收或发送，或者执行默认操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> value := &lt;-ch:<br>    <span class="hljs-comment">// 从ch接收数据</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 没有数据可接收时执行</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h3><ul>
<li><p><strong>关闭通道</strong>：使用<code>close(channel)</code>可以关闭一个通道，表明不再会有数据发送到该通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 关闭通道ch</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>唯一关闭原则：应该只有一个goroutine负责关闭管道。重复关闭管道会导致运行时panic（<code>panic: close of closed channel</code>）。</li>
<li>接收者可以通过<code>v, ok := &lt;-ch</code>来检查通道是否已经关闭（<code>ok</code>为<code>false</code>表示通道已关闭且没有更多数据可接收）。</li>
<li>向一个已关闭的通道发送数据会导致运行时panic，尝试从一个已关闭的无缓冲通道接收数据（如果没有其他发送者等待）也会导致接收操作立即返回零值和<code>false</code>的<code>ok</code>。</li>
</ul>
<h2 id="Switch-Select-区别"><a href="#Switch-Select-区别" class="headerlink" title="Switch\Select 区别"></a>Switch\Select 区别</h2><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><ul>
<li><strong>用途</strong>：主要用于基于不同条件（通常是变量的值）执行不同的代码路径。它可以处理多种情况，并且可以有一个可选的默认分支（<code>default</code> case）。</li>
<li><strong>适用场景</strong>：当你需要根据某个表达式的值来做决策时，比如处理枚举类型、错误码等。</li>
<li><strong>控制流</strong>：顺序执行，从上到下匹配<code>case</code>，一旦匹配成功执行相应代码块后（除非有<code>break</code>），会继续检查下一个<code>case</code>，直到遇到<code>break</code>或者执行完所有匹配的<code>case</code>（如果没有<code>break</code>）。</li>
<li><strong>特点</strong>：不涉及并发，纯粹用于逻辑控制。</li>
</ul>
<h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><ul>
<li><p><strong>用途</strong>：专门用于处理channel的操作，如接收或发送数据。它是Go语言并发模型中的一个重要组件，用于实现非阻塞的IO多路复用。</p>
</li>
<li><p><strong>适用场景</strong>：当你需要同时监听多个channel上的事件并作出响应时，比如在处理网络连接、信号量或是其他并发任务的协调时。</p>
</li>
<li><p><strong>控制流</strong>：非确定性选择，当有多个channel操作准备就绪时，会选择一个随机的（实际上是由运行时决定的）channel执行。如果没有channel准备好，select会阻塞，直到至少有一个channel可操作。</p>
</li>
<li><p>特点</p>
<p>：</p>
<ul>
<li>可以有default子句，用于在没有任何channel操作准备就绪时执行。</li>
<li>如果有多个channel同时就绪，select会随机选择一个执行，这对于需要公平性的情况需要注意。</li>
<li>可以用来实现超时机制，通过配合time.After函数的channel。</li>
</ul>
</li>
</ul>
<p>总结来说，<code>switch</code>是用于控制流程的决策，基于表达式的值；而<code>select</code>则专注于并发编程中的通信，特别是与channel相关的操作，提供了在多个并发活动之间进行选择的能力。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go语言中的<code>strings</code>包提供了许多用于操作字符串的实用函数。以下是一些最常用的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go">**<span class="hljs-string">`Contains(s, substr string) bool`</span>**<br>- 检查字符串<span class="hljs-string">`s`</span>是否包含子字符串<span class="hljs-string">`substr`</span>。如果包含，返回<span class="hljs-string">`true`</span>；否则返回<span class="hljs-string">`false`</span>。<br><br>**<span class="hljs-string">`Count(s, sep string) int`</span>**<br>- 计算字符串<span class="hljs-string">`s`</span>中非重叠的<span class="hljs-string">`sep`</span>出现次数。如果<span class="hljs-string">`sep`</span>为空，则返回<span class="hljs-string">`s`</span>中字符（非字节）的数量加一。<br><br>**<span class="hljs-string">`EqualFold(s, t string) bool`</span>**<br>- 比较<span class="hljs-string">`s`</span>和<span class="hljs-string">`t`</span>是否相等，忽略大小写。<br><br>**<span class="hljs-string">`Fields(s string) []string`</span>**<br>- 根据空白字符分割字符串<span class="hljs-string">`s`</span>，返回一个由字段组成的切片。<br><br>**<span class="hljs-string">`FieldsFunc(s string, f func(rune) bool) []string`</span>**<br>- 使用函数<span class="hljs-string">`f`</span>作为分隔符来分割<span class="hljs-string">`s`</span>，其中<span class="hljs-string">`f`</span>应该返回<span class="hljs-string">`true`</span>以指示分隔符。<br><br>**<span class="hljs-string">`Index(s, sep string) int`</span>**<br>- 返回<span class="hljs-string">`s`</span>中<span class="hljs-string">`sep`</span>第一次出现的索引，如果未找到则返回<span class="hljs-string">`-1`</span>。<br><br>**<span class="hljs-string">`Join(a []string, sep string) string`</span>**<br>- 使用<span class="hljs-string">`sep`</span>连接切片<span class="hljs-string">`a`</span>中的字符串元素。<br><br>**<span class="hljs-string">`LastIndex(s, sep string) int`</span>**<br>- 返回<span class="hljs-string">`s`</span>中最后一次<span class="hljs-string">`sep`</span>出现的索引，如果未找到则返回<span class="hljs-string">`-1`</span>。<br><br>**<span class="hljs-string">`Map(f func(rune) rune, s string) string`</span>**<br>- 将函数<span class="hljs-string">`f`</span>应用于<span class="hljs-string">`s`</span>中的每个字符，然后返回结果字符串。<br><br>**<span class="hljs-string">`Repeat(s string, count int) string`</span>**<br>- 返回<span class="hljs-string">`s`</span>重复<span class="hljs-string">`count`</span>次的结果。<br><br>**<span class="hljs-string">`Replace(s, old, new string, n int) string`</span>**<br>- 将<span class="hljs-string">`s`</span>中的前<span class="hljs-string">`n`</span>个<span class="hljs-string">`old`</span>替换为<span class="hljs-string">`new`</span>。如果<span class="hljs-string">`n`</span>小于<span class="hljs-number">0</span>，则替换所有出现。<br><br>**<span class="hljs-string">`Split(s, sep string) []string`</span>**<br>- 根据<span class="hljs-string">`sep`</span>分割<span class="hljs-string">`s`</span>，返回一个由子字符串组成的切片。<br><br>**<span class="hljs-string">`SplitAfter(s, sep string) []string`</span>**<br>- 类似于<span class="hljs-string">`Split`</span>，但在每个分割点之后保留<span class="hljs-string">`sep`</span>。<br><br>**<span class="hljs-string">`SplitN(s, sep string, n int) []string`</span>**<br>- 类似于<span class="hljs-string">`Split`</span>，但最多分割<span class="hljs-string">`n-1`</span>次，从而得到<span class="hljs-string">`n`</span>个元素。<br><br>**<span class="hljs-string">`Title(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为标题大小写，即每个单词的第一个字母大写，其余小写。<br><br>**<span class="hljs-string">`ToLower(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为小写。<br><br>**<span class="hljs-string">`ToUpper(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为大写。<br><br>**<span class="hljs-string">`Trim(s string, cutset string) string`</span>**<br>- 移除<span class="hljs-string">`s`</span>前后两端的<span class="hljs-string">`cutset`</span>字符。<br><br>**<span class="hljs-string">`TrimSpace(s string) string`</span>**<br>- 移除<span class="hljs-string">`s`</span>前后两端的空白字符。<br><br>**<span class="hljs-string">`HasPrefix(s, prefix string) bool`</span>**<br>- 检查<span class="hljs-string">`s`</span>是否以<span class="hljs-string">`prefix`</span>开始。<br><br>**<span class="hljs-string">`HasSuffix(s, suffix string) bool`</span>**<br>   - 检查<span class="hljs-string">`s`</span>是否以<span class="hljs-string">`suffix`</span>结束。<br></code></pre></td></tr></table></figure>





<p>这些函数提供了强大的字符串处理能力，可以满足大多数字符串操作的需求</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Go%E7%AC%94%E8%AE%B0/" class="category-chain-item">Go笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Go/" class="print-no-link">#Go</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>语法笔记</div>
      <div>http://gondmhd.github.io/2024/12/10/go/语法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Gond</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/12/10/go/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7/" title="版本更新特性">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">版本更新特性</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/10/go/reflect%E5%8C%85%E5%8F%8D%E5%B0%84/" title="reflect反射笔记">
                        <span class="hidden-mobile">reflect反射笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
