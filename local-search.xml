<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql主从复制实践</title>
    <link href="/2025/04/13/go/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/04/13/go/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql主从复制实践"><a href="#mysql主从复制实践" class="headerlink" title="mysql主从复制实践"></a>mysql主从复制实践</h1><h2 id="1、部署主从两个mysql节点"><a href="#1、部署主从两个mysql节点" class="headerlink" title="1、部署主从两个mysql节点"></a>1、部署主从两个mysql节点</h2><p>本次使用docker-compose.yml 进行部署</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">Demo</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">33307</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data1:/var/lib/mysql</span><br>      <span class="hljs-comment"># - ./master/config/my.cnf:/etc/my.cnf</span><br>  <span class="hljs-attr">mysql2:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">Demo</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">33308</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data2:/var/lib/mysql</span><br>      <span class="hljs-comment"># - ./slaver/config/my.cnf:/etc/my.cnf</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data1:</span><br>  <span class="hljs-attr">mysql_data2:</span><br></code></pre></td></tr></table></figure><p>使用docker-compose启动mysql主从容器，然后使用命令从容器内部复制配置文件到主机里面，将注释去掉重启容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose <span class="hljs-built_in">cp</span> mysql1:/etc/my.cnf ./master/config/my.cnf<span class="hljs-comment"># 主节点配置文件copy</span><br>docker-compose <span class="hljs-built_in">cp</span> mysql2:/etc/my.cnf ./slaver/config/my.cnf<span class="hljs-comment"># 从节点配置文件拷贝</span><br></code></pre></td></tr></table></figure><h2 id="2、修改主从复制配置文件"><a href="#2、修改主从复制配置文件" class="headerlink" title="2、修改主从复制配置文件"></a>2、修改主从复制配置文件</h2><p>主文件修改：直接覆盖文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs txt">vim my.cnf<br><br>[mysqld]#修改配置文件：vim /etc/my.cnf<br>[mysqld]<br># 主库唯一 ID（从库需设为不同值，如 2）<br>server-id=1<br># 启用二进制日志<br>log-bin=mysql-bin<br># 二进制日志格式（ROW 模式更适合主从复制）<br>binlog-format=ROW<br># 不记录到二进制日志的数据库（按需配置）<br># binlog-ignore-db=mysql<br># 允许从库连接的 IP 范围（% 表示所有）<br>bind-address=0.0.0.0<br># 字符集<br>character-set-server=utf8mb4<br># 跳过 DNS 解析（提高连接速度）<br>skip-name-resolve<br><br></code></pre></td></tr></table></figure><p>从文件修改：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">[mysqld]<br>#从服务器唯一ID<br>server-id=2<br>#启用中继日志<br>relay-log=mysql-relay<br></code></pre></td></tr></table></figure><p>重启容器配置</p><h2 id="3、搭建主从复制"><a href="#3、搭建主从复制" class="headerlink" title="3、搭建主从复制"></a>3、搭建主从复制</h2><p>3.1主机设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose exec -it mysql1  /bin/bash# 进入容器<br>mysql -uroot -padmin# 登陆数据库<br>或者<br>docker-compose exec -it mysql1 mysql -uroot -padmin<br></code></pre></td></tr></table></figure><p> 3.1 主机上建立帐户并授权 slave</p><p>给从机授权，为了让从机能够和主机连接起来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;123456&#x27;</span>;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br><br></code></pre></td></tr></table></figure><p>3.3 查询master状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">show master status; <span class="hljs-comment">#查询master的状态</span><br><br>mysql&gt; show master status;<br>+------------------+----------+--------------+------------------+-------------------+<br>| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+------------------+----------+--------------+------------------+-------------------+<br>| mysql-bin.000001 |      154 |              |                  |                   |<br>+------------------+----------+--------------+------------------+-------------------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><br>Binlog_Do_DB：需要复制的数据库。<br>Binlog_Ignore_DB：不需要复制的数据库。<br></code></pre></td></tr></table></figure><p>3.4 从机设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose <span class="hljs-built_in">exec</span> -it mysql2  /bin/bash<span class="hljs-comment"># 进入容器</span><br>mysql -uroot -padmin<span class="hljs-comment"># 登陆数据库</span><br>或者<br>docker-compose <span class="hljs-built_in">exec</span> -it mysql2 mysql -uroot -padmin<br></code></pre></td></tr></table></figure><p>复制主机的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">CHANGE MASTER TO MASTER_HOST=<span class="hljs-string">&#x27;mysql1&#x27;</span>,MASTER_USER=<span class="hljs-string">&#x27;slave&#x27;</span>,MASTER_PASSWORD=<span class="hljs-string">&#x27;123456&#x27;</span>,MASTER_PORT=3306, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=154;<br><span class="hljs-comment">#解释：</span><br><span class="hljs-comment"># CHANGE MASTER TO MASTER_HOST=&#x27;172.16.0.3&#x27;,使用容器名称</span><br><span class="hljs-comment">#MASTER_USER=&#x27;slave&#x27;(刚刚配置的用户名),</span><br><span class="hljs-comment">#MASTER_PASSWORD=&#x27;123456&#x27;(刚刚授权的密码),</span><br><span class="hljs-comment">#master_port=主机开放的端口 使用容器内部网络端口3306,</span><br><span class="hljs-comment">#MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="hljs-comment">#MASTER_LOG_POS=具体值(之前的Position);</span><br><br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql&gt; CHANGE MASTER TO MASTER_HOST=<span class="hljs-string">&#x27;mysql1&#x27;</span>,MASTER_USER=<span class="hljs-string">&#x27;slave&#x27;</span>,MASTER_PASSWORD=<span class="hljs-string">&#x27;123456&#x27;</span>,MASTER_PORT=3306, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=154;<br>Query OK, 0 rows affected, 2 warnings (0.03 sec)<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项：&#x3D;&#x3D;这里如果出现错误，先重置。执行完下面两条命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">stop slave;<br>reset master;<br></code></pre></td></tr></table></figure><p><strong>启动从服务器复制功能</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql&gt; start slave;<br>Query OK, 0 rows affected (0.05 sec)<br></code></pre></td></tr></table></figure><p>查看从服务器状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sh">show slave status\G;<br><br>*************************** 1. row ***************************<br>               Slave_IO_State: Waiting <span class="hljs-keyword">for</span> master to send event<br>                  Master_Host: mysql1<br>                  Master_User: slave<br>                  Master_Port: 3306<br>                Connect_Retry: 60<br>              Master_Log_File: mysql-bin.000001<br>          Read_Master_Log_Pos: 154<br>               Relay_Log_File: mysql-relay.000002<br>                Relay_Log_Pos: 320<br>        Relay_Master_Log_File: mysql-bin.000001<br>             Slave_IO_Running: Yes<br>            Slave_SQL_Running: Yes<br>              Replicate_Do_DB: <br>          Replicate_Ignore_DB: <br>           Replicate_Do_Table: <br>       Replicate_Ignore_Table: <br>      Replicate_Wild_Do_Table: <br>  Replicate_Wild_Ignore_Table: <br>                   Last_Errno: 0<br>                   Last_Error: <br>                 Skip_Counter: 0<br>          Exec_Master_Log_Pos: 154<br>              Relay_Log_Space: 523<br>              Until_Condition: None<br>               Until_Log_File: <br>                Until_Log_Pos: 0<br>           Master_SSL_Allowed: No<br>           Master_SSL_CA_File: <br>           Master_SSL_CA_Path: <br>              Master_SSL_Cert: <br>            Master_SSL_Cipher: <br>               Master_SSL_Key: <br>        Seconds_Behind_Master: 0<br>Master_SSL_Verify_Server_Cert: No<br>                Last_IO_Errno: 0<br>                Last_IO_Error: <br>               Last_SQL_Errno: 0<br>               Last_SQL_Error: <br>  Replicate_Ignore_Server_Ids: <br>             Master_Server_Id: 1<br>                  Master_UUID: 6b47696b-17ad-11f0-8b0f-0242ac160002<br>             Master_Info_File: /var/lib/mysql/master.info<br>                    SQL_Delay: 0<br>          SQL_Remaining_Delay: NULL<br>      Slave_SQL_Running_State: Slave has <span class="hljs-built_in">read</span> all relay <span class="hljs-built_in">log</span>; waiting <span class="hljs-keyword">for</span> more updates<br>           Master_Retry_Count: 86400<br>                  Master_Bind: <br>      Last_IO_Error_Timestamp: <br>     Last_SQL_Error_Timestamp: <br>               Master_SSL_Crl: <br>           Master_SSL_Crlpath: <br>           Retrieved_Gtid_Set: <br>            Executed_Gtid_Set: <br>                Auto_Position: 0<br>         Replicate_Rewrite_DB: <br>                 Channel_Name: <br>           Master_TLS_Version: <br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><br>ERROR: <br>No query specified<br><br></code></pre></td></tr></table></figure><p>下面两个参数都是Yes，则说明主从配置成功！</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Slave_IO_Running:</span> <span class="hljs-literal">Yes</span> <br><span class="hljs-attr">Slave_SQL_Running:</span> <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure><h2 id="4、测试主从复制"><a href="#4、测试主从复制" class="headerlink" title="4、测试主从复制"></a>4、测试主从复制</h2><p>连上 主数据库，本地连接配置，看docker-compose.yml文件中的mysql1</p><p>连上 从数据库，本地连接配置，看docker-compose.yml文件中的mysql2</p><p>在主数据库中执行命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br>USE test;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT, name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Alice&#x27;</span>), (<span class="hljs-string">&#x27;Bob&#x27;</span>);<br></code></pre></td></tr></table></figure><p>发现从数据库也增加了对应的库表。</p><h2 id="5、重置配置主从"><a href="#5、重置配置主从" class="headerlink" title="5、重置配置主从"></a>5、重置配置主从</h2><p>如何停止从服务配置功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">stop slave; <br></code></pre></td></tr></table></figure><p>如何重新配置主从 （即清除之前的主从配置）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">stop slave;<br>reset master;<br></code></pre></td></tr></table></figure><h2 id="6、golang-简单使用"><a href="#6、golang-简单使用" class="headerlink" title="6、golang 简单使用"></a>6、golang 简单使用</h2><p>下载依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">go get <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>go get <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>go get <span class="hljs-string">&quot;gorm.io/plugin/dbresolver&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><span class="hljs-string">&quot;gorm.io/plugin/dbresolver&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DBConfig <span class="hljs-keyword">struct</span> &#123;<br>MasterDSN <span class="hljs-type">string</span><br>SlaveDSNs []<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Users <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">uint</span><br>Name      <span class="hljs-type">string</span><br>Email     <span class="hljs-type">string</span><br>CreatedAt time.Time<br>&#125;<br><br><span class="hljs-comment">// TableName 方法为 Users 结构体指定表别名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Users)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dbConfig := DBConfig&#123;<br>MasterDSN: <span class="hljs-string">&quot;root:admin@tcp(127.0.0.1:33307)/test?parseTime=true&quot;</span>,<br>SlaveDSNs: []<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;root:admin@tcp(127.0.0.1:33308)/test?parseTime=true&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 初始化数据库连接</span><br>db, err := gorm.Open(mysql.Open(dbConfig.MasterDSN), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 配置读写分离</span><br>err = db.Use(dbresolver.Register(dbresolver.Config&#123;<br>Sources: []gorm.Dialector&#123;mysql.Open(dbConfig.MasterDSN)&#125;, <span class="hljs-comment">// 写操作源</span><br>Replicas: []gorm.Dialector&#123; <span class="hljs-comment">// 读操作源</span><br>mysql.Open(dbConfig.SlaveDSNs[<span class="hljs-number">0</span>]),<br>&#125;,<br>Policy: dbresolver.RandomPolicy&#123;&#125;, <span class="hljs-comment">// 使用随机选择从库</span><br>&#125;))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to setup db resolver&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 配置连接池</span><br>sqlDB, err := db.DB()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)<br>sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)<br>sqlDB.SetConnMaxLifetime(time.Hour)<br><br><span class="hljs-comment">/*// 自动迁移表结构</span><br><span class="hljs-comment">db.AutoMigrate(&amp;Users&#123;&#125;)*/</span><br><br><span class="hljs-comment">//testCS(db)</span><br><span class="hljs-comment">//readFromMasterV2(db)</span><br><span class="hljs-comment">//transactionDemo(db)</span><br><br><span class="hljs-comment">// 事务外混合操作</span><br>db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 自动使用主库</span><br><span class="hljs-keyword">var</span> u Users<br>tx.First(&amp;u, <span class="hljs-number">1</span>) <span class="hljs-comment">// 自动主库</span><br>log.Println(u)<br><br><span class="hljs-keyword">if</span> err := tx.Create(&amp;Users&#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>db.Clauses(dbresolver.Read).First(&amp;u, <span class="hljs-number">1</span>) <span class="hljs-comment">// 显式指定（非必须） 使用tx 会自动读取主库 db则会根据需求读取</span><br>log.Println(u)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testCS</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br><span class="hljs-comment">// 写操作示例（使用主库）</span><br>user := Users&#123;Name: <span class="hljs-string">&quot;John3&quot;</span>, Email: <span class="hljs-string">&quot;john3@example.com&quot;</span>&#125;<br>result := db.Create(&amp;user)<br><span class="hljs-keyword">if</span> result.Error != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(result.Error)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Created user ID: %d\n&quot;</span>, user.ID)<br><br><span class="hljs-comment">// 读操作示例（使用从库）</span><br><span class="hljs-keyword">var</span> readUser Users<br>db.First(&amp;readUser, user.ID)<br>fmt.Printf(<span class="hljs-string">&quot;Read user: %+v\n&quot;</span>, readUser)<br><br><span class="hljs-comment">// 更新操作示例（使用主库）</span><br>db.Model(&amp;user).Update(<span class="hljs-string">&quot;Email&quot;</span>, <span class="hljs-string">&quot;new@example.com&quot;</span>)<br><br><span class="hljs-comment">// 查询操作示例（使用从库）</span><br><span class="hljs-keyword">var</span> updatedUser Users<br>db.First(&amp;updatedUser, <span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Updated user: %+v\n&quot;</span>, updatedUser)<br>&#125;<br><br><span class="hljs-comment">// 方式 1：使用 Clauses 强制走主库</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFromMaster</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br><span class="hljs-keyword">var</span> user Users<br>db.Clauses(dbresolver.Write).First(&amp;user, <span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;从主分支：&quot;</span>, user)<br>&#125;<br><br><span class="hljs-comment">// 方式 2：使用 Session 配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFromMasterV2</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br><span class="hljs-keyword">var</span> user Users<br>db.Session(&amp;gorm.Session&#123;QueryFields: <span class="hljs-literal">true</span>&#125;).Clauses(dbresolver.Write).First(&amp;user, <span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;From master:&quot;</span>, user)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transactionDemo</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br><span class="hljs-comment">// 开始事务</span><br>tx := db.Begin()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>tx.Rollback()<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 事务内操作（自动使用主库）</span><br><span class="hljs-comment">// 创建用户</span><br>newUser := Users&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Email: <span class="hljs-string">&quot;alice@example.com&quot;</span>&#125;<br><span class="hljs-keyword">if</span> err := tx.Create(&amp;newUser).Error; err != <span class="hljs-literal">nil</span> &#123;<br>tx.Rollback()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 事务内查询（自动使用主库）</span><br><span class="hljs-keyword">var</span> latestUser Users<br><span class="hljs-keyword">if</span> err := tx.Last(&amp;latestUser).Error; err != <span class="hljs-literal">nil</span> &#123;<br>tx.Rollback()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 更新操作</span><br><span class="hljs-keyword">if</span> err := tx.Model(&amp;latestUser).Update(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;new_alice@example.com&quot;</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br>tx.Rollback()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 提交事务</span><br><span class="hljs-keyword">if</span> err := tx.Commit().Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;commit failed: &quot;</span> + err.Error())<br>&#125;<br>log.Println(<span class="hljs-string">&quot;事务操作成功&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上就是简单的读写分离操作了，事务里面的操作默认是走的主库，也可以手动指定</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码设计模式</title>
    <link href="/2025/04/11/go/golang%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/04/11/go/golang%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="golang-设计模式"><a href="#golang-设计模式" class="headerlink" title="golang 设计模式"></a>golang 设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>工厂模式是一种创建对象的设计模式，它将对象的创建和使用分离，把对象创建逻辑封装在一个工厂类或工厂函数中，这样可以提高代码的可维护性和可扩展性。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><strong>简单工厂模式</strong>：一个工厂类负责创建所有类型的对象。</li><li><strong>工厂方法模式</strong>：定义一个创建对象的接口，让子类决定实例化哪个类。</li><li><strong>抽象工厂模式</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li></ul><p><strong>Go 语言实现简单工厂模式示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Product 定义产品接口</span><br><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">interface</span> &#123;<br>    Use()<br>&#125;<br><br><span class="hljs-comment">// ConcreteProductA 具体产品A</span><br><span class="hljs-keyword">type</span> ConcreteProductA <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ConcreteProductA)</span></span> Use() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Using ConcreteProductA&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// ConcreteProductB 具体产品B</span><br><span class="hljs-keyword">type</span> ConcreteProductB <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ConcreteProductB)</span></span> Use() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Using ConcreteProductB&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Factory 简单工厂</span><br><span class="hljs-keyword">type</span> Factory <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// CreateProduct 根据类型创建产品</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Factory)</span></span> CreateProduct(productType <span class="hljs-type">string</span>) Product &#123;<br>    <span class="hljs-keyword">switch</span> productType &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span>:<br>        <span class="hljs-keyword">return</span> &amp;ConcreteProductA&#123;&#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span>:<br>        <span class="hljs-keyword">return</span> &amp;ConcreteProductB&#123;&#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    factory := &amp;Factory&#123;&#125;<br>    productA := factory.CreateProduct(<span class="hljs-string">&quot;A&quot;</span>)<br>    productA.Use()<br><br>    productB := factory.CreateProduct(<span class="hljs-string">&quot;B&quot;</span>)<br>    productB.Use()<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>解耦对象的创建和使用</strong>：使用者只需关注产品的使用，无需关心产品的创建细节。</li><li><strong>提高代码的可维护性和可扩展性</strong>：当需要添加新的产品类型时，只需修改工厂类的创建逻辑。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>工厂类职责过重</strong>：简单工厂模式中，工厂类负责创建所有类型的对象，当产品类型过多时，工厂类的代码会变得复杂。</li><li><strong>不符合开闭原则</strong>：每次添加新的产品类型，都需要修改工厂类的代码。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>策略模式定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端。</p><p><strong>Go 语言实现策略模式示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Strategy 定义策略接口</span><br><span class="hljs-keyword">type</span> Strategy <span class="hljs-keyword">interface</span> &#123;<br>    Execute()<br>&#125;<br><br><span class="hljs-comment">// ConcreteStrategyA 具体策略A</span><br><span class="hljs-keyword">type</span> ConcreteStrategyA <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ConcreteStrategyA)</span></span> Execute() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Executing Strategy A&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// ConcreteStrategyB 具体策略B</span><br><span class="hljs-keyword">type</span> ConcreteStrategyB <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *ConcreteStrategyB)</span></span> Execute() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Executing Strategy B&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Context 上下文</span><br><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br>    strategy Strategy<br>&#125;<br><br><span class="hljs-comment">// SetStrategy 设置策略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetStrategy(strategy Strategy) &#123;<br>    c.strategy = strategy<br>&#125;<br><br><span class="hljs-comment">// ExecuteStrategy 执行策略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ExecuteStrategy() &#123;<br>    <span class="hljs-keyword">if</span> c.strategy != <span class="hljs-literal">nil</span> &#123;<br>        c.strategy.Execute()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    context := &amp;Context&#123;&#125;<br><br>    strategyA := &amp;ConcreteStrategyA&#123;&#125;<br>    context.SetStrategy(strategyA)<br>    context.ExecuteStrategy()<br><br>    strategyB := &amp;ConcreteStrategyB&#123;&#125;<br>    context.SetStrategy(strategyB)<br>    context.ExecuteStrategy()<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>算法可替换</strong>：客户端可以根据需要动态地选择不同的算法。</li><li><strong>符合开闭原则</strong>：当需要添加新的算法时，只需实现策略接口，无需修改上下文类。</li><li><strong>解耦算法和客户端</strong>：算法的实现和使用分离，提高了代码的可维护性和可扩展性。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>策略类数量过多</strong>：当策略较多时，会导致策略类的数量增加，增加代码的复杂度。</li><li><strong>客户端需要了解所有策略</strong>：客户端需要了解所有的策略类，才能选择合适的策略。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂模式主要关注对象的创建，通过工厂类或工厂函数来封装对象的创建逻辑；而策略模式主要关注算法的封装和替换，通过定义策略接口和具体策略类，让客户端可以动态地选择不同的算法。这两种模式都能提高代码的可维护性和可扩展性，在实际开发中可以根据具体需求选择合适的设计模式。</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-Nacos</title>
    <link href="/2025/04/10/tools/Go-Nacos/"/>
    <url>/2025/04/10/tools/Go-Nacos/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Nacos配置中心使用"><a href="#Go-Nacos配置中心使用" class="headerlink" title="Go-Nacos配置中心使用"></a>Go-Nacos配置中心使用</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>1、编写配置文件 <code>docker-compose.yaml</code></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.0&quot;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">Nacos</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nacos-standalone</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nacos/nacos-server:v2.2.0</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MODE=standalone</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">JVM_XMS=512m</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">JVM_MAX=512m</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">JVM_XMN=256m</span><br>    <span class="hljs-attribute">privileged</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;NACOS_DIR&#125;/data:/home/nacos/data</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-comment"># 8848 端口是 Nacos 服务的主端口，用于 HTTP 服务通信和管理控制台访问</span><br>      <span class="hljs-comment"># 客户端通过该端口进行服务注册、服务发现、配置获取等操作</span><br>      <span class="hljs-comment"># 也可通过浏览器访问 http://nacos-server:8848/nacos 打开管理控制台</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">8848:8848</span><br>      <span class="hljs-comment"># 9848 端口用于 Nacos 服务器与支持 gRPC 协议的客户端进行通信</span><br>      <span class="hljs-comment"># 客户端可使用该端口建立与 Nacos 服务器的长连接，实现高效的数据交互</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">9848:9848</span><br>      <span class="hljs-comment"># 9849 端口用于 Nacos 服务器集群内部节点之间通过 gRPC 协议进行通信</span><br>      <span class="hljs-comment"># 确保集群中各个节点的数据同步和一致性</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">9849:9849    </span><br><br></code></pre></td></tr></table></figure><p>2、docker-compose.yaml 同级目录创建隐藏文件，创建环境变量.env</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">vim .env<br><br>NACOS_DIR=/home/gond/work/db/nacos<br></code></pre></td></tr></table></figure><p>3、环境变量优秀级</p><ol><li><p>命令行中显式设置的环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker-compose -e <span class="hljs-attribute">DB_HOST</span>=custom_host up -d<br></code></pre></td></tr></table></figure></li><li><p><code>.env</code> 文件中定义的环境变量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DB_HOST</span>=default_host<br><span class="hljs-attr">DB_PORT</span>=<span class="hljs-number">5432</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker-compose.yml</code> 文件中直接硬编码的环境变量</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">myapp</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">myapp-image</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=hardcoded_host</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_PORT=5433</span><br></code></pre></td></tr></table></figure></li><li><p>主机环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">DB_HOST</span>=host_env_host<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>环境默认值配置技巧</p></blockquote><p>demo</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">myapp:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp-image</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=$&#123;DB_HOST:-localhost&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_PORT=$&#123;DB_PORT:-5432&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">APP_ENV=$&#123;APP_ENV:-development&#125;</span>   <br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="登陆平台"><a href="#登陆平台" class="headerlink" title="登陆平台"></a>登陆平台</h3><p>访问web地址</p><p>url: <a href="http://localhost:8848/nacos/#/login">http://localhost:8848/nacos/#/login</a></p><p>nacos&#x2F;nacos</p><h3 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20250410211114368.png?raw=true" alt="命名空间"></p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>找对对应的命名空间 上边我们创建的命名空间为 mhd<br><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20250410211541269.png?raw=true" alt="配置文件"></p><h3 id="golang获取nacos配置信息"><a href="#golang获取nacos配置信息" class="headerlink" title="golang获取nacos配置信息"></a>golang获取nacos配置信息</h3><p>安装依赖</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/nacos-group/nacos-sdk-<span class="hljs-keyword">go</span>/v2<br></code></pre></td></tr></table></figure><p>简单获取nacos配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/clients&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/common/constant&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/vo&quot;</span><br><br><span class="hljs-string">&quot;gopkg.in/yaml.v3&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 解析config.yml配置文件 和上边的字段保持一致</span><br><br><span class="hljs-keyword">type</span> NacosTestConfig <span class="hljs-keyword">struct</span> &#123;<br>Name     <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;Name&quot;`</span><br>ListenOn <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;ListenOn&quot;`</span><br>Etcd     Etcd   <span class="hljs-string">`yaml:&quot;Etcd&quot;`</span><br>&#125;<br><span class="hljs-keyword">type</span> Etcd <span class="hljs-keyword">struct</span> &#123;<br>Hosts []<span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;Hosts&quot;`</span><br>Key   <span class="hljs-type">string</span>   <span class="hljs-string">`yaml:&quot;Key&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>serverConfig := []constant.ServerConfig&#123;<br>&#123;<br>IpAddr: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-comment">//nacos 地址</span><br>Port:   <span class="hljs-number">8848</span>,        <span class="hljs-comment">//nacos 端口</span><br>&#125;,<br>&#125;<br><br>clientConfig := &amp;constant.ClientConfig&#123;<br>NamespaceId:         <span class="hljs-string">&quot;1d920a58-2a12-48dd-8354-88170c2dc758&quot;</span>, <span class="hljs-comment">//命名空间 比较重要 拿取刚才创建的命名空间ID</span><br>TimeoutMs:           <span class="hljs-number">5000</span>,<br>NotLoadCacheAtStart: <span class="hljs-literal">true</span>,<br>LogDir:              <span class="hljs-string">&quot;/tmp/nacos/log&quot;</span>,<br>CacheDir:            <span class="hljs-string">&quot;/tmp/nacos/cache&quot;</span>,<br>LogLevel:            <span class="hljs-string">&quot;debug&quot;</span>,<br>&#125;<br><br>configClient, err := clients.NewConfigClient(<br>vo.NacosClientParam&#123;<br>ClientConfig:  clientConfig,<br>ServerConfigs: serverConfig,<br>&#125;,<br>)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//读取配置文件失败</span><br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> dataId = <span class="hljs-string">&quot;config.yaml&quot;</span><br><span class="hljs-keyword">var</span> group = <span class="hljs-string">&quot;dev&quot;</span><br>content, err := configClient.GetConfig(vo.ConfigParam&#123;<br>DataId: dataId, <span class="hljs-comment">//配置文件名</span><br>Group:  group,  <span class="hljs-comment">//配置文件分组</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//读取配置文件失败</span><br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(content) <span class="hljs-comment">//这里我们打印一下配置文件的内容</span><br><br><span class="hljs-comment">// 解析配置文件</span><br><span class="hljs-keyword">var</span> nacosTestConfig *NacosTestConfig<br>yaml.Unmarshal([]<span class="hljs-type">byte</span>(content), &amp;nacosTestConfig)<br>fmt.Println(nacosTestConfig) <span class="hljs-comment">//这里我们打印一下解析后的配置文件内容</span><br><br><span class="hljs-comment">// 监听配置文件变化</span><br>err = configClient.ListenConfig(vo.ConfigParam&#123;<br>DataId: dataId, <span class="hljs-comment">//配置文件名</span><br>Group:  group,<br>OnChange: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace, group, dataId, data <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;配置文件发生变化:&quot;</span>, dataId, group, namespace)<br>fmt.Println(data) <span class="hljs-comment">//这里我们打印一下配置文件的内容</span><br><span class="hljs-comment">// 解析配置文件</span><br><span class="hljs-keyword">var</span> nacosTestConfig *NacosTestConfig<br>yaml.Unmarshal([]<span class="hljs-type">byte</span>(data), &amp;nacosTestConfig)<br>fmt.Println(nacosTestConfig) <span class="hljs-comment">//这里我们打印一下解析后的配置文件内容</span><br>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>time.Sleep(time.Second * <span class="hljs-number">100</span>) <span class="hljs-comment">// 这里我们休眠100秒，等待配置文件变化</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">Name: usercenter.rpc<br>ListenOn: 0.0.0.0:8080<br>Etcd:<br>  Hosts:<br>  - 127.0.0.1:2379<br>  Key: usercenter.rpc<br><br>&amp;&#123;usercenter.rpc 0.0.0.0:8080 &#123;[127.0.0.1:2379] usercenter.rpc&#125;&#125;<br>配置文件发生变化: config.yaml dev 1d920a58-2a12-48dd-8354-88170c2dc758<br>Name: Testusercenter.rpc<br>ListenOn: 0.0.0.0:8080<br>Etcd:<br>  Hosts:<br>  - 127.0.0.1:2379<br>  Key: usercenter.rpc<br><br>&amp;&#123;Testusercenter.rpc 0.0.0.0:8080 &#123;[127.0.0.1:2379] usercenter.rpc&#125;&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDb 介绍</title>
    <link href="/2025/03/06/tools/MongoDb%E5%85%A5%E9%97%A8/"/>
    <url>/2025/03/06/tools/MongoDb%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDb入门"><a href="#MongoDb入门" class="headerlink" title="MongoDb入门"></a>MongoDb入门</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h3><ul><li>MongoDB是一个基于<code>分布式文件存储</code>的数据库</li><li>由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB是一个介于<code>关系数据库</code>和<code>非关系数据库</code>之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li><li>支持的数据结构非常松散，是类似<code>json</code>的<code>bson</code>格式，因此可以存储比较复杂的数据类型。</li><li>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立<code>索引</code></li></ul><h3 id="2-业务应用场景"><a href="#2-业务应用场景" class="headerlink" title="2. 业务应用场景"></a>2. 业务应用场景</h3><p>传统的关系型数据库(如MySQL)，在数据操作的<code>三高</code>需求以及应对Web2.0的网站需求面前，显得力不从心，而 <a href="https://so.csdn.net/so/search?q=MongoDB&spm=1001.2101.3001.7020">MongoDB</a>可应对“三高“需求</p><ul><li><code>High performance</code>：对数据库高并发读写的需求</li><li><code>Huge Storage</code>：对海量数据的高效率存储和访问的需求</li><li><code>High Scalability &amp;&amp; High Availability</code>：对数据库的高可扩展性和高可用性的需求</li></ul><p><strong>具体应用场景</strong>：</p><ol><li>社交场景，使用 MongoDB存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。</li><li>游戏场景，使用 MongoDB存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。</li><li>物流场景，使用 MongoDB存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</li><li>物联网场景，使用 MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。</li><li>视频直播，使用 MongoDB存储用户信息、点赞互动信息等。</li></ol><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高</p><p>对于这样的数据，我们更适合使用 MongoDB来实现数据的存储。</p><h3 id="3、什么时候选择MongoDB"><a href="#3、什么时候选择MongoDB" class="headerlink" title="3、什么时候选择MongoDB"></a>3、什么时候选择MongoDB</h3><ul><li>应用不需要事务及复杂join支持</li><li>新应用，需求会变，数据模型无法确定，想快速迭代开发</li><li>应用需要2000-3000以上的读写QPS（更高也可以）</li><li>应用需要TB甚至PB级别数据存储</li><li>应用要求存储的数据不丢失</li><li>应用需要99.999%高可用</li><li>应用需要大量的地理位置查询、文本查</li></ul><p>相对MySQL，在以上以用场景可以以更低的成本解决问题（包括学习、开发、运维等成本）</p><h3 id="4、体系机构"><a href="#4、体系机构" class="headerlink" title="4、体系机构"></a>4、体系机构</h3><table><thead><tr><th><strong>SQL术语&#x2F;概念</strong></th><th>MongoDB术语&#x2F;概念</th><th>解释&#x2F;说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接，MongoDB不支持</td></tr><tr><td></td><td>嵌入文档</td><td>MongoDB通过嵌入式文档来代替多表连接</td></tr><tr><td>primary key</td><td>primary key</td><td>主健，Mongodb 自动将_id字段设置为主健</td></tr></tbody></table><h3 id="5、数据类型"><a href="#5、数据类型" class="headerlink" title="5、数据类型"></a>5、数据类型</h3><p>MongoDB的最小存储单位就是文档<code>document</code>对象。文档<code>document</code>对象对应于关系型数据库的行。数据在MongoDB中以<code>BSON（Binary-JSON）</code>文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称 Binary JSON；BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和Bin Data类型。</p><p>BSON采用了类似于C语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>BSON中，除了基本JSON类型： string，integer，boolean，double，null，array和object，mongo还使用了特殊的数据类型。这些类型包括 date， object id， binary data， regular expression和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息</p><p>BSON数据类型参考列表：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>描述</strong></th><th>举列</th></tr></thead><tbody><tr><td>字符串</td><td>UTF-8字符串都可以表示为字符串类型的数据</td><td>{“x”：“foobar”}</td></tr><tr><td>对象id</td><td>对象id是文档的12字节的唯一ID</td><td>{“x”:”ObjectId()”}</td></tr><tr><td>布尔值</td><td>真或者假：true或者false</td><td>{“x”:”true”}</td></tr><tr><td>数组</td><td>值的集合或者列表都可以表示成数组</td><td>shell是不支持该类型的，shell中默认会转换成64位浮点数</td></tr><tr><td>32位整数</td><td>类型不可用。Javascript仅支持64位浮点数，所以32位整数会被自动转换</td><td>shell 是不支持该类型的，shell中默认会转成64位浮点数</td></tr><tr><td>64位整数</td><td>不支持这个类型，shell会使用一个特殊的内嵌文档来显示64位整数</td><td>shell 是不支持该类型的，shell中默认会转成64位浮点数</td></tr><tr><td>64位浮点数</td><td>shell中的数字就是这一种类型</td><td>{“x”:3.14159,”y”:3}</td></tr><tr><td>null</td><td>表示空值或者未定义类型</td><td>{“x”:null}</td></tr><tr><td>undeined</td><td>文档中也可以使用未定义类型</td><td>{“x”:underfined}</td></tr><tr><td>符号</td><td>shell不支持，shell会将数据库中的符号类型的数据自动转换成字符串</td><td></td></tr><tr><td>正则表达式</td><td>文档中可以包含正则表达式，采用JavaScript的正则表达式语法</td><td>{“x”:&#x2F;foobar&#x2F;}</td></tr><tr><td>代码</td><td>文档中还可以包含JavaScript代码</td><td>{“x”:function(){&#x2F;<em>…</em>&#x2F;}}</td></tr><tr><td>二进制数据</td><td>二进制数据可以由任意字节的喘组成，不过shell中无法使用</td><td></td></tr><tr><td>最大值&#x2F;最小值</td><td>BSON包括一个特殊类型，表示可能的最大值，shell中没有这个类型</td><td></td></tr></tbody></table><blockquote><p>提示：shell默认使用64位浮点型数值。{“x”:3.14或{“x”:3}。对于整型值，可以使用NumberInt（4字节符号整数）或 NumberLong（8字节符号整数），{“x”:NumberInt(“3” ){“x”:NumberLong(“3”)}</p></blockquote><ol start="6"><li><p>特点</p><ol><li><p><strong>高性能</strong></p><p>MongoDB提供高性能的数据持久性。特别是，</p><p>对嵌入式数据模型的支持减少了数据库系统上I&#x2F;O活动。</p><p>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种O2O应用）</p></li><li><p><strong>高可用性</strong></p><p>MongoDB的复制工具称为副本集（ replica set），它可提供自动故障转移和数据冗余</p></li><li><p><strong>高扩展性</strong></p><p>MongoDB提供了水平可扩展性作为其核心功能的一部分。</p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p></li><li><p><strong>丰富的查询支持</strong></p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p></li><li><p><strong>其他特点</strong></p><p>如无模式（动态模式）、灵活的文档模型</p></li></ol></li></ol><h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><p><strong>docker-compose部署</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mongodb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mongo:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mongo</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;27017:27017&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/db:/data/db</span>  <span class="hljs-comment"># 持久化数据</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MONGO_INITDB_ROOT_USERNAME=admin</span>  <span class="hljs-comment"># 初始管理员用户名</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MONGO_INITDB_ROOT_PASSWORD=admin123</span>  <span class="hljs-comment"># 初始管理员密码</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">mongod</span> <span class="hljs-string">--auth</span>  <span class="hljs-comment"># 启用认证</span><br></code></pre></td></tr></table></figure><p>使用官方提供的安装包访问</p><p><a href="https://www.mongodb.com/try/download/compass">MongoDB ComPass</a></p><p>使用工具连接的时候i先关闭</p><p>ommand: mongod –auth  # 启用认证</p><h2 id="三、简单使用"><a href="#三、简单使用" class="headerlink" title="三、简单使用"></a>三、简单使用</h2><p><strong>前置准备</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Client *mongo.Client<br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">10</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-comment">// 设置客户端连接配置</span><br>clientOptions := options.Client().ApplyURI(<span class="hljs-string">&quot;mongodb://admin:admin123@localhost:27017&quot;</span>)<br>clientOptions.SetMaxPoolSize(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 连接到MongoDB</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>Client, err = mongo.Connect(ctx, clientOptions)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 检查连接</span><br>err = Client.Ping(ctx, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Connected to MongoDB!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>插入</p><p><code>插入单条数据</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br><br>student := User&#123;Name: <span class="hljs-string">&quot;张三&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>insertRes, err := collect.InsertOne(context.Context(context.Background()), student)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;单条插入成功，插入id为：：&quot;</span>, insertRes.InsertedID)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>插入多条数据</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertRows</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br>users := []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>&amp;User&#123;Name: <span class="hljs-string">&quot;张三&quot;</span>, Age: <span class="hljs-number">18</span>&#125;,<br>&amp;User&#123;Name: <span class="hljs-string">&quot;李四&quot;</span>, Age: <span class="hljs-number">19</span>&#125;,<br>&amp;User&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>, Age: <span class="hljs-number">20</span>&#125;,<br>&#125;<br>info, err := collect.InsertMany(context.Context(context.Background()), users)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;多条插入失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;多条插入成功，插入id为：：&quot;</span>, info.InsertedIDs)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改</p><p><code>修改单个</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br>filter := bson.D&#123;&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>&#125;&#125;<br>update := bson.D&#123;&#123;<span class="hljs-string">&quot;$set&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">31</span>&#125;&#125;&#125;&#125;<br>result, err := collect.UpdateOne(context.Background(), filter, update)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;修改单个文档失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;修改单个文档成功，受影响的文档数为：&quot;</span>, result.ModifiedCount)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>修改多个</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">upateRows</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br>filter := bson.D&#123;&#123;<span class="hljs-string">&quot;age&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;$gt&quot;</span>, <span class="hljs-number">25</span>&#125;&#125;&#125;&#125;<br>update := bson.D&#123;&#123;<span class="hljs-string">&quot;$set&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;isAdult&quot;</span>, <span class="hljs-literal">true</span>&#125;&#125;&#125;&#125;<br>result, err := collect.UpdateMany(context.Background(), filter, update)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;修改多个文档失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;修改多个文档成功，受影响的文档数为：&quot;</span>, result.ModifiedCount)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delete</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br>filter := bson.D&#123;&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>&#125;&#125;<br>result, err := collect.DeleteOne(context.Background(), filter)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;删除失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;删除成功，受影响的文档数为：&quot;</span>, result.DeletedCount)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查询</p><p><code>查询单个</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">query</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br>querinfo := bson.D&#123;&#123;<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>&#125;&#125;<br>info := &amp;User&#123;&#125;<br>err := collect.FindOne(context.Background(), querinfo).Decode(info)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;查询失败&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;查询成功，查询结果为：&quot;</span>, info)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>查询duoge</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryRows</span><span class="hljs-params">(collect *mongo.Collection)</span></span> &#123;<br><span class="hljs-comment">// 查询多个</span><br><span class="hljs-comment">// 将选项传递给Find()</span><br>findOptions := options.Find()<br>findOptions.SetLimit(<span class="hljs-number">2</span>) <span class="hljs-comment">// 匹配两个</span><br><span class="hljs-comment">// 定义一个切片用来存储查询结果</span><br><span class="hljs-keyword">var</span> results []User<br><span class="hljs-comment">//把bson.D&#123;&#123;&#125;&#125;作为一个filter来匹配所有文档 这里是查找文档中name为张三的</span><br>cur, err := collect.Find(context.TODO(), bson.D&#123;&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>&#125;&#125;, findOptions)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> cur.Next(context.TODO()) &#123;<br>str := User&#123;&#125;<br>err := cur.Decode(&amp;str)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>results = <span class="hljs-built_in">append</span>(results, str)<br>&#125;<br>cur.Close(context.TODO())<br>fmt.Println(results)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transactionExample</span><span class="hljs-params">(collection *mongo.Collection)</span></span> &#123;<br>session, err := Client.StartSession()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to start session: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> session.EndSession(context.Background())<br><br>err = session.StartTransaction()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to start transaction: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 在事务中插入一条记录</span><br>student := User&#123;Name: <span class="hljs-string">&quot;事务插入用户&quot;</span>, Age: <span class="hljs-number">22</span>&#125;<br>_, err = collection.InsertOne(context.Background(), student)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>session.AbortTransaction(context.Background())<br>log.Fatalf(<span class="hljs-string">&quot;Failed to insert document in transaction: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 在事务中更新一条记录</span><br>filter := bson.D&#123;&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>&#125;&#125;<br>update := bson.D&#123;&#123;<span class="hljs-string">&quot;$set&quot;</span>, bson.D&#123;&#123;<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">35</span>&#125;&#125;&#125;&#125;<br>_, err = collection.UpdateOne(context.Background(), filter, update)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>session.AbortTransaction(context.Background())<br>log.Fatalf(<span class="hljs-string">&quot;Failed to update document in transaction: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 提交事务</span><br>err = session.CommitTransaction(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to commit transaction: %v&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Transaction completed successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql使用</title>
    <link href="/2024/12/10/tools/Mysql%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/12/10/tools/Mysql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql用法"><a href="#Mysql用法" class="headerlink" title="Mysql用法"></a>Mysql用法</h1><h2 id="1、查询相关"><a href="#1、查询相关" class="headerlink" title="1、查询相关"></a>1、<code>查询相关</code></h2><hr><p><strong>使用like关键字进行模糊匹配:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27; %pattern%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>使用正则表达式进行查询:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">column</span> regexp <span class="hljs-string">&#x27;pattern&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>子查询（Nested Queries）</strong></p><p>子查询允许你将一个查询的结果作为另一个查询的条件。例如，查找订单金额大于平均订单金额的订单：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Orders<br><span class="hljs-keyword">WHERE</span> OrderAmount <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(OrderAmount) <span class="hljs-keyword">FROM</span> Orders);<br></code></pre></td></tr></table></figure><p><strong>联接查询（JOINs）</strong></p><p><strong>student</strong> :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">---------------------- student-----------------------</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>sex <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>submission_date <span class="hljs-type">date</span>,<br><span class="hljs-keyword">primary</span> key(id))engine<span class="hljs-operator">=</span>innodb <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (name, sex, submission_date)<br><span class="hljs-keyword">VALUES</span><br>    (&quot;张三&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;李四&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;王五&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;赵六&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;孙七&quot;, &quot;男&quot;, &quot;2010-10-10&quot;);<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">id</th><th align="center">name</th><th align="center">sex</th><th align="center">submission_date</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td><td align="center">2010-10-10</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">男</td><td align="center">2010-10-10</td></tr><tr><td align="center">3</td><td align="center">王五</td><td align="center">男</td><td align="center">2010-10-10</td></tr><tr><td align="center">4</td><td align="center">赵六</td><td align="center">男</td><td align="center">2010-10-10</td></tr><tr><td align="center">5</td><td align="center">孙七</td><td align="center">男</td><td align="center">2010-10-10</td></tr></tbody></table><p><strong>grade</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">------------------- grade-------------</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> grade(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>stuid <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>class <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>grade <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),<br><span class="hljs-keyword">primary</span> key(id))engine<span class="hljs-operator">=</span>innodb <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (name, sex, submission_date)<br><span class="hljs-keyword">VALUES</span><br>    (&quot;张三&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;李四&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;王五&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;赵六&quot;, &quot;男&quot;, &quot;2010-10-10&quot;),<br>    (&quot;孙七&quot;, &quot;男&quot;, &quot;2010-10-10&quot;);<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">id</th><th align="center">stuid</th><th align="center">class</th><th align="center">grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">计算机</td><td align="center">100</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">guitar</td><td align="center">90</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">美术</td><td align="center">80</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">美术</td><td align="center">80</td></tr><tr><td align="center">5</td><td align="center">2</td><td align="center">计算机</td><td align="center">70</td></tr><tr><td align="center">6</td><td align="center">2</td><td align="center">guitar</td><td align="center">60</td></tr><tr><td align="center">7</td><td align="center">3</td><td align="center">guitar</td><td align="center">50</td></tr></tbody></table><p><strong>查询每个学生的总成绩</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(grade),stuid <span class="hljs-keyword">from</span> grade <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stuid;# 查询总成绩<br><br><span class="hljs-keyword">select</span> stuid,<span class="hljs-built_in">avg</span>(grade) <span class="hljs-keyword">from</span> grade <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stuid;# 查询平均成绩<br></code></pre></td></tr></table></figure><p><strong>多表查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,<span class="hljs-built_in">sum</span>(grade) <span class="hljs-keyword">from</span> student a,grade b <span class="hljs-keyword">where</span> a.id <span class="hljs-operator">=</span> b.stuid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> b.stuid;<br></code></pre></td></tr></table></figure><p><strong>内连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,<span class="hljs-built_in">sum</span>(grade) <span class="hljs-keyword">from</span> student a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> grade b <span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.stuid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> b.stuid;<br><br># 对比直接多表查询（隐式连接）好处<br>## <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 明确指出了连接条件，使得查询更容易理解和维护。<br>## 以轻松地添加更多的 <span class="hljs-keyword">JOIN</span> 子句来连接更多表，而不需要修改现有的 <span class="hljs-keyword">WHERE</span> 子句。<br>## 使用 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 可以帮助数据库查询优化器更好地理解查询意图，从而选择更高效的执行计划。显式连接条件可以帮助优化器确定哪些索引可以被利用。<br></code></pre></td></tr></table></figure><p><strong>左联接（LEFT JOIN）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> grade b <span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span>b.stuid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> b.stuid;<br><br># a表的id在b表的stuid出现的话显示相关b表数据，若不出现在b表，则相关b表的数据列显示null.<br></code></pre></td></tr></table></figure><p><strong>右连接(RIGHT JOIN)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student a  <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> grade b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.stuid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a.id; <br><br># b表的stuid在a表的id出现的话显示相关a表数据，若不出现在a表，则相关a表的数据列显示<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="union-all和union的区别"><a href="#union-all和union的区别" class="headerlink" title="union all和union的区别"></a>union all和union的区别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>：用于合并多个查询结果，包括重复的行。<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> student <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> stuid <span class="hljs-keyword">from</span> grade;<br><br><br><span class="hljs-keyword">UNION</span>：用于合并多个查询结果，并且自动去除重复的行。<br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> student <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> stuid <span class="hljs-keyword">from</span> grade;<br></code></pre></td></tr></table></figure><h2 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h2><hr><p><strong>longtex类型</strong></p><p>“LONGTEXT”数据类型是一种比较大的文本类型，可以容纳最大长度为4 GB的字符数据。</p><p><strong>json类型</strong></p><ol><li>MySQL 5.7及更早版本：<ul><li>最大存储容量为64KB。</li></ul></li><li>MySQL 8.0：<ul><li>最大存储容量为4GB</li></ul></li></ol><p>使用longtext字段存储JSON或其他结构化数据存在一些潜在的问题:</p><ol><li>不便于索引和查询。longtext是非结构化文本,不能建立索引,不便于通过结构化字段进行精确或范围查询。</li><li>性能可能受影响。和直接使用json数据类型相比,从longtext中提取JSON需要额外的解析步骤,可能影响查询性能。</li><li>无法校验数据格式。longtext中存储的内容无法校验是否符合JSON规范,容易出现格式错误无法解析的情况。</li><li>可读性差。与专门的JSON字段相比,直接查看longtext内容无法清晰看出结构。</li><li>存储利用率低。JSON数据本身就很“紧凑”,使用longtext可能存在空间浪费。</li><li>不利于数据隔离。多个文档通常需要使用分隔符隔离,增加解析复杂性。</li><li>后续难扩展。如果需要使用更多JSON功能,就需要迁移数据格式。</li></ol><p><strong>如果条件允许, stronger的做法是直接使用json数据类型来存储和处理JSON内容。</strong></p><p><strong>整数类型</strong></p><ul><li>TINYINT: tinyint类型用于存储范围在-128到127之间的整数。它占1个字节。</li><li>SMALLINT:smallint类型用于存储范围在-32768到32767之间的整数。它占2个字节。</li><li>MEDIUMINT:mediumint类型用于存储范围在-8388608到8388607之间的整数。它占3个字节。</li><li>INT:int类型用于存储范围在-2147483648到2147483647之间的整数。它占4个字节。</li><li>BIGINT:bigint类型用于存储范围在-9,223,372,036,854,775,808到9,223,372,036,854,775,807之间的整数。它占8个字节。</li></ul><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><hr><p><strong>JSON_EXTRACT</strong></p><p>JSON_EXTRACT函数用于从JSON类型字段或变量中提取数据,它的语法形式为:</p><p>JSON_EXTRACT(json_doc, path)</p><p>参数说明:</p><ul><li>json_doc: JSON类型字段或变量,可以是长文本、VARCHAR等类型。</li><li>path: JSON路径表达式,使用点号.指定每个层级,用通配符*匹配多层。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 如果需要查出整行数据,可以在<span class="hljs-keyword">SELECT</span>和<span class="hljs-keyword">WHERE</span>中使用:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">WHERE</span> JSON_EXTRACT(metadata, <span class="hljs-string">&#x27;$.fields[0].fieldPath&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;id&#x27;</span><br><br># 单独执行JSON_EXTRACT语句,直接获取字段值:<br><span class="hljs-keyword">SELECT</span> JSON_EXTRACT(metadata, <span class="hljs-string">&#x27;$.fields[0].fieldPath&#x27;</span>) <br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br></code></pre></td></tr></table></figure><p><strong>常用函数</strong></p><table><thead><tr><th>类别</th><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>字符串函数</td><td><code>CHAR_LENGTH(str)</code></td><td>返回字符串 <code>str</code> 的长度（以字符为单位）。</td></tr><tr><td></td><td><code>CONCAT(str1, str2, ...)</code></td><td>连接一个或多个字符串。</td></tr><tr><td></td><td><code>LOWER(str)</code></td><td>将字符串 <code>str</code> 转换为小写。</td></tr><tr><td></td><td><code>UPPER(str)</code></td><td>将字符串 <code>str</code> 转换为大写。</td></tr><tr><td></td><td><code>SUBSTRING(str, start, len)</code></td><td>返回从位置 <code>start</code> 开始的 <code>len</code> 个字符。</td></tr><tr><td></td><td><code>REPLACE(str, find_str, replace_str)</code></td><td>替换字符串中的子串。</td></tr><tr><td>数学函数</td><td><code>ABS(X)</code></td><td>返回 <code>X</code> 的绝对值。</td></tr><tr><td></td><td><code>POW(X, Y)</code></td><td>返回 <code>X</code> 的 <code>Y</code> 次幂。</td></tr><tr><td></td><td><code>RAND()</code></td><td>返回一个随机数。</td></tr><tr><td></td><td><code>ROUND(X, D)</code></td><td>返回 <code>X</code> 四舍五入到 <code>D</code> 位小数的结果。</td></tr><tr><td>日期时间函数</td><td><code>NOW()</code></td><td>返回当前的日期和时间。</td></tr><tr><td></td><td><code>CURDATE()</code></td><td>返回当前的日期。</td></tr><tr><td></td><td><code>CURTIME()</code></td><td>返回当前的时间。</td></tr><tr><td></td><td><code>DATE_ADD(date, INTERVAL expr unit)</code></td><td>添加时间间隔。</td></tr><tr><td></td><td><code>TIMESTAMPDIFF(unit, datetime1, datetime2)</code></td><td>计算时间差。</td></tr><tr><td></td><td><code>FROM_UNIXTIME(unix_timestamp)</code></td><td>返回datetime时间戳</td></tr><tr><td></td><td><code>UNIX_TIMESTAMP(datetime)</code></td><td>返回unix时间戳</td></tr><tr><td>控制流函数</td><td><code>IF(condition, then, else)</code></td><td>根据条件返回不同值。</td></tr><tr><td></td><td><code>CASE</code></td><td>根据多个条件返回不同值。</td></tr><tr><td></td><td><code>COALESCE(expr1, expr2, ...)</code></td><td>返回第一个非空表达式的值。</td></tr><tr><td>加密解密函数</td><td><code>ENCODE(str, key_str)</code></td><td>使用 <code>key_str</code> 对 <code>str</code> 进行编码。</td></tr><tr><td></td><td><code>DECODE(str, key_str)</code></td><td>使用 <code>key_str</code> 对 <code>str</code> 进行解码。</td></tr><tr><td></td><td><code>MD5(str)</code></td><td>返回 <code>str</code> 的 MD5 散列值。</td></tr><tr><td></td><td><code>SHA1(str)</code></td><td>返回 <code>str</code> 的 SHA-1 散列值。</td></tr><tr><td></td><td><code>SHA2(str, bit_length)</code></td><td>返回 <code>str</code> 的 SHA-2 散列值。</td></tr><tr><td>聚合函数</td><td><code>COUNT(expr)</code></td><td>返回 <code>expr</code> 的行数。</td></tr><tr><td></td><td><code>SUM(expr)</code></td><td>返回 <code>expr</code> 的总和。</td></tr><tr><td></td><td><code>AVG(expr)</code></td><td>返回 <code>expr</code> 的平均值。</td></tr><tr><td></td><td><code>MIN(expr)</code></td><td>返回 <code>expr</code> 的最小值。</td></tr><tr><td></td><td><code>MAX(expr)</code></td><td>返回 <code>expr</code> 的最大值。</td></tr></tbody></table><h2 id="4、Mysql5-7和Mysql8-0优缺点"><a href="#4、Mysql5-7和Mysql8-0优缺点" class="headerlink" title="4、Mysql5.7和Mysql8.0优缺点"></a>4、Mysql5.7和Mysql8.0优缺点</h2><hr><p>MySQL 5.7优点:</p><ul><li>稳定性好,生态成熟。5.7版本已经用了很多年,Bug较少。</li><li>兼容性强,与5.6下的应用兼容性好。</li><li>功能完善,支持多种存储引擎。</li><li>性能优化成熟,查询效率高。</li></ul><p>MySQL 5.7缺点:</p><ul><li>不支持新的JSON功能和可拓展存储引擎。</li><li>不支持从库读取复制功能。</li><li>部分新特性支持不够完善。</li></ul><p>MySQL 8.0优点:</p><ul><li>支持新存储引擎如InnoDB容器存储引擎。</li><li>全新的JSON数据类型支持,查询和索引功能强大。</li><li>支持从库读取功能等新复制特性。</li><li>性能有一定提升,支持区块存储引擎对分区表性能优化。</li></ul><p>MySQL 8.0缺点:</p><ul><li>新版本兼容性问题,与5.7下应用迁移成本高。</li><li>新功能测试环境建设难度大。</li><li>BUG率可能高于5.7稳定版本。</li></ul><h2 id="5-、Insert"><a href="#5-、Insert" class="headerlink" title="5 、Insert"></a>5 、Insert</h2><p>在数据库操作中，处理重复插入是一个常见需求，尤其是在尝试插入数据到具有唯一约束（如唯一键、主键）的表时。以下是几种处理重复插入的方法：</p><ol><li><p><strong>忽略重复记录</strong>： 使用 <code>INSERT IGNORE</code> 语句，当插入的记录违反唯一性约束时，MySQL会忽略这条插入语句，而不是抛出错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> IGNORE <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>ON DUPLICATE KEY UPDATE</code>**： 当插入的记录导致唯一键冲突时，此语句可以更新已有记录的某些字段而不是插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...)<br><span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span><br>column1 <span class="hljs-operator">=</span> <span class="hljs-keyword">VALUES</span>(column1), column2 <span class="hljs-operator">=</span> <span class="hljs-keyword">VALUES</span>(column2);<br></code></pre></td></tr></table></figure><p>这里，<code>VALUES(column_name)</code> 函数用于引用新插入的值。</p></li><li><p><strong>先查询后插入（SELECT + INSERT）</strong>：在插入之前，先查询记录是否存在。如果不存在，则插入。这种方法适用于不支持上述特性的数据库系统。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> cat(id, name, age)<br><span class="hljs-keyword">SELECT</span> s.SNO, s.SEX, s.CSZ<br><span class="hljs-keyword">FROM</span> test.student44 s<br><span class="hljs-keyword">WHERE</span> s.SNAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;陈强&#x27;</span><br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> cat c<br>    <span class="hljs-keyword">WHERE</span> c.id <span class="hljs-operator">=</span> s.SNO<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>MERGE</code> 语句（适用于SQL Server和Oracle等）</strong>：</p><p><code>MERGE</code> 是一种更高级的语句，可以同时完成查询、插入、更新和删除操作。对于避免重复插入，它可以用来根据条件决定是插入新记录还是更新现有记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">MERGE</span> <span class="hljs-keyword">INTO</span> Customers <span class="hljs-keyword">AS</span> Target<br><span class="hljs-keyword">USING</span> NewCustomerData <span class="hljs-keyword">AS</span> Source<br><span class="hljs-keyword">ON</span> Target.CustomerID <span class="hljs-operator">=</span> Source.CustomerID<br><span class="hljs-keyword">WHEN</span> MATCHED <span class="hljs-keyword">THEN</span><br>    <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SET</span> Target.Email <span class="hljs-operator">=</span> Source.Email<br><span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">NOT</span> MATCHED <span class="hljs-keyword">THEN</span><br>    <span class="hljs-keyword">INSERT</span> (CustomerID, Name, Email)<br>    <span class="hljs-keyword">VALUES</span> (Source.CustomerID, Source.Name, Source.Email);<br></code></pre></td></tr></table></figure></li></ol><h2 id="6、mysql问题"><a href="#6、mysql问题" class="headerlink" title="6、mysql问题"></a>6、mysql问题</h2><h3 id="1、插入中文记录问题"><a href="#1、插入中文记录问题" class="headerlink" title="1、插入中文记录问题"></a>1、插入中文记录问题</h3><blockquote><p>在表的字符集是utf8mb4情况下，插入中文数据提示报错</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span> 错误 [<span class="hljs-number">1366</span>] [HY000]: Incorrect string <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;\xE5\xB8\x82\xE4\xB8\xAD...&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;ACCOUNT&#x27;</span> <span class="hljs-keyword">at</span> <span class="hljs-type">row</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>排查：</strong></p><ul><li><p>检查客户端&#x2F;驱动程序的字符集设置</p></li><li><p>检查表和列的字符集设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> SAYTH_MONITOR_RISK_ALARM_DATA;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看表库的字符集编码<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> SAYTH_MONITOR_RISK_ALARM_DATA <span class="hljs-keyword">CONVERT</span> <span class="hljs-keyword">TO</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>更改表的字符集编码<br></code></pre></td></tr></table></figure></li></ul><h3 id="2、mysql数据库清除自增id并从1开始"><a href="#2、mysql数据库清除自增id并从1开始" class="headerlink" title="2、mysql数据库清除自增id并从1开始"></a>2、mysql数据库清除自增id并从1开始</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> tablename;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tablename AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;# 使用 <span class="hljs-keyword">DELETE</span> 语句结合 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 重置自增计数器<br><br>## 或者<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> tablename;# <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 语句可以快速清空表中的所有数据，并重置自增计数器<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用linux笔记</title>
    <link href="/2024/12/10/linux/linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/12/10/linux/linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Linux系统命令"><a href="#1、Linux系统命令" class="headerlink" title="1、Linux系统命令"></a>1、Linux系统命令</h1><h2 id="linux离线安装net-tools"><a href="#linux离线安装net-tools" class="headerlink" title="linux离线安装net-tools"></a>linux离线安装net-tools</h2><p>需镜像站下载工具离线包</p><p>rpm -Uvh net-tools-2.0-0.25.20131004git.el7.x86_64.rpm     #输入此命令进行安装</p><p>centos修改host文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">修改hosts文件<br><br>vim /etc/hosts<br>如：<br><br>127.0.0.1 http://www.baidu.com<br><br>修改完成后生效命令<br><br>/etc/init.d/network restart<br><br>nano /etc/ssh/sshd_config<br>ctl O<br>ctl X<br></code></pre></td></tr></table></figure><h2 id="查看机器是否虚拟化"><a href="#查看机器是否虚拟化" class="headerlink" title="查看机器是否虚拟化"></a>查看机器是否虚拟化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo |grep vmx<br><span class="hljs-comment"># 有输出为支持虚拟化</span><br></code></pre></td></tr></table></figure><h2 id="echo命令写入文件"><a href="#echo命令写入文件" class="headerlink" title="echo命令写入文件"></a>echo命令写入文件</h2><ul><li><p>echo内容 &gt;&gt; 文件 等价于末尾追加</p></li><li><p>echo内容 &gt; 文件 等价于清空原内容并重写</p></li><li><p>添加\n换行符可以实现多行写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;内容1\n内容2&quot; &gt;&gt; 文件<br></code></pre></td></tr></table></figure></li></ul><h2 id="sed命令写入"><a href="#sed命令写入" class="headerlink" title="sed命令写入"></a>sed命令写入</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle">向文件添加行:<br>sed -i <span class="hljs-string">&#x27;行号a 添加的内容&#x27;</span> 文件<br><br>例如在第一行添加:<br>sed -i <span class="hljs-string">&#x27;1a 添加的第一行&#x27;</span> <span class="hljs-keyword">file</span><br><br>替换文件内容:<br>sed -i <span class="hljs-string">&#x27;s/old/new/g&#x27;</span> <span class="hljs-keyword">file</span><br><br>删除文件某一行:<br>sed -i <span class="hljs-string">&#x27;行号d&#x27;</span> <span class="hljs-keyword">file</span><br><br>将命令输出写入文件:<br>command | sed <span class="hljs-string">&#x27;脚本&#x27;</span> &gt; <span class="hljs-keyword">file</span><br><br>将文件内容输出到其他文件:<br>sed <span class="hljs-string">&#x27;脚本&#x27;</span> <span class="hljs-keyword">file</span> &gt; new_file<br><br>直接写入文件不读入:<br>sed -i <span class="hljs-string">&#x27;写入指令&#x27;</span> <span class="hljs-keyword">file</span><br><br>例如在文件最后一行添加内容:<br><br>sed -i <span class="hljs-string">&#x27;$a 新内容&#x27;</span> <span class="hljs-keyword">file</span><br>例如<br>sed -i <span class="hljs-string">&#x27;s/192.168.0.102/192.168.0.195/g&#x27;</span> <span class="hljs-regexp">/home/</span><span class="hljs-keyword">super</span><span class="hljs-regexp">/superdraw-v23.11.0/</span>datahub<span class="hljs-regexp">/tools/</span>setup_superdraw.sh<br><br>创建新文件并写入内容<br>如果文件不存在就新建:<br><br>sed -i <span class="hljs-string">&#x27;1i\content&#x27;</span> new_file<br><br>替换/修改指定行内容<br>例如替换第<span class="hljs-number">5</span>行内容:<br><br>sed -i <span class="hljs-string">&#x27;5c\replaced line&#x27;</span> <span class="hljs-keyword">file</span># replaced line 为要替换的内容<br></code></pre></td></tr></table></figure><h2 id="修改ip"><a href="#修改ip" class="headerlink" title="修改ip"></a>修改ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim /etc/sysconfig/network-scripts/ifcfg-网卡名</span><br>我们需要修改BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span>也就是将dhcp改为static，<br><br>修改ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> 意思是将网卡设置 为开机启用，<br><br>同时在文字下方添加<br><br>IPADDR=192.168.0.230 <span class="hljs-comment">#</span><br>静态IP  <br><br>GATEWAY=192.168.0.1 <span class="hljs-comment">#默认网关  </span><br><br>NETMASK=255.255.255.0 <span class="hljs-comment">#子网掩码  </span><br><br>DNS1=192.168.0.1 <span class="hljs-comment">#DNS 配置  </span><br><br>DNS2=8.8.8.8        <span class="hljs-comment">#谷歌地址</span><br>重启网卡<br>systemctl restart NetworkManager.service<br></code></pre></td></tr></table></figure><h2 id="获取公网ip"><a href="#获取公网ip" class="headerlink" title="获取公网ip"></a>获取公网ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux 命令：curl cip.cc<br></code></pre></td></tr></table></figure><h2 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown [选项] 时间 [警告信息]<br>选项:<br>-c：取消已经执行的 shutdown 命令；<br>-h：关机；<br>-r：重启；<br></code></pre></td></tr></table></figure><h2 id="查看目录文件大小"><a href="#查看目录文件大小" class="headerlink" title="查看目录文件大小"></a>查看目录文件大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看当前文件目录各个文件夹大小<br><span class="hljs-built_in">du</span> -h --max-depth=1<br><span class="hljs-comment">#查看指定目录  du -h --max-depth=1 /path</span><br>2、查看当前目录下所有目录及子目录大小<br><span class="hljs-built_in">du</span> -h - .<br>“.”代表当前目录下。也可以换成一个明确的路径<br><br>-h表示用K、M、G的人性化形式显示<br>Filesystem：文件系统<br>Size： 分区大小<br>Used： 已使用容量<br>Avail： 还可以使用的容量<br>Use%： 已用百分比<br>Mounted on： 挂载点　<br>相关命令：<br><br><span class="hljs-built_in">df</span> -hl：查看磁盘剩余空间<br><span class="hljs-built_in">df</span> -h：查看每个根路径的分区大小<br><span class="hljs-built_in">du</span> -sh [目录名]：返回该目录的大小<br><span class="hljs-built_in">du</span> -sm [文件夹]：返回该文件夹总M数<br><span class="hljs-built_in">du</span> -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）<br><br>查看系统日志配置文件<br><span class="hljs-built_in">cat</span> /etc/rsyslog.conf<br></code></pre></td></tr></table></figure><h2 id="查找文件或者目录"><a href="#查找文件或者目录" class="headerlink" title="查找文件或者目录"></a>查找文件或者目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找目录下是否包含某个目录</span><br>find /path/to/directory -type d -name &quot;directory_name&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找目录下是否包含某个文件</span><br>find /path/to/directory -type f -name &quot;file_name&quot;<br><br></code></pre></td></tr></table></figure><h2 id="生成目录结构树"><a href="#生成目录结构树" class="headerlink" title="生成目录结构树"></a>生成目录结构树</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">安装tree工具<br>sudo apt install tree<br>简单使用<br>tree -L 2     <span class="hljs-comment"># 2代表层级</span><br><br>生成对应目录结构<br>.<br>├── mysql<br>│   └── docker-compose.yml<br>└── portainer<br>    ├── docker-compose.yml<br>    ├── portainer.tar<br>    └── start.sh<br><br>参数<br>-d 只显示文件夹<br>-h 显示文件大小<br>-D 显示完整的时间戳信息<br>-t 按修改时间排序<br>-s 按文件大小排序<br></code></pre></td></tr></table></figure><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">启动防火墙： systemctl start firewalld<br>查看防火墙状态： systemctl status firewalld<br>停止防火墙： systemctl stop firewalld<br>禁用防火墙： systemctl <span class="hljs-built_in">disable</span> firewalld<br>查看已经开放的端口 firewall-cmd --list-ports<br><br>开启指定端口（需 systemctl reload firewalld）<br>firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent<br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br><br>--zone=&lt;zone&gt; <span class="hljs-comment"># 指定 zone</span><br>--add-port=&lt;portid&gt;]/&lt;protocol&gt; <span class="hljs-comment"># 端口id / 协议</span><br>--permanent <span class="hljs-comment"># 永久开启，不添加则重启失效</span><br><br>关闭指定端口（需 systemctl reload firewalld）<br>firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent<br>firewall-cmd --zone=public –remove-port=80/tcp --permanent<br></code></pre></td></tr></table></figure><p>centos scp传输命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -P 46022 ./code.tar.gz root@192.168.5.16:/root/laozhao/SA_V3.1.1.0323-Release<span class="hljs-comment"># 上传</span><br>scp -P 46022 root@1192.168.5.16:/home/tools/docker-20.10.21.tgz ./<span class="hljs-comment"># 下载</span><br></code></pre></td></tr></table></figure><h2 id="tar使用命令"><a href="#tar使用命令" class="headerlink" title="tar使用命令"></a>tar使用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar x[z|J]f SMC-V1.0.0-2021xxxxxx-linux-x86_64-singleton.tar.[gz|xz]<br>不同格式压缩包使用不同命令参数解压，gz 格式使用 xzf 参数解压，xz 格式使用 xJf 参数解压<br></code></pre></td></tr></table></figure><h2 id="Centos7性能查看"><a href="#Centos7性能查看" class="headerlink" title="Centos7性能查看"></a>Centos7性能查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux CPU大小<br><span class="hljs-built_in">cat</span> /proc/cpuinfo |grep <span class="hljs-string">&quot;model name&quot;</span> &amp;&amp; <span class="hljs-built_in">cat</span> /proc/cpuinfo |grep <span class="hljs-string">&quot;physical id&quot;</span><br>或者 lscpu<br>内存大小<br><span class="hljs-built_in">cat</span> /proc/meminfo |grep MemTotal或者（free -m  total显示总内存 ）<br>硬盘大小<br>fdisk -l |grep Disk<br></code></pre></td></tr></table></figure><h2 id="centos7查看系统版本"><a href="#centos7查看系统版本" class="headerlink" title="centos7查看系统版本"></a>centos7查看系统版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/redhat-release<br></code></pre></td></tr></table></figure><h2 id="centos7查看进程占用端口"><a href="#centos7查看进程占用端口" class="headerlink" title="centos7查看进程占用端口"></a>centos7查看进程占用端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"> netstat -tunlp | grep 端口号<br> <span class="hljs-comment">#t：表示查看tcp</span><br> <span class="hljs-comment">#u：表示查看udp</span><br> <span class="hljs-comment">#p：表示占用端口的进程</span><br> <span class="hljs-comment">#n：表示端口以数字形式表示，没有n直接显示服务名</span><br> <span class="hljs-comment">#l：表示显示所监听的端口</span><br><br>查看所有tcp连接包括LISTEN状态<br><span class="hljs-comment"># netstat -an |grep tcp</span><br></code></pre></td></tr></table></figure><h2 id="yum安装卡住"><a href="#yum安装卡住" class="headerlink" title="yum安装卡住"></a>yum安装卡住</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br>yum makecache  <span class="hljs-comment">#卡住等待运行完</span><br>yum update<br></code></pre></td></tr></table></figure><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 安装tcpdump工具<br>rpm -ql tcpdump　　　　　　　　　　<span class="hljs-comment">#查看tcpdump是否安装</span><br>yum install tcpdump -y<br>2.  tcpdump抓包<br>根据协议和端口抓包<br>tcpdump -i eth0 udp port 694 -n　　　　　　　　　　　　　 <span class="hljs-comment">#-i指定网卡信息  udp协议</span><br>tcpdump -i eth0 tcp  port 8088 -n　　  　　　　　　　　　　 <span class="hljs-comment">#port 8088端口   tcp协议</span><br>tcpdump -i eth0 port 8088 -c 3 -t -w /tmp/tcpdump.pcap　　　<span class="hljs-comment">#-c指定抓包数量   -t不显示时间戳  -w指定存放路径　</span><br>根据主机抓包<br>tcpdump host 192.168.0.204 and 192.168.0.205　　　　　　<span class="hljs-comment">#两台主机之间通信抓包</span><br></code></pre></td></tr></table></figure><h2 id="linux-下查看网卡流量"><a href="#linux-下查看网卡流量" class="headerlink" title="linux 下查看网卡流量"></a>linux 下查看网卡流量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#yum install -y iftop </span><br>iftop -i 网卡名<br></code></pre></td></tr></table></figure><p>centos7配置清华源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">备份原文件<br>sudo sed -e <span class="hljs-string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \<br>         -e <span class="hljs-string">&#x27;s|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g&#x27;</span> \<br>         -i.bak \<br>         /etc/yum.repos.d/CentOS-*.repo<br>sudo yum clean all<br>sudo yum makecache<br>yum update<br></code></pre></td></tr></table></figure><h2 id="Debian12配置清华源"><a href="#Debian12配置清华源" class="headerlink" title="Debian12配置清华源"></a>Debian12配置清华源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.back<span class="hljs-comment"># 备份文件</span><br><br><span class="hljs-built_in">cat</span> &gt; /etc/apt/sources.list &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware </span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h2 id="清理所有相关进程"><a href="#清理所有相关进程" class="headerlink" title="清理所有相关进程"></a>清理所有相关进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep benthos* | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span> -9   <span class="hljs-comment"># benthos* 进程名</span><br></code></pre></td></tr></table></figure><h2 id="Debian12系统打包软件离线包"><a href="#Debian12系统打包软件离线包" class="headerlink" title="Debian12系统打包软件离线包"></a>Debian12系统打包软件离线包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打包</span><br>mkdir packages &amp;&amp; cd packages<br>apt download vim iftop sudo telnet -d   # 会在packages目录下生成deb离线包，拷贝到别的服务器<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>dpkg -i *.deb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现实情况 需要将某台安装好的服务器上的软件包全部打包</span><br>cd /var/cache/apt/archives<br>tar -czvf archives.tar.gz archives/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">上传安装</span><br>dpkg -i *.deb<br></code></pre></td></tr></table></figure><h2 id="ubuntu-资源监视器"><a href="#ubuntu-资源监视器" class="headerlink" title="ubuntu 资源监视器"></a>ubuntu 资源监视器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gnome-system-monitor<br></code></pre></td></tr></table></figure><h2 id="linux建立软连接"><a href="#linux建立软连接" class="headerlink" title="linux建立软连接"></a>linux建立软连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s 源文件 目标连接<br></code></pre></td></tr></table></figure><h1 id="2、centos下安装mysql数据库"><a href="#2、centos下安装mysql数据库" class="headerlink" title="2、centos下安装mysql数据库"></a>2、centos下安装mysql数据库</h1><h2 id="1、添加MariaDB的repo源："><a href="#1、添加MariaDB的repo源：" class="headerlink" title="1、添加MariaDB的repo源："></a>1、添加MariaDB的repo源：</h2><p>进入&#x2F;etc&#x2F;yum.repos.d下，添加CentOS-MariaDB.repo文件，其中添加内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># MariaDB 10.3 CentOS repository list - created 2018-05-26 07:55 UTC</span><br><span class="hljs-comment"># http://downloads.mariadb.org/mariadb/repositories/</span><br>[mariadb]<br>name = MariaDB<br>baseurl = http://yum.mariadb.org/10.3/centos7-amd64<br>gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB<br>gpgcheck=1<br><span class="hljs-comment"># 卸载mariadb仓库</span><br>rpm -qa | grep mariadb<br>rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64<br></code></pre></td></tr></table></figure><h2 id="2、清除Yum的缓存并重新建立"><a href="#2、清除Yum的缓存并重新建立" class="headerlink" title="2、清除Yum的缓存并重新建立"></a>2、清除Yum的缓存并重新建立</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure><h2 id="3、打印MariaDB源中的软件包："><a href="#3、打印MariaDB源中的软件包：" class="headerlink" title="3、打印MariaDB源中的软件包："></a>3、打印MariaDB源中的软件包：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list --disablerepo=\* --enablerepo=mariadb<br><br><span class="hljs-built_in">test</span>为测试工具，backup为备份工具<br></code></pre></td></tr></table></figure><h2 id="4、安装MariaDB数据库："><a href="#4、安装MariaDB数据库：" class="headerlink" title="4、安装MariaDB数据库："></a>4、安装MariaDB数据库：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install MariaDB-client MariaDB-server MariaDB-devel -y<br></code></pre></td></tr></table></figure><h2 id="5、启动数据库并设置为开机自启"><a href="#5、启动数据库并设置为开机自启" class="headerlink" title="5、启动数据库并设置为开机自启"></a>5、启动数据库并设置为开机自启</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、启动maria DB服务:<br><span class="hljs-comment"># systemctl start mariadb.service</span><br>2、添加至开机自启动：<br><span class="hljs-comment"># systemctl enable mariadb.service</span><br>3、查看数据库状态<br><span class="hljs-comment"># systemctl status mariadb</span><br></code></pre></td></tr></table></figure><h2 id="6、初始化数据库，并删除测试数据库及更改权限和设置密码"><a href="#6、初始化数据库，并删除测试数据库及更改权限和设置密码" class="headerlink" title="6、初始化数据库，并删除测试数据库及更改权限和设置密码"></a>6、初始化数据库，并删除测试数据库及更改权限和设置密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">初始化数据库配置<br><br>mysql_secure_installation<br><br>首先是设置密码，会提示先输入密码：<br><br>设置密码<br><br>Enter current password <span class="hljs-keyword">for</span> root (enter <span class="hljs-keyword">for</span> none):&lt;–直接回车<br><br>Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车<br>New password: &lt;– 设置root用户的密码<br>Re-enter new password: &lt;– 再输入一次你设置的密码<br>其他配置<br><br>Remove anonymous <span class="hljs-built_in">users</span>? [Y/n] &lt;– 是否删除匿名用户，Y回车<br><br>Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录, N回车,<br><br>Remove <span class="hljs-built_in">test</span> database and access to it? [Y/n] &lt;– 是否删除<span class="hljs-built_in">test</span>数据库，Y回车<br><br>Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，Y回车<br><br>初始化MariaDB完成，接下来测试本地登录。<br><br></code></pre></td></tr></table></figure><h3 id="7-检查是否启动成功"><a href="#7-检查是否启动成功" class="headerlink" title="7.检查是否启动成功"></a>7.检查是否启动成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysqld.service<br></code></pre></td></tr></table></figure><h3 id="8-通过密码登录，进行修改密码操作-可不操作"><a href="#8-通过密码登录，进行修改密码操作-可不操作" class="headerlink" title="8.通过密码登录，进行修改密码操作(可不操作)"></a>8.通过密码登录，进行修改密码操作(可不操作)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;super000&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="9-授权其他机器远程登录"><a href="#9-授权其他机器远程登录" class="headerlink" title="9.授权其他机器远程登录"></a>9.授权其他机器远程登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRANT ALL PRIVILEGES ON *.* TO <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;super000&#x27;</span> WITH GRANT OPTION;<br> <br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="10、连接数据库，并查询版本"><a href="#10、连接数据库，并查询版本" class="headerlink" title="10、连接数据库，并查询版本"></a>10、连接数据库，并查询版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p -A<br><br>其中-u制定用户，-p使用密码，-A为不预先读取数据库。<br><br>MariaDB [(none)]&gt; <span class="hljs-keyword">select</span> version();<br>+-----------------+<br>| version()       |<br>+-----------------+<br>| 10.3.32-MariaDB |<br>+-----------------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.000 sec)<br><br>show full processlist;<br>可查看当前用户，及登陆地址，选择的数据库，数据库引擎。<br><br></code></pre></td></tr></table></figure><h3 id="11-设置Mariadb的字符集为UTF-8，令其支持中文"><a href="#11-设置Mariadb的字符集为UTF-8，令其支持中文" class="headerlink" title="11.设置Mariadb的字符集为UTF-8，令其支持中文"></a>11.设置Mariadb的字符集为UTF-8，令其支持中文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看当前编码：<br>show variables like <span class="hljs-string">&#x27;character%&#x27;</span>; <br>show variables like <span class="hljs-string">&#x27;collation%&#x27;</span>;<br>2.退出数据库（<span class="hljs-built_in">exit</span>），<br>3.修改配置文件 vim /etc/my.cnf.d/server.cnf<br>在mysqld下添加 character-set-server = utf8<br>              collation-server = utf8_general_ci<br>              skip-character-set-client-handshake<br>              注意去掉前面的<span class="hljs-comment">#号</span><br>4.重启 数据库 systemctl restart mariadb<br>5.进入数据库 mysql -uroot -p<br>6.查看字符集编码<br></code></pre></td></tr></table></figure><h3 id="12-防火墙开放3306端口"><a href="#12-防火墙开放3306端口" class="headerlink" title="12.防火墙开放3306端口"></a>12.防火墙开放3306端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --state<br>firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>firewall-cmd --zone=public --add-port=80-90/tcp --permanent   <span class="hljs-comment">#作用域是public，批量开放tcp协议的80-90端口，一直有效</span><br>firewall-cmd --zone=public --add-port=80/tcp --add-port=90/tcp --permanent  <span class="hljs-comment">#作用域是public，批量开放tcp协议的80、90端口，一直有效</span><br>firewall-cmd --zone=public --add-service=http --permanent <span class="hljs-comment">#开放的服务是http协议，一直有效</span><br>firewall-cmd --reload<br><br>停止防火墙： systemctl stop firewalld<br>禁用防火墙： systemctl <span class="hljs-built_in">disable</span> firewalld<br></code></pre></td></tr></table></figure><h3 id="13-数据库的操作"><a href="#13-数据库的操作" class="headerlink" title="13.数据库的操作"></a>13.<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）查看mysql是否启动：service mariadb status<br><br>启动mysql：systemctl start mariadb<br><br>停止mysql：systemctl stop mariadb<br><br>重启mysql：systemctl restart mariadb<br><br>（2）查看数据库版本 mysql -V<br></code></pre></td></tr></table></figure><h2 id="7-JDK配置"><a href="#7-JDK配置" class="headerlink" title="7 JDK配置"></a>7 JDK配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看服务器上是否有Java安装包</span><br>rpm -qa | grep java<br><br><span class="hljs-comment"># 查看Linux系统是否有自带的jdk</span><br>java -version<br><br><span class="hljs-comment"># 上传安装包 解压，配置/etc/profile</span><br>tar -xzvf jdk-11.0.1_linux-x64_bin.tar.gz<br>[root@ecs-dc44 data]<span class="hljs-comment"># cd jdk-11.0.1</span><br>[root@ecs-dc44 jdk-11.0.1]<span class="hljs-comment"># pwd</span><br>/data/jdk-11.0.1<br><br><span class="hljs-comment"># 配置文件路径</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/data/jdk-11.0.1<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br><br><span class="hljs-comment"># 刷新</span><br><span class="hljs-built_in">source</span> /etc/profile<br><br></code></pre></td></tr></table></figure><h1 id="3、Linux下安装python3"><a href="#3、Linux下安装python3" class="headerlink" title="3、Linux下安装python3"></a>3、Linux下安装python3</h1><h3 id="1、依赖安装"><a href="#1、依赖安装" class="headerlink" title="1、依赖安装"></a>1、依赖安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc是一个用于linux系统下编程的编译器，由于python3需要编译安装，因此，需要首先安装gcc。先查看一下系统中，是否安装了gcc。<br><span class="hljs-comment"># gcc -version</span><br>未安装需要安装<br><span class="hljs-comment"># yum -y install gcc</span><br>编译安装python3过程中，根据系统本身的依赖，可能出现的不同的报错信息。提前按照好依赖包<br>yum -y install zlib* libffi-devel openssl-devel wget<br></code></pre></td></tr></table></figure><h3 id="2-python3-下载"><a href="#2-python3-下载" class="headerlink" title="2 python3 下载"></a>2 python3 下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cd ~ </span><br><span class="hljs-comment"># wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="hljs-comment"># wget https://www.python.org/ftp/python/3.9.9/Python-3.9.9.tgz</span><br></code></pre></td></tr></table></figure><h3 id="3-python3编译安装"><a href="#3-python3编译安装" class="headerlink" title="3 python3编译安装"></a>3 python3编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压下载的python3压缩包<br><span class="hljs-comment"># tar -zxvf Python-3.7.0.tgz</span><br>新建一个python3的安装目录(位置可自定义)<br><span class="hljs-comment"># mkdir /usr/lib/python3.7</span><br>进入Python-3.7.0目录下，「指定安装目录，设置启用ssl功能<br><span class="hljs-comment"># cd Python-3.7.0</span><br>./configure --prefix=/usr/lib/python3.7 --with-ssl<br>编译安装<br><span class="hljs-comment"># make &amp;&amp; make install</span><br></code></pre></td></tr></table></figure><h3 id="4创建软连接"><a href="#4创建软连接" class="headerlink" title="4创建软连接"></a>4创建软连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">上述步骤完成后，其实python3已经安装完毕，但是为了方便使用，一般会创建python3和pip3的软连接。创建后可直接在终端通过python命令进入python和pip3命令安装python包<br><br>创建python3和pip3软连接：<br><span class="hljs-comment"># ln -s /usr/lib/python3.7/bin/python3.7 /usr/bin/python3</span><br><span class="hljs-comment"># ln -s /usr/lib/python3.7/bin/pip3.7 /usr/bin/pip3</span><br><span class="hljs-comment"># ln -s /usr/bin/pip3 /usr/bin/pip</span><br><br>系统默认的python软连接指向的是python2，如果我们需要更方便使用，可以删除原有的python软连接，并建立新的python软连接指向python3<br><br><span class="hljs-comment"># rm -f /usr/bin/python</span><br><span class="hljs-comment"># ln -s /usr/bin/python3 /usr/bin/python</span><br><br>查看最新的有python的软连接<br><span class="hljs-comment"># python --version</span><br></code></pre></td></tr></table></figure><h3 id="5修改yum配置"><a href="#5修改yum配置" class="headerlink" title="5修改yum配置"></a>5修改yum配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">修改yum配置文件，下面两个文件都要修改<br><span class="hljs-comment"># vi /usr/bin/yum</span><br><span class="hljs-comment"># vi /usr/libexec/urlgrabber-ext-down</span><br>按i进入编辑模式，在第一行<span class="hljs-comment">#!/usr/bin/python把修改为#!/usr/bin/python2.7</span><br></code></pre></td></tr></table></figure><h3 id="6联网快速安装方法"><a href="#6联网快速安装方法" class="headerlink" title="6联网快速安装方法"></a>6联网快速安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">3、安装Python3：（此方法默认为3.6，无法安装3.7）<br>yum install python3 -y<br>yum -y install epel-release<br>yum -y install python-pip<br><br>备份旧的Python的默认执行程序　　<br><span class="hljs-built_in">mv</span> /usr/bin/python /usr/bin/python.bak.$(<span class="hljs-built_in">date</span> +%F).$(<span class="hljs-built_in">date</span> +%R)<br>使用Python3软链接替代Python默认执行程序　　<br><span class="hljs-built_in">ln</span> -s /usr/bin/python3 /usr/bin/python<br><br>修改以下文件的开头第一行内容，把python改成python2.7(不修改yum命令无法使用)<br><br>/usr/bin/yum<br>/usr/libexec/urlgrabber-ext-down<br>/usr/bin/yum-config-manager<br>查看Python替换正常，且yum可用　　<br>yum --version<br>python --version<br><br>卸载python3.6.x<br><br>rpm -qa|grep python3|xargs rpm -ev --allmatches --nodeps<br>whereis python3 |xargs <span class="hljs-built_in">rm</span> -frv<br></code></pre></td></tr></table></figure><h1 id="4、linux-自带python-搭建http服务"><a href="#4、linux-自带python-搭建http服务" class="headerlink" title="4、linux 自带python 搭建http服务"></a>4、linux 自带python 搭建http服务</h1><h2 id="1、版本说明（内置库）"><a href="#1、版本说明（内置库）" class="headerlink" title="1、版本说明（内置库）"></a>1、版本说明（内置库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">如果python版本为2.x，输入命令：<br><br>python -m SimpleHTTPServer 8000<br><br>（8000为端口号，如果不指定则默认8000端口）<br><br><span class="hljs-comment">######################################</span><br><br>如果python版本为3.x，输入命令：<br><br>python -m http.server 8000<br><br>（8000为端口号，如果不指定则默认8000端口）<br><br>默认位当前目录<br></code></pre></td></tr></table></figure><h2 id="2、配置后台关闭bash窗口运行"><a href="#2、配置后台关闭bash窗口运行" class="headerlink" title="2、配置后台关闭bash窗口运行"></a>2、配置后台关闭bash窗口运行</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nohup python -m SimpleHTTPServer 8000 &amp;    #python2.0<br><br>nohup python -m http.server 8000 &amp;# python3.0<br><br>在命令的开头加一个nohup，忽略所有的挂断信号，如果当前bash关闭，则当前进程会挂载到init进程下，成为其子进程，这样即使退出当前用户，其8000端口也可以使用<br>在上述命令的最后加一个 &amp; ，则该命令产生的进程在后台运行，不会影响当前终端的使用（我们在只有一个bash的环境下）<br><br>配置sh脚本<br>nohup python -m SimpleHTTPServer 8080 &gt;/home/httplog/http.log 2&gt;&amp;1 &amp;  # /home/httplog/http.log为输出文件日志路径<br></code></pre></td></tr></table></figure><h1 id="5、xshell代理服务器连接"><a href="#5、xshell代理服务器连接" class="headerlink" title="5、xshell代理服务器连接"></a>5、xshell代理服务器连接</h1><h2 id="5、1-window设置"><a href="#5、1-window设置" class="headerlink" title="5、1 window设置"></a>5、1 window设置</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">1、本地下載openSSH，根据代理服务器的环境下载<br>下载地址：https://github.com/PowerShell/Win32-OpenSSH/releases<br>2、下载完毕解压安装<br>以管理员身份cmd进入解压目录下，执行<br>powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1<br>3、防火墙高级设置里面添加22端口的tcp入站规则<br>4、系统服务里面启动openSSH相关服务<br></code></pre></td></tr></table></figure><h2 id="5-2-xshell隧道代理设置"><a href="#5-2-xshell隧道代理设置" class="headerlink" title="5.2  xshell隧道代理设置"></a>5.2  xshell隧道代理设置</h2><h3 id="5-2-1-建立跳板机连接"><a href="#5-2-1-建立跳板机连接" class="headerlink" title="5.2.1 建立跳板机连接"></a>5.2.1 建立跳板机连接</h3><p>首先建立跳板机的连接，并配置隧道。打开<a href="https://so.csdn.net/so/search?q=XShell&spm=1001.2101.3001.7020">XShell</a>点击文件菜单再点击新建弹出新建会话属性窗口，名称就取为跳板机，端口是22，主机填写前面假设的ip地址。如下图所示：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071154535.png" alt="image-20220630163450501"></p><h3 id="5-2-2-填写跳板机用户名密码"><a href="#5-2-2-填写跳板机用户名密码" class="headerlink" title="5.2.2 填写跳板机用户名密码"></a>5.2.2 填写跳板机用户名密码</h3><p>点击用户身份验证，填写登录跳板机的<a href="https://so.csdn.net/so/search?q=SSH&spm=1001.2101.3001.7020">SSH</a>用户名和密码如下图所示：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071155281.png" alt="image-20220630163646503"></p><h3 id="5-2-3-防止跳板机连接过久自动断开"><a href="#5-2-3-防止跳板机连接过久自动断开" class="headerlink" title="5.2.3 防止跳板机连接过久自动断开"></a>5.2.3 防止跳板机连接过久自动断开</h3><p>为防止跳板机连接过久自动断开，所以这里添加登录脚本直接发送top命令。点击登录脚本，勾选上执行以下等待并发送规则，点击添加弹出等待发送规则添加窗口，在发送框填写top。具体配置看图：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071155510.png" alt="image-20220630163747497"></p><h3 id="5-2-4-配置内网隧道"><a href="#5-2-4-配置内网隧道" class="headerlink" title="5.2.4 配置内网隧道"></a>5.2.4 <strong>配置内网隧道</strong></h3><p>接下来继续配置连接内网服务器的隧道，点击隧道再点击添加按钮进入隧道添加页面，源主机为本机localhost，侦听端口可以在有效范围内随便填写，这里为了区分连接内网哪台服务器，所以用内网服务器ip最后一位加22即522作为侦听端口。目标主机就是我们要通过跳板机访问的内网主机，端口是22。同样的操作再配置一个连接192.168.100.6的隧道，端口不能与522冲突，按刚才的规则可以用622端口。具体配置如下图：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071157969.png" alt="image-20220630163839280"></p><h3 id="5-2-5-登录跳板机并连接内网服务器"><a href="#5-2-5-登录跳板机并连接内网服务器" class="headerlink" title="5.2.5 登录跳板机并连接内网服务器"></a>5.2.5 <strong>登录跳板机并连接内网服务器</strong></h3><p>到此跳板机的配置已经完成了，下面来建立通过跳板机登录内网服务器的连接会话，首先还是进入新建会话属性窗口，注意一下这次的配置，主机为localhost，侦听端口为刚才的522，即这个配置连接之后是访问内网的192.168.100.5服务器</p><h1 id="6、允许以root用户登录操作系统"><a href="#6、允许以root用户登录操作系统" class="headerlink" title="6、允许以root用户登录操作系统"></a>6、<strong>允许以root用户登录操作系统</strong></h1><h3 id="6-1-修改-etc-gdm3-daemon-conf文件"><a href="#6-1-修改-etc-gdm3-daemon-conf文件" class="headerlink" title="6.1 修改&#x2F;etc&#x2F;gdm3&#x2F;daemon.conf文件"></a>6.1 修改&#x2F;etc&#x2F;gdm3&#x2F;daemon.conf文件</h3><p>新增下面一行AllowRoot &#x3D; true</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">[security]<br> <br>AllowRoot = true<br></code></pre></td></tr></table></figure><h4 id="6-2修改-etc-pam-d-gdm-password"><a href="#6-2修改-etc-pam-d-gdm-password" class="headerlink" title="6.2修改&#x2F;etc&#x2F;pam.d&#x2F;gdm-password"></a>6.2修改&#x2F;etc&#x2F;pam.d&#x2F;gdm-password</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">注释掉下面内容<br><br><span class="hljs-params">#</span>auth required pam<span class="hljs-built_in">_</span>succeed<span class="hljs-built_in">_</span>if.so user != root quiet<span class="hljs-built_in">_</span>success<br></code></pre></td></tr></table></figure><h3 id="6-3修改-etc-ssh-sshd-config"><a href="#6-3修改-etc-ssh-sshd-config" class="headerlink" title="6.3修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config"></a>6.3修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config</h3><p>将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin prohibit-password<br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h1 id="7、linux格式化硬盘-挂载"><a href="#7、linux格式化硬盘-挂载" class="headerlink" title="7、linux格式化硬盘 挂载"></a>7、linux格式化硬盘 挂载</h1><h2 id="1、查看硬盘信息"><a href="#1、查看硬盘信息" class="headerlink" title="1、查看硬盘信息"></a>1、查看硬盘信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># fdisk -l</span><br><br>Disk /dev/sda: 146.1 GB, 146163105792 bytes<br><br>255 heads, 63 sectors/track, 17769 cylinders<br><br>Units = cylinders of 16065 * 512 = 8225280 bytes<br><br>    Device Boot       Start          End       Blocks    Id   System<br><br>/dev/sda1    *            1           13       104391    83   Linux<br><br>/dev/sda2               14         5112     40957717+   83   Linux<br><br>/dev/sda3             5113         5243      1052257+   82   Linux swap /<br><br>Solaris<br><br>/dev/sda4             5244        17769    100615095     5   Extended<br><br>/dev/sda5             5244        17769    100615063+   83   Linux<br><br>Disk /dev/sdb: 291.3 GB, 291331192320 bytes<br><br>255 heads, 63 sectors/track, 17769 cylinders<br><br>Units = cylinders of 16065 * 512 = 8225280 bytes<br><br>Disk /dev/sdb1: 291.3 GB, 291331192320 bytes<br></code></pre></td></tr></table></figure><h2 id="2、创建新硬盘分区"><a href="#2、创建新硬盘分区" class="headerlink" title="2、创建新硬盘分区"></a>2、创建新硬盘分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk可以用m命令来看fdisk命令的内部命令；<br><br>a：命令指定启动分区；<br><br>d：命令删除一个存在的分区；<br><br>l：命令显示分区ID号的列表；<br><br>m：查看fdisk命令帮助；<br><br>n：命令创建一个新分区；<br><br>p：命令显示分区列表；<br><br>t：命令修改分区的类型ID号；<br><br>w：命令是将对分区表的修改存盘让它发生作用。<br><br> <span class="hljs-comment">#fdisk /dev/sdb</span><br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):n<br><br>Command action<br><br>　　   e    extended    //输入e为创建扩展分区<br><br>　　   p    primary partition (1-4)<br><br>Partion number(1-4)：1<br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w<br><br>输入n回车，再输入p回车，再输出1回车，一路回车，最后输入w回车保存。<br><br>查看一下：<br><br>fdisk -l<br><br>可以看到/dev/sdb1分区<br></code></pre></td></tr></table></figure><h2 id="3、格式化分区"><a href="#3、格式化分区" class="headerlink" title="3、格式化分区"></a>3、格式化分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext3 /dev/sdb1<br></code></pre></td></tr></table></figure><h2 id="4、创建-data1目录："><a href="#4、创建-data1目录：" class="headerlink" title="4、创建&#x2F;data1目录："></a>4、创建&#x2F;data1目录：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data1<br></code></pre></td></tr></table></figure><h2 id="5、挂载分区"><a href="#5、挂载分区" class="headerlink" title="5、挂载分区"></a>5、挂载分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/sdb1 /data1<br></code></pre></td></tr></table></figure><h2 id="6、配置开机自动挂载"><a href="#6、配置开机自动挂载" class="headerlink" title="6、配置开机自动挂载"></a>6、配置开机自动挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为mount挂载在重启服务器后会失效，所以需要将分区信息写到/etc/fstab文件中让它永久挂载：<br><br>vi /etc/fstab<br><br>加入：<br><br>LABEL=/data1             /data1                   ext3     defaults         1 2<br><br>查看<span class="hljs-built_in">cat</span> /etc/fstab<br><br>LABEL=/                  /                        ext3     defaults         1 1<br><br>LABEL=/data              /data                    ext3     defaults         1 2<br><br>LABEL=/data1             /data1                   ext3     defaults         1 2<br><br>LABEL=/boot              /boot                    ext3     defaults         1 2<br><br>tmpfs                    /dev/shm                 tmpfs    defaults         0 0<br><br>devpts                   /dev/pts                 devpts   gid=5,mode=620   0 0<br><br>sysfs                    /sys                     sysfs    defaults         0 0<br><br>proc                     /proc                    proc     defaults         0 0<br><br>LABEL=SWAP-hda3          swap                     swap     defaults         0 0<br><br>重启系统<br></code></pre></td></tr></table></figure><h1 id="8-openssl生成证书文件"><a href="#8-openssl生成证书文件" class="headerlink" title="8 openssl生成证书文件"></a>8 openssl生成证书文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">签署证书时不能直接绑定 IP 地址，因为证书是用于确认域名的身份，而不是特定的 IP 地址。<br><br>但是，您可以通过使用证书中的 SAN（Subject Alternative Name）扩展来绑定多个域名和 IP 地址。例如，您可以在生成 CSR 文件时使用以下命令：<br><br>openssl req -newkey rsa:2048 -nodes -keyout mykey.key -out mycsr.csr -subj <span class="hljs-string">&quot;/C=US/ST=California/L=San Francisco/O=Example Inc./CN=example.com/subjectAltName=DNS:example.com,IP:0.0.0.0&quot;</span><br><br>以上命令会生成一个包含以下内容的 CSR 文件：<br><br>    主域名：example.com<br>    IP 地址：0.0.0.0<br><br>颁发机构将使用该 CSR 签署证书，并在证书中包括主域名和 IP 地址的信息。<br><br>使用 OpenSSL 生成 p12 格式证书并配置的详细示例：<br><br>    首先，生成一对私钥和证书请求文件：<br><br>openssl req -newkey rsa:2048 -nodes -keyout mykey.key -out mycsr.csr<br><br>    您需要输入一些信息，如国家、省份、城市、组织名称等，证书请求文件 mycsr.csr 将使用这些信息生成。<br><br>    使用私钥和证书请求文件生成证书：<br><br>openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> mycsr.csr -signkey mykey.key -out mycert.crt<br><br>    最后，使用证书和私钥生成 p12 格式证书：<br><br>openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> mycert.crt -inkey mykey.key -out mycert.p12<br><br>    您需要输入一个密码，该密码将用于保护 p12 证书的安全。请记住您输入的密码，因为您将需要在使用证书时输入该密码。<br>    <br> <br></code></pre></td></tr></table></figure><h1 id="9、conda使用"><a href="#9、conda使用" class="headerlink" title="9、conda使用"></a>9、conda使用</h1><h2 id="conda是一款软件管理工具"><a href="#conda是一款软件管理工具" class="headerlink" title="conda是一款软件管理工具"></a>conda是一款软件管理工具</h2><ul><li>miniconda 只包含了conda、python、和一些必备的软件工具</li><li>anaconda 包含了数据科学和机器学习要用到的很多软件</li></ul><p>常见开发使用miniconda即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh --no-check-certificate<br><span class="hljs-comment"># 下载minicoda -c参数提供端点续传</span><br>bash Miniconda3-latest-Linux-x86_64.sh <span class="hljs-comment">#执行脚本安装</span><br>conda init<span class="hljs-comment">#conda 初始化</span><br>conda create -n your_env_name python=3.9<span class="hljs-comment">#conda 创建虚拟环境</span><br>conda activate your_env_name<span class="hljs-comment">#conda激活虚拟环境</span><br>conda config --add envs_dirs newdir <span class="hljs-comment">#增加环境路径newdir</span><br>conda <span class="hljs-built_in">env</span> list<span class="hljs-comment">#查看有哪些虚拟路径以及它们的存储路径，* 号表示当前所处的环境</span><br>conda <span class="hljs-built_in">env</span> remove --name PySanic<span class="hljs-comment">#删除虚拟环境</span><br>deactivate<span class="hljs-comment"># 退出虚拟环境</span><br>conda update conda<span class="hljs-comment"># conda升级</span><br>conda config --show<span class="hljs-comment"># 显示配置信息</span><br><span class="hljs-comment">## 设置清华镜像源</span><br>sudo vim ~/.condarc<br><br>将以下内容覆盖’.codnarc’文件里面所有内容<br>channels:<br>  - defaults<br>show_channel_urls: <span class="hljs-literal">true</span><br>default_channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2<br>custom_channels:<br>  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/<br>  <br> <span class="hljs-comment"># 配置完清除索引缓存</span><br> conda clean -i<br><br><span class="hljs-comment"># 卸载Anaconda</span><br><span class="hljs-built_in">rm</span> -rf ~/anaconda3<br></code></pre></td></tr></table></figure><p><strong>关闭初始化conda</strong></p><p>查看配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">conda <span class="hljs-built_in">config</span> <span class="hljs-comment">--show | grep auto_activate_base</span><br></code></pre></td></tr></table></figure><p>关闭初始化</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda<span class="hljs-built_in"> config </span>--<span class="hljs-built_in">set</span> auto_activate_base <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="10-git使用"><a href="#10-git使用" class="headerlink" title="10 git使用"></a>10 git使用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch [branch name]#创建本地分支<br>git checkout [branch name]#切换到新分支<br>git checkout -b [branch name]#创建分支同时也切换分支<br>git stash # 暂存文件<br>git stash list # 查看stash了哪些存储<br>git stash apply stash@&#123;$num&#125;# 应用某个储存<br>git stash pop# 恢复缓存之前<br>git stash drop stash@&#123;$num&#125;# 丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储<br>git stash clear# 删除所有缓存的stash<br>git branch -d [branch-name]# 删除分支<br><br>项目目录创建 .gitignore 文件 忽略增加到git的目录或者文件<br>git rm --cached -r ./test/# 删除增加过的文件或者目录缓存<br><br>git revert &lt;commit-hash&gt;# 撤销提交<br><br><br>git reset [--mixed/soft/hard] HEAD^   撤销上次的提交<br>//如果想撤销N次commit,使用HEAD~N<br>1、--mixed   不删除工作空间改动代码，撤销commit，并且撤销git add .操作。这个为默认参数,git reset --mixed HEAD^ 和git reset HEAD^ 效果相同<br>2、--soft    不删除工作空间改动代码，撤销commit，不撤销git add .<br>3、--hard    删除工作空间改动代码，撤销commit，撤销git add . 注意完成这个操作后，就恢复到了上一次的commit状态<br><br>Tips:如果只是想更改提交的注释信息,使用git commit --amend 即可进入vim编辑器修改,不用撤销commit操作<br><br>git log    获取历史提交的版本号     Tips:也可以在项目的.git/logs/refs/heads/master文件中查看操作日志<br>git reset --hard e7a98b4eabc91afebd7e3f3d7c474276146c6c2f(版本号)    恢复到指定的历史版本<br><br>//如果需要同步远程<br>git push origin source -f    强制 push 更新远程分支<br><br>git revert 是一种更安全、更透明的撤销方式，因为它保留了历史的完整性，适用于公开的、已推送的提交。<br>git reset 提供了更多的灵活性和控制，但同时也带来了更大的风险，尤其是在多人协作的环境中。<br>        <br></code></pre></td></tr></table></figure><h1 id="11-安装docker"><a href="#11-安装docker" class="headerlink" title="11 安装docker"></a>11 安装docker</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安裝docker</span><br>yum install -y yum-utils device-mapper-persistent-data net-tools telnet<br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>yum -y install docker-ce.x86_64 <br>systemctl start docker <br>systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安裝docker-compose(上传docker-compose,移动到/usr/local/bin目录下，并授权)</span><br>mv docker-compose /usr/local/bin/<br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装docker-compose</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载最新docker-compose 保存到/usr/local/bin/docker-compose</span><br>sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">授权</span><br>sudo chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>sudo rm /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否有docker用户组</span><br>cat /etc/group ｜ grep docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有的话添加</span><br>sudo groupadd docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前用户到docker组</span><br>sudo usermod -aG docker $USER<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新用户组</span><br>newgrp docker                      <br></code></pre></td></tr></table></figure><h3 id="docker配置镜像加速方案"><a href="#docker配置镜像加速方案" class="headerlink" title="&#x3D;&#x3D;docker配置镜像加速方案&#x3D;&#x3D;"></a>&#x3D;&#x3D;docker配置镜像加速方案&#x3D;&#x3D;</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    &quot;registry-mirrors&quot;:[</span><br><span class="hljs-string">        &quot;https://hub.uuuadc.top&quot;,</span><br><span class="hljs-string">        &quot;https://docker.anyhub.us.kg&quot;,</span><br><span class="hljs-string">        &quot;https://dockerhub.jobcher.com&quot;,</span><br><span class="hljs-string">        &quot;https://dockerhub.icu&quot;,</span><br><span class="hljs-string">        &quot;https://docker.ckyl.me&quot;,</span><br><span class="hljs-string">        &quot;https://docker.awsl9527.cn&quot;</span><br><span class="hljs-string">    ],</span><br><span class="hljs-string">    &quot;data-root&quot;:&quot;/home/dockerdate&quot;,</span><br><span class="hljs-string">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="hljs-string">    &quot;log-opts&quot;:&#123;</span><br><span class="hljs-string">        &quot;max-size&quot;:&quot;512m&quot;,&quot;max-file&quot;:&quot;3&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&#x27;</span> | sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart docker<br></code></pre></td></tr></table></figure><h1 id="12、Debian安装Wireshark"><a href="#12、Debian安装Wireshark" class="headerlink" title="12、Debian安装Wireshark"></a>12、Debian安装Wireshark</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.打开终端并以root用户身份登录。<br><br>2. 运行以下命令以添加Wireshark的软件源： <br>echo &quot;deb http://deb.debian.org/debian buster main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb-src http://deb.debian.org/debian buster main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb http://security.debian.org/debian-security buster/updates main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb-src http://security.debian.org/debian-security buster/updates main&quot; &gt;&gt; /etc/apt/sources.list <br><br>3. 更新软件包列表： apt-get update <br>4. 现在，您应该可以安装Wireshark了：  apt-get install wireshark tshark -y<br></code></pre></td></tr></table></figure><h1 id="13-Kafka命令"><a href="#13-Kafka命令" class="headerlink" title="13 Kafka命令"></a>13 Kafka命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、使用以下命令查看当前 Kafka 主题：<br>kafka-topics.sh --list --bootstrap-server localhost:9092<br>2、刪除主題<br>kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic your_topic_name<br>3、创建主题<br>kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic my-topic<br><br>    --create：创建一个新主题。<br>    --bootstrap-server：指定要用于连接到 Kafka 集群的引导服务器地址。这应该是 Kafka 消息代理的主机名和端口号，例如 localhost:9092。<br>    --replication-factor：指定要为每个分区保留多少个副本。在生产环境中，通常将副本因子设置为 2 或更高，以确保数据冗余性和高可用性。单一副本的主题只有在测试或开发环境中才有意义。<br>    --partitions：指定要为主题创建的分区数。如果没有特殊需求，请在生产中创建多个分区以支持更好的伸缩性和吞吐量。<br>    --topic：指定要创建的主题名称。<br></code></pre></td></tr></table></figure><h1 id="14-k8s相关命令"><a href="#14-k8s相关命令" class="headerlink" title="14 k8s相关命令"></a>14 k8s相关命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、 查看节点<br>kubectl get nodes<br>2、查看Pod<br> kubectl get pods<br>3、删除Pods<br>kubectl delete pod &lt;pod-name&gt;<br>4、k8s查看所有命名空间<br>kubectl get namespaces<br>5、切换进入命名空间<br>kubectl config set-context --current --namespace=&lt;namespace&gt;<br>6、查看services<br>kubectl get services<br>7、刪除命名空间<br>kubectl delete namespace &lt;namespace-name&gt;<br>8、创建命令空间<br>kubectl create namespace &lt;namespace-name&gt;<br></code></pre></td></tr></table></figure><h1 id="15-ES相关命令"><a href="#15-ES相关命令" class="headerlink" title="15 ES相关命令"></a>15 ES相关命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs apl">1、创建索引：（指定索引最大字段数）<br>PUT /benthos<br>&#123;<br>  &quot;settings&quot;: &#123;<br>    &quot;index.mapping.total_fields.limit&quot;: 10000<br>  &#125;<br>  &#125;<br><br>2、查看索引列表：<br>curl -X GET &quot;localhost:9200/_cat/indices?v&quot;<br><br>3、向索引中添加文档：<br>curl -X POST &quot;localhost:9200/your_index/_doc&quot; -H &#x27;Content-Type: application/json&#x27; -d &#x27;&#123;<br>  &quot;field1&quot;: &quot;value1&quot;,<br>  &quot;field2&quot;: &quot;value2&quot;<br>&#125;&#x27;<br><br>4、获取单个文档：<br>curl -X GET &quot;localhost:9200/your_index/_doc/your_document_id?pretty&quot;<br><br>5、更新文档：<br>curl -X POST &quot;localhost:9200/your_index/_doc/your_document_id/_update&quot; -H &#x27;Content-Type: application/json&#x27; -d &#x27;&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;new_field&quot;: &quot;new_value&quot;<br>  &#125;<br>&#125;&#x27;<br><br>6、删除索引：<br><br>7、查看索引内容：<br>http://192.168.0.71:9200/benthos/_search?q=*<br><br>8、修改索引字段数<br>PUT /索引名/_settings<br>&#123;<br>  &quot;index.mapping.total_fields.limit&quot;: 新的最大字段数<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="16-Tshark分包命令"><a href="#16-Tshark分包命令" class="headerlink" title="16 Tshark分包命令"></a>16 Tshark分包命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">安装<br>sudo apt install -y tshark<br><br>1 使用tshark分割包<br>tshark -r input.pcap -w output -C 1 -b filesize:1024<br><span class="hljs-comment"># tshark 同步发送</span><br>tshark -i eth0 -w capture.pcap &amp;&amp; $ rsync -avz capture.pcap user@remote.server:/path/to/remote/dir<br><span class="hljs-comment"># tshark 生成ek josn清除 索引行</span><br>tshark -r test2.pcap -T ek -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt; testek.json<br><span class="hljs-comment"># tshark过滤字段</span><br> 选项用于过滤要显示或处理的数据包。您可以使用 Wireshark Display Filters 语法来定义过滤条件，以限制结果集中的数据包。例如，您可以使用 -Y <span class="hljs-string">&quot;ip.src == 192.168.0.1&quot;</span> 来仅显示源IP地址为 192.168.0.1 的数据包。<br><br>-e 选项用于指定在输出中显示的字段。您可以使用 tshark 的字段名称或编码来提取感兴趣的特定字段。例如，您可以使用 -e frame.number -e ip.src -e tcp.dstport 来获取每个数据包的帧编号、源IP地址和目标TCP端口号。<br>tshark -r <span class="hljs-string">&quot;<span class="hljs-variable">$pcap_file</span>&quot;</span> -Y <span class="hljs-string">&quot;<span class="hljs-variable">$filter</span>&quot;</span> -T ek -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt;  <span class="hljs-string">&quot;<span class="hljs-variable">$output_file</span>&quot;</span> <br><br>tshark -r test2.pcap -T ek -e -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt; testek.json<br><br><span class="hljs-built_in">nohup</span> bash tshark_benthos.sh &gt; output.log 2&gt;&amp;1 &amp;<br><br><br></code></pre></td></tr></table></figure><h1 id="17-linux环境变量等级"><a href="#17-linux环境变量等级" class="headerlink" title="17 linux环境变量等级"></a>17 linux环境变量等级</h1><h2 id="在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级"><a href="#在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级" class="headerlink" title="在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级"></a>在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级</h2><ol><li>全局系统级别（Global System Level）：<br>这是最高级别的环境变量，适用于整个系统的所有用户和进程。这些环境变量通常定义在系统范围的配置文件中，例如<code>/etc/profile</code>、<code>/etc/environment</code>和<code>/etc/profile.d/</code>目录下的文件。修改这些文件需要root权限。</li><li>用户级别（User Level）：<br>用户级别的环境变量仅适用于特定用户。每个用户都有自己的环境变量配置，通常保存在用户的主目录中的文件中。最常见的是<code>~/.bashrc</code>和<code>~/.bash_profile</code>文件，它们在用户登录时会被加载。修改这些文件只会影响到相应用户。</li><li>会话级别（Session Level）：<br>会话级别的环境变量仅适用于当前会话。当用户登录后，会话级别的环境变量会被创建，并在用户退出登录后被销毁。这些环境变量可以通过在终端中直接设置变量来定义，例如使用<code>export</code>命令。</li><li>会话级别（Session Level）：<br>会话级别的环境变量仅适用于当前会话。当用户登录后，会话级别的环境变量会被创建，并在用户退出登录后被销毁。这些环境变量可以通过在终端中直接设置变量来定义，例如使用<code>export</code>命令。</li></ol><h1 id="18-Ubuntu-安装第三方包（deb）"><a href="#18-Ubuntu-安装第三方包（deb）" class="headerlink" title="18 Ubuntu 安装第三方包（deb）"></a>18 Ubuntu 安装第三方包（deb）</h1><p><strong>安装实例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">下载好对应的deb包<br>sudo dpkg -<span class="hljs-selector-tag">i</span> com<span class="hljs-selector-class">.alibabainc</span><span class="hljs-selector-class">.dingtalk_7</span>.<span class="hljs-number">1.0</span>.<span class="hljs-number">31120</span>_amd64<span class="hljs-selector-class">.deb</span> <br></code></pre></td></tr></table></figure><p><strong>查看安装的包</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">sudo dpkg -l <span class="hljs-string">| grep dingtalk</span><br></code></pre></td></tr></table></figure><p><strong>卸载已安装的包</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo dpkg-r dingtalk</span><br></code></pre></td></tr></table></figure><p><strong>deb包默认暂存路径</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/<br></code></pre></td></tr></table></figure><h1 id="19-谷歌浏览器技巧"><a href="#19-谷歌浏览器技巧" class="headerlink" title="19 谷歌浏览器技巧"></a>19 谷歌浏览器技巧</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 截图<br>1. 按F12<br>2. Ctrl + Shift + P<br>3. 输入命令 `Capture full size screenshot`<br><br># 隐藏广告<br>1. 按F12<br>2. Elements<br>3. Styles增加 display：none<br></code></pre></td></tr></table></figure><h1 id="20-转换文件名编码"><a href="#20-转换文件名编码" class="headerlink" title="20 转换文件名编码"></a>20 转换文件名编码</h1><p>Windows下压缩的zip文件，在 Ubuntu下解开时，中文文件名会显示乱码，可以用convmv解决。</p><p>安装convmv：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install convmv<br></code></pre></td></tr></table></figure><p>转换文件或目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">convmv -f gbk -t utf8 -r --notest *<br><br>--notest: 这个选项告诉 convmv 实际执行转换操作，而不是仅仅测试哪些文件名需要转换。如果不加此选项，convmv 会显示哪些文件名会被修改，但不会真正修改它们<br><br>*: 是一个通配符，代表当前目录下的所有文件。结合 -r 选项，这将影响到目录树中所有层级的文件名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 注册单元服务</title>
    <link href="/2024/12/10/linux/linux%E6%B3%A8%E5%86%8C%E5%8D%95%E5%85%83%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/12/10/linux/linux%E6%B3%A8%E5%86%8C%E5%8D%95%E5%85%83%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-注册单元服务"><a href="#Linux-注册单元服务" class="headerlink" title="Linux 注册单元服务"></a>Linux 注册单元服务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>systemctl是一个系统软件服务的管理工具，可以用于启动、停止、重启和重新加载服务，查看服务状态以及设置默认启动级别等。它还可以管理服务之间的依赖关系，定制服务配置，并对服务的日志进行管理</p></blockquote><blockquote><p>Linux中，定义软件服务的文件通常是systemd服务单元文件，具有<code>.service</code>后缀，这些文件通常位于以下目录：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">/etc/systemd/system/<br><br>/usr/lib/systemd/system<br><br>/lib/systemd/system<br></code></pre></td></tr></table></figure><h2 id="Service文件"><a href="#Service文件" class="headerlink" title="Service文件"></a>Service文件</h2><h3 id="格式说明"><a href="#格式说明" class="headerlink" title="格式说明"></a>格式说明</h3><p>service文件通常由三部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs te">[Unit]：定义与Unit类型无关的通用选项，用于提供unit的描述信息、unit行为及依赖关系等<br><br>[Service]：与特定类型相关的专用选项，此处为Service类型<br><br>[Install]：定义由“systemctl enable”以及&quot;systemctl disable“命令在实现服务启用或禁用时用到的一些选项<br></code></pre></td></tr></table></figure><p>注意</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">以<span class="hljs-params">#</span>开头的行后面的内容会被认为是注释<br><br>1、yes、on、true代表开启，0、no、off、false代表关闭<br><br>时间单位默认是秒，可以用毫秒（ms）分钟（m）等须显式说明<br></code></pre></td></tr></table></figure><h3 id="Unit部分"><a href="#Unit部分" class="headerlink" title="Unit部分"></a>Unit部分</h3><table><thead><tr><th>可选项</th><th>描述</th></tr></thead><tbody><tr><td>Description</td><td>对当前服务的简单描述</td></tr><tr><td>After</td><td>可以指定在哪些服务之后进行启动</td></tr><tr><td>Before</td><td>可以指定服务依赖于哪些服务(这种依赖是”强依赖”，一旦所依赖的服务异常，当前的服务也随之停止)</td></tr><tr><td>Requires</td><td>可以指定服务依赖于哪些服务(这种依赖是”弱依赖”，即使所依赖的服务的启动情况不影响当前的服务是否启动)</td></tr><tr><td>Wants</td><td>可以指定服务依赖于哪些服务(这种依赖是”弱依赖”，即使所依赖的服务的启动情况不影响当前的服务是否启动)</td></tr><tr><td>Conflicts</td><td>定义units间的冲突关系</td></tr></tbody></table><h3 id="Service部分"><a href="#Service部分" class="headerlink" title="Service部分"></a>Service部分</h3><table><thead><tr><th>可选项</th><th>描述</th></tr></thead><tbody><tr><td>EnvironmentFile</td><td>环境配置文件，用来指定当前服务启动的环境变量</td></tr><tr><td>ExecStart</td><td>指定服务启动时执行的命令或脚本</td></tr><tr><td>ExecStartPre</td><td>指定服务启动前执行的命令或脚本</td></tr><tr><td>ExecStartPost</td><td>指定服务启动后执行的命令或脚本</td></tr><tr><td>ExecStop</td><td>指明停止服务要运行的命令或脚本</td></tr><tr><td>ExecStopPost</td><td>指定服务停止之后执行的命令或脚本</td></tr><tr><td>RestartSec</td><td>指定服务在重启时等待的时间，单位为秒</td></tr><tr><td>ExecReload</td><td>指明重启服务要运行的命令或脚本</td></tr><tr><td>Restart</td><td>当设定Restart&#x3D;1 时，则当次daemon服务意外终止后，会再次自动启动此服务，具体看下列类型</td></tr><tr><td>PrivateTmp</td><td>设定为yes时，会在生成&#x2F;tmp&#x2F;systemd-private-UUID-NAME.service-XXXXX&#x2F;tmp&#x2F;目录</td></tr><tr><td>KillMode</td><td>指定停止的方式，具体见下面</td></tr><tr><td>Restart</td><td>指定重启时的类型，具体见下面</td></tr><tr><td>Type</td><td>指定启动类型，具体见下面</td></tr></tbody></table><p>Type的可选值</p><table><thead><tr><th><strong>type可选项</strong></th><th>描述</th></tr></thead><tbody><tr><td>simple</td><td>指定ExecStart字段的进程为主进程</td></tr><tr><td>forking</td><td>指定以fork() 子进程执行ExecStart字段的进程</td></tr><tr><td>oneshot</td><td>执行一次</td></tr><tr><td>notify</td><td>启动后发送会发送通知信号通知systemd</td></tr><tr><td>idle</td><td>等其他任务结束后才运行</td></tr></tbody></table><p>Restart的可选值</p><table><thead><tr><th>Restart可选项</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>no</td><td>退出后不会重启</td></tr><tr><td>on-success</td><td>当进程正常退出时(退出码为0) 执行重启</td></tr><tr><td>on-failure</td><td>当进程不正常退出时(退出码不为0) 执行重启</td></tr><tr><td>on-abnormal</td><td>当被信号终止和超时执行重启</td></tr><tr><td>on-abort</td><td>当收到没有捕捉到的信号终止时执行重启</td></tr><tr><td>on-watchdog</td><td>当看门狗超时时执行重启</td></tr><tr><td>always</td><td>一直重启</td></tr></tbody></table><p>KillMode可选值</p><table><thead><tr><th>KillMode可选项</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>control-group</td><td>杀掉当前进程中所有的进程</td></tr><tr><td>process</td><td>杀掉当前进程的主进程</td></tr><tr><td>mixed</td><td>主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</td></tr><tr><td>none</td><td>不杀掉任何进程</td></tr></tbody></table><h3 id="Install部分"><a href="#Install部分" class="headerlink" title="Install部分"></a>Install部分</h3><table><thead><tr><th>Install可选项</th><th>描述</th></tr></thead><tbody><tr><td>Alias</td><td>别名，可使用systemctl command Alias.service</td></tr><tr><td>RequiredBy</td><td>被哪些units所依赖，强依赖</td></tr><tr><td>WantedBy</td><td>被哪些units所依赖，弱依赖</td></tr><tr><td>Also</td><td>安装本服务的时候还要安装别的相关服务</td></tr><tr><td>Install</td><td>一般填为WantedBy&#x3D;multi-user.target</td></tr></tbody></table><p>注意</p><blockquote><p>对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启，使用命令 <code>systemctl daemon-reload</code></p></blockquote><h2 id="自定义Service服务"><a href="#自定义Service服务" class="headerlink" title="自定义Service服务"></a>自定义Service服务</h2><blockquote><p>这里将一个frpc软件定义成一个服务，通过使用<code>systemctl</code>命令进行启动、停止等的管理操作。</p></blockquote><h3 id="创建service文件"><a href="#创建service文件" class="headerlink" title="创建service文件"></a>创建service文件</h3><p>新建<code>frpc.service</code>的service文件，填写以下内容，配置文件信息根据软件(frpc)文件路径更改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Unit]<br>Description=Frpc Client Service<br>After=network.target<br> <br>[Service]<br>Type=simple<br>Restart=always<br>TimeoutStartSec=30<br>Restart=on-failure<br>RestartSec=5s<br>ExecStart=/usr/local/program/frp/frpc -c /usr/local/program/frp/frpc.ini<br>ExecStop=/bin/kill <span class="hljs-variable">$MAINPID</span><span class="hljs-comment"># 强制终止 关闭主进程 相对而言 直接使用systemctl stop 更优雅 给服务更多机会释放资源 </span><br>ExecReload=/usr/local/program/frp/frpc reload -c /usr/local/program/frp/frpc.ini<br> <br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h3 id="启动系统服务"><a href="#启动系统服务" class="headerlink" title="启动系统服务"></a>启动系统服务</h3><p>将<code>frpc.service</code>文件复制到<code>/lib/systemd/system</code>里面，然后重新加载systemctl配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> ./frpc.service /lib/systemd/system<br>systemctl <span class="hljs-built_in">enable</span> frpc  <br>systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>启动创建好的服务，并设置自启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 重新加载配置文件</span><br>systemctl daemon-reload<br> <br><span class="hljs-comment"># 启动frpc服务</span><br>systemctl start frpc<br> <br><span class="hljs-comment"># 开机自启动frpc服务</span><br>systemctl <span class="hljs-built_in">enable</span> frpc<br> <br><span class="hljs-comment"># 查看frpc当前状态</span><br>systemctl status frpc<br></code></pre></td></tr></table></figure><h2 id="systemctl命令集合"><a href="#systemctl命令集合" class="headerlink" title="systemctl命令集合"></a>systemctl命令集合</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#语法</span><br>systemctl COMMAND name.service<br><span class="hljs-comment">#启动</span><br>systemctl start name.service<br><span class="hljs-comment">#停止</span><br>systemctl stop name.service<br><span class="hljs-comment">#重启</span><br>systemctl restart name.service<br><span class="hljs-comment">#查看状态</span><br>systemctl status name.service<br><span class="hljs-comment">#禁止自动和手动启动</span><br>systemctl mask name.service<br><span class="hljs-comment">#取消禁止</span><br>systemctl unmask name.service<br><span class="hljs-comment">#查看某服务当前激活与否的状态</span><br>systemctl is-active name.service<br><span class="hljs-comment">#查看所有已经激活的服务</span><br>systemctl list-units --<span class="hljs-built_in">type</span>|-t service<br><span class="hljs-comment">#查看所有服务</span><br>systemctl list-units --<span class="hljs-built_in">type</span> service --all<br><span class="hljs-comment">#设定某服务开机自启，相当于chkconfig name on</span><br>systemctl <span class="hljs-built_in">enable</span> name.service<br><span class="hljs-comment">#设定某服务开机禁止启动：相当于chkconfig name off</span><br>systemctl <span class="hljs-built_in">disable</span> name.service<br><span class="hljs-comment">#查看所有服务的开机自启状态，相当于chkconfig --list</span><br>systemctl list-unit-files --<span class="hljs-built_in">type</span> service<br><span class="hljs-comment">#用来列出该服务在哪些运行级别下启用和禁用：chkconfig –list name</span><br><span class="hljs-built_in">ls</span> /etc/systemd/system/*.wants/name.service<br><span class="hljs-comment">#查看服务是否开机自启</span><br>systemctl is-enabled name.service<br><span class="hljs-comment">#列出失败的服务</span><br>systemctl --failed --<span class="hljs-built_in">type</span>=service<br><span class="hljs-comment">#开机并立即启动或停止</span><br>systemctl <span class="hljs-built_in">enable</span> --now postfix<br>systemctl <span class="hljs-built_in">disable</span>  --now postfix<br><span class="hljs-comment">#查看服务的依赖关系</span><br>systemctl list-dependencies name.service<br><span class="hljs-comment">#杀掉进程</span><br>systemctl <span class="hljs-built_in">kill</span> unitname<br><span class="hljs-comment">#重新加载配置文件</span><br>systemctl daemon-reload<br><span class="hljs-comment">#关机</span><br>systemctl halt、systemctl poweroff<br><span class="hljs-comment">#重启</span><br>systemctl reboot<br><span class="hljs-comment">#挂起</span><br>systemctl <span class="hljs-built_in">suspend</span><br><span class="hljs-comment">#休眠</span><br>systemctl hibernate<br><span class="hljs-comment">#休眠并挂起</span><br>systemctl hybrid-sleep<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql之B+树</title>
    <link href="/2024/12/10/tools/MySql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BB+%E6%A0%91/"/>
    <url>/2024/12/10/tools/MySql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="MySql的数据存储之B-树"><a href="#MySql的数据存储之B-树" class="headerlink" title="MySql的数据存储之B+树"></a>MySql的数据存储之B+树</h1><h2 id="1-MySql的实际存储位置"><a href="#1-MySql的实际存储位置" class="headerlink" title="1 MySql的实际存储位置"></a>1 MySql的实际存储位置</h2><p>B+树是MySql数据结构的主流存储方式，包括InnoDB和MYISAM引擎，它们的默认存储结构都是B+树</p><p>了解B+树前，我们先要知道MySql 的实际存储位置在哪？</p><p>有人会说它存在我么的D盘或C盘的MySql文件夹的Data目录里，这个回答没错，我们在深入的了解一下呢？</p><p>不管是在个人电脑上使用本机MySql或者在互联网上把信息存在服务器上，其实它们最终的存储地址都是被写在了物理磁盘上，只有存在物理磁盘上，才能保证数据长久不丢失</p><p>物理磁盘一般可以描述为：柱面，磁面，扇区，通过这三个参数可以精准定位到数据所在的地方</p><p><strong>我们来看看一个普通的磁面：</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/Screenshot1.png?raw=true" alt="磁面图"></p><p>我们可以看到这个磁面上记录着磁道和扇区，</p><p>一般磁盘定位有固定头和移动头两种：</p><p>固定头每个磁道上都有一个读写头，造价高，但是读写速度快，定位时间短</p><p>移动头每个磁面上一个读写头，造价适中，读写速度主要取决于定位时间，从定位磁道，再到定位扇区所化的时间，现行的物理磁盘大多都是使用的移动头定位。</p><p>我们在了解了我们的磁盘和移动头后，我们就需要了解一次物理磁盘的I&#x2F;O，它指的是对于磁盘来说，一次磁盘的连续读或者连续写称为一次磁盘 I&#x2F;O, 磁盘的 IOPS 就是每秒磁盘连续读次数和连续写次数之和。</p><p>我们这里就把他当作读写一次扇区，即一次I&#x2F;O只读写一个扇区（实际上的I&#x2F;O指的是根据查询的数据大小，可能会连续读写好几个或者几百个扇区，但是也只进行了一次I&#x2F;O，因为I&#x2F;O读写的时间开销最大的还是在移动头的定位时间上）</p><p>一个扇区的大小比较公认的是512字节（后面慢慢发展的也有一个扇区2048字节的，我们这里就举例512字节）</p><p><strong>我们先简单的看一个数据表，数据在扇区上是怎么存储的：</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513100745862-1612056196.png?raw=true" alt="2846424-20230513100745862-1612056196"></p><p>这里我们定义了一张表，还有里面的数据，他有三个属性：id 8字节，name 40字节，no 16字节</p><p>由此我们可以推出：这张表的一条记录就是8+40+16&#x3D;64字节，我们这会儿定义的这张表的一条记录就要占64字节</p><p>一个扇区512字节：512&#x2F;64&#x3D;8</p><p>所以一个扇区就只能装8条记录，我们这32条记录就需要32&#x2F;8&#x3D;4，就需要4个扇区去装入，</p><p>如果我们按照规定的一次I&#x2F;O读写一个扇区，那我们要找到32这条记录的话需要4次I&#x2F;O操作，4次还算一般性能，但是我们在大型的数据库存储一张表可不止32条记录哦</p><p>但我们简单的把记录加到800条的时候：800&#x2F;8 &#x3D; 100 ，也就是需要100个扇区来装入，那我们要查找第800条记录的时候就需要100次I&#x2F;O操作，显然这样的I&#x2F;O操作就太慢了，要是有1000个人需要查找，时间开销就很大了</p><p>这种情况我们就需要引入索引；B+树的根节点几乎全是索引</p><h2 id="2-MySql的索引"><a href="#2-MySql的索引" class="headerlink" title="2 MySql的索引"></a>2 MySql的索引</h2><p>什么是索引呢？</p><p>索引是为了加速对表中数据行的检索而创建的一种分散的存储结构。索引是针对表而建立的，它是由数据页面以外的索引页面组成的，每个索引页面中的行都会含有逻辑指针，以便加速检索物理数据。</p><p>简单的说，索引就是建表或者后期加入的，它可以分为主键索引，复合索引，普通索引，</p><p>当我们建立索引以后，就会自动的把建立索引的属性或属性组单独的拿出来然后和这个属性所在的物理地址一起单独构成一个表来存放，虽然多了一个表但是因为属性较少，所占的空间少，查询效率高了</p><p><strong>这里我们再来简单的看两个表：</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513103130886-1795854003-17236910800611.png?raw=true" alt="2846424-20230513103130886-1795854003"></p><p> 这里我们可以看到右边的表就是我们的数据表，它记录着800条记录，上面我们也看到了它要被查询到的话需要100次I&#x2F;O，所以我们考虑为id建一个索引</p><p>当id被选为索引以后，id会和id所在的实际物理地址构成一个表，这个表id 8字节，地址 8字节，一共16字节，它也是存在一个扇区的还有可能没有和数据原表在相邻的扇区</p><p>一个扇区的的大小512字节：512&#x2F;16 &#x3D; 32，所以这个索引表所在的扇区，可以装32条记录</p><p>第一条记录：记录id为1，它所在的物理地址，</p><p>第二条记录：记录id为33，它所在的物理地址，</p><p>第三十二条记录：记录id为1023，它所在的物理地址</p><p><strong>有了这个索引表之后，我们再查800条记录数据的过程就简单化了</strong></p><p>首先，一次I&#x2F;O操作会把这个索引表查出来（要用到索引才能命中，也就是再sql语句中的条件判断语句带有id），这里只进行了一次I&#x2F;O就拿到了1<del>33，33</del>65，….~1023这些区间的信息</p><p>然后，我们查第800条记录的时候我们很幸运，因为索引表中有一个区间是800~833就可以通过地址直接去读800所在的扇区 这里就也只用了一次I&#x2F;O操作</p><p>这是最好的情况：2次I&#x2F;O就拿到了第800条件记录</p><p>我们看看最坏的情况，细心的朋友可以发现再每个区间都有一个最坏情况，</p><p>比如：</p><p>1~33区间上，当我们要查询32时只能通过找到id&#x3D;1的扇区，然后依次读取直到读到id&#x3D;32的扇区</p><p>33~65区间上，当我们要查询64时只能通过找到id&#x3D;33的扇区，然后依次读取直到读到id&#x3D;64的扇区</p><p>……</p><p>800~833区间上，我们去查找832时：</p><p>只会给我们找到800的首地址，这是一次I&#x2F;O读写了</p><p>从800读到832一共是32条记录：32&#x2F;8&#x3D;4（扇区），也就是我们要连续读取4个扇区才可以找到id &#x3D; 832这条记录，这就需要4次I&#x2F;O</p><p>我们可以看到，即使是最坏的情况：1+4&#x3D;5，我们也只需要5次I&#x2F;O就可以拿到任意的数据了</p><p>比起没有索引的查询：从第32条记录开始，就会成比例的不断增大读写次数</p><p>有索引的情况的查询：最坏的情况也就5次I&#x2F;O操作，但是索引需要单独存储，总的来说还是利大于弊，不建议建立索引，因为索引的维护需要开销，一般只会给经</p><p>常查询且不常更改的数据做索引</p><p><strong>继续加大数据，这次存放80000条记录：</strong></p><p>当数据量达到80000条的时候：我们的一级索引表（紧贴实际数据表的索引表被称为一级索引）就显得的很乏力了，</p><p>我们简单的计算一下，我们的一级索引表只能存放1~1025记录的区间地址，当数据为80000</p><p>80000&#x2F;1024 &#x3D; 78~79，我们需要79个扇区来存储</p><p>如果是最坏的情况：我们要查找第80000条记录，那么在一级索引表中我们就进行了79次I&#x2F;O操作了，再加上一级索引表去查实际数据的地址又是4次I&#x2F;O，所以在这种情况下就是79+4&#x3D;83次I&#x2F;O</p><p>对于80000条数据查询就需要83次I&#x2F;O，很显然，这个I&#x2F;O次数太多了，我们得想办法把I&#x2F;O次数压下去</p><p> 这个时候我们的开发者想到的就是加一层，二级索引来指向一级索引，一级索引指向数据，对于B+树结构来说就是多了一层</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513131455394-112588750.png?raw=true" alt="2846424-20230513131455394-112588750"></p><p>在二级索引上的adress字段就是记录的一级索引的地址，而不直接指向数据，在二级索引就是记录一个一级扇区的位置</p><p>比如：</p><p>一级索引一个扇区的数据区间在1~1025</p><p>二级索引一条记录的就是一级索引区间的1~1025</p><p> 所以一个二级索引扇区可以记录一级索引区间的范围是：</p><p>1024 * 32 &#x3D; 32768</p><p>对于有80000条记录的表，二级索引扇区只需要3个就可以放下</p><p><strong>这个时候利用二级索引查找80000：</strong></p><p>1.首先我们要找到80000这个区间，他在第三个扇区上，那么在二级索引上的I&#x2F;O读写就需要 3次</p><p>然后去一级索引上找，由于是二级索引提供的物理地址，只需要一次I&#x2F;O就可以读取到那个扇区，一级索引上有一个区间就是80000~81025，</p><p>最后去找实际的数据刚好80000就是头指针，也只需要一次I&#x2F;O就可以完成</p><p>这是最好的一种情况：3+1+1&#x3D;5，最好的状态5次I&#x2F;O就可以拿到数据了</p><p> 2.最坏的情况也是出现在一级索引去找数据：就是80000~80033这个区间</p><p>我们要找80032的时候，只能通过首地址为80000的地址去找，要连续查找4个扇区，就是4次I&#x2F;O操作才能拿到</p><p>3+1+4&#x3D;8</p><p>所以在B+树上加了一层以后最坏，不管什么情况下，查找任意数据都只需要8次I&#x2F;O操作，</p><p>综上：查找80000条数据（最坏的情况）</p><p>a.没有索引，一个扇区一个扇区的查找，80000&#x2F;8 &#x3D; 10000，没有索引需要10000次I&#x2F;O操作</p><p>b.一级索引，由于第80000条记录在最后一个扇区上，80000&#x2F;1024 &#x3D; 79 ，一级索引需要79次I&#x2F;O，利用一级索引去查找数据4次I&#x2F;O，一级索引需要83次I&#x2F;O操作</p><p>c.二级索引，由于第80000条记录在最后一个扇区上，80000 &#x2F; 32768 &#x3D; 3，二级索引需要3次I&#x2F;O，利用二级索引的区间地址去找一级索引只需要1次I&#x2F;O，然后一级索引去找数据需要4次I&#x2F;O，二级索引查找数据就只需要8次I&#x2F;O操作</p><p><strong>可能对博客中的例子存在的疑问：</strong></p><p>a.索引表的区间范围一定是32吗？</p><p>不是，要根据开发人员的默认设置，或者后期数据库管理员去调整，一般人是更改不了物理存储的，只能了解原理</p><p>b.索引的表每条记录都是16字节吗？</p><p>不是，要根据建立索引属性的大小和实际物理地址大小而定，不一定每个扇区都能存刚好存32条索引记录</p><p>c.800条记录没有索引的情况真的要100次I&#x2F;O操作吗？</p><p>不是，要根据一次读取的页面大小，MySql的默认读取是16KB：16kb &#x2F; 64 &#x3D;250 条记录，一般的查询一次I&#x2F;O至少就是250条记录，</p><p>根据计算机局部性原理，当一个扇区的数据被使用后，它周围的数据极有可能再最近会被用到，所以mysql的缓存机制会支持一次查询返回4页，即从查询的当前的页开始往后磁头移动4页的大小，4*16&#x3D;64kb</p><p>也就是64kb &#x2F; 64 &#x3D; 100条记录，在缓存中有一次I&#x2F;O是有100条记录被返回，然后怎么查询就是InnoDB引擎所要了解的知识了</p><h2 id="3-MySql中B-树索引存储结构的形成"><a href="#3-MySql中B-树索引存储结构的形成" class="headerlink" title="3 MySql中B+树索引存储结构的形成"></a>3 MySql中B+树索引存储结构的形成</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513140022983-1295848335.png?raw=true" alt="2846424-20230513140022983-1295848335"></p><p>这就是一颗较为完整的B+树了，我们在仔细的看看可以发现B+树的特征</p><p>a.索引区间由根节点不断的变小，描述数据所在的扇区也越来越细化</p><p>b.根节点存放的都是索引，只有最下面一层的子节点才是数据</p><p>我们看完了B+树的形成过程以及它的大致模型，我们就不得不提一下它和B树的区别了，这是更深了解B+树的关键，</p><p>现在图片上描述的B+树，其实B树有很大一部分都能做到，我们就来看看B树和B+树的区别吧</p><h3 id="B树和B-树的区别（主要的区别）"><a href="#B树和B-树的区别（主要的区别）" class="headerlink" title="B树和B+树的区别（主要的区别）"></a><strong>B树和B+树的区别（主要的区别）</strong></h3><h4 id="区别1："><a href="#区别1：" class="headerlink" title="区别1："></a><strong>区别1：</strong></h4><p>B树的在根节点也存有数据，然后根节点存储的数据又是索引，又是数据</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513142254511-1038566211.png?raw=true" alt="2846424-20230513142254511-1038566211"></p><p> 如图，在索引上出现的数据就不会在子节点出现了</p><p>可以说父节点可能既有索引又有数据，这就是B树的存储方式</p><p>B+树根节点没有数据，只存放索引</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513143219545-2067039685.png?raw=true" alt="2846424-20230513143219545-2067039685"></p><p> 如图，数据都在最下面一层的子节点上，除了这一层以外的父节点全是索引没有数据</p><p>B树，存在一种情况就是所查的数据在最上层，因为节点有数据可能第80000条记录在最上层区间上，所以一次I&#x2F;O就可以拿到数据，最坏的情况就和B+树一样，要到最后一层才能拿到数据</p><p>B+树，每次拿数据都需要在最下一层去拿，即使我们去拿一个表的第一条记录，它也会从根结点一级一级的往下直到最后一层才有数据</p><p>感觉有时候B树比B+树快啊，为什么MySql要用B+树呢？</p><p>因为B+树的查询比B树更加稳定，有利于开发者，数据库管理员对其进行性能测试，运行时日志检测的数据也会很准确</p><p>举个简单的例子，就以上面两张图片：我们要查询第7条数据和第8条数据，这两条记录是紧挨着的</p><p>使用B树查询：</p><p>第七条记录：1次I&#x2F;O</p><p>第八条记录：2次I&#x2F;O</p><p>使用B+树查询：</p><p>第七条记录：2次I&#x2F;O</p><p>第八条记录：2次I&#x2F;O</p><p>我们可以看到使用B树的第一次查询需要1次I&#x2F;O，第二个需要2次I&#x2F;O，B+树则都需要两次</p><p>这就很明显阿可以看出B树的查询效率很不稳定，尤其是层数变多，数据区间变得的时候，就更加明显</p><h4 id="区别2"><a href="#区别2" class="headerlink" title="区别2"></a><strong>区别2</strong></h4><p>这个区别是B+树特有的，</p><p>在B树上子节点和子节点是相互隔离开的，现在我们构造一种情况，B树中我们一条查询语句需要查询两条记录，</p><p>比如  id &#x3D; 6  and id &#x3D; 8</p><p>由于这是一条查询语句，所以要一起执行会发生什么，我们的磁头会先移动到根节点进行定位，然后就可以id &#x3D; 6这条记录，然后从新去根节点查索引，磁头再定</p><p>位到 id &#x3D; 8 这条记录</p><p>很显然我们的B树查询进行了两次磁头定位，我们知道在读写磁盘时，最大的开销就是磁头的定位，所以我们要尽量少的进行磁头定位</p><p>所以，B+树在最后一层的数据结点上都加了指针（指向的是物理地址），让它指向下一个区间的开始位置，把尾部的数据又串起来了，就是专门对付这种相邻区间要重复磁头定位的情况</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2846424-20230513151547063-131791169.png?raw=true" alt="2846424-20230513151547063-131791169"></p><p>有了这个尾部指针，我们在用B+树去查找 id &#x3D;6 和 id &#x3D; 8的记录，当经过一次磁头定位以后找到了id &#x3D; 6 的记录，它会根据尾指针直接读取 id &#x3D; 8的记录，加快了相邻扇或几个相邻扇区的读写速度</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>在 B+树中，查询相隔多个数据页的数据时，一旦找到第一个数据页，后续查询通常不需要从根节点开始遍历。这是因为 B+树的叶子节点（数据页）之间通过双向链接相连，使得可以直接从一个叶子节点跳转到相邻的叶子节点。这意味着从第一个数据页开始，可以直接遍历到第二个数据页，而无需再次从根节点开始。</p><p><strong>查询流程</strong></p><ol><li><strong>查找第一个数据页</strong>：<ul><li>从根节点开始遍历 B+树，使用索引键值来定位到包含目标数据的第一个叶子节点（数据页）。</li></ul></li><li><strong>访问第二个数据页</strong>：<ul><li>一旦找到第一个数据页，可以直接通过该数据页与相邻叶子节点之间的链接来访问第二个数据页。</li><li>不需要再次从根节点开始遍历 B+树。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语法笔记</title>
    <link href="/2024/12/10/go/%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/10/go/%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="记不住系列"><a href="#记不住系列" class="headerlink" title="记不住系列"></a>记不住系列</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong><code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>    IdOrName any   <span class="hljs-string">`json:&quot;idOrName&quot;`</span><br>    M        MyInt <span class="hljs-string">`json:&quot;m&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">&quot;nihao&quot;</span><br>    u := User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// u 是 User1 类型的变量</span><br><br>    <span class="hljs-comment">// 若要声明一个 User1 类型的指针，应如下所示：</span><br>    uPtr := &amp;User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// uPtr 是 *User1 类型的指针变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>u</code> 是 <code>User1</code> 结构体的一个实例，直接存储结构体的值；而如果声明一个指针变量，应该使用取址运算符 <code>&amp;</code>，如 <code>uPtr</code> 示例所示。指针变量存储的是结构体实例的内存地址，而不是结构体的值本身。</p><p>在 Go 语言中，当你修改一个指针类型地址指向的值时，实际上是在修改指针所指向的内存区域中的值；而当你直接修改一个变量的值时，是在修改该变量所在内存区域的值。下面是两者的区别：</p><ol><li><p><strong>修改指针类型地址指向的值：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> ptrToM *MyInt = &amp;m <span class="hljs-comment">// 创建一个指向 m 的指针</span><br><br><span class="hljs-comment">// 修改指针指向的值</span><br>*ptrToM = <span class="hljs-number">20</span> <span class="hljs-comment">// 此时，m 的值变为 20，因为 ptrToM 指向 m 的内存地址</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure><p>在这里，<code>ptrToM</code> 是一个指向 <code>MyInt</code> 类型变量 <code>m</code> 的指针。通过 <code>*ptrToM = 20</code>，我们改变了 <code>ptrToM</code> 所指向内存区域的值，也就是变量 <code>m</code> 的值。</p></li><li><p><strong>直接修改变量的值</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 直接修改变量的值</span><br>m = <span class="hljs-number">20</span> <span class="hljs-comment">// 直接将 m 的值改为 20</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure><p>在这里，我们直接操作变量 <code>m</code>，将其值设为 20，这是对变量自身内存区域的修改。</p></li></ol><p>简而言之，指针修改的是它指向的内存位置的值，而直接修改变量则是修改变量自身的内存位置的值。使用指针可以在不复制大量数据的情况下修改大型数据结构，还可以实现对函数内部局部变量的修改（通过传递指针作为参数），从而达到引用传递的效果。</p><ol><li><strong>内存地址</strong>：内存地址是计算机内存中每个存储位置的编号，用来唯一标识内存中的一个存储单元。程序运行时，变量、数据结构、指令等都会被加载到内存中，并且每个都有对应的内存地址。</li><li><strong>指针（Pointer）</strong>：在编程语言中，指针是一种数据类型，它存储的就是这样一个内存地址。通过指针，程序能够直接访问和修改内存中的数据。例如，在go中，声明一个整型指针变量 <code>int *p;</code>，通过赋值 <code>p = &amp;x;</code>（其中x为一个整型变量），指针p就存储了x变量的内存地址，进而可以使用 <code>*</code>p &#x3D; 10;&#96; 来改变x的值。</li></ol><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在Go语言中，<code>map</code> 类型相当于Python中的 <code>dict</code>（字典）类型。两者都是关联数组或哈希表的实现，提供了通过键（key）来访问和存储值（value）的能力</p><ul><li><p>在 Go 语言中声明一个 map：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// 创建一个键为string类型，值为int类型的map</span><br><span class="hljs-comment">// 插入或更新元素</span><br>myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">// 如果&quot;apple&quot;这个键不存在，则插入；如果存在，则更新其值为5</span><br><span class="hljs-comment">// 删除键为&quot;apple&quot;的元素</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;apple&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>在 Python 中声明一个 dict：</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>两者都可以通过键来添加、修改、删除和查找元素，并且它们都不保证元素的迭代顺序是固定的（在Go 1.18版本之前）。此外，Go 的 map 和 Python 的 dict 都要求键必须是可比较的类型。在Go中，键通常是整数、浮点数、字符串或指针等；在Python中，键可以是不可变类型，如整数、浮点数、字符串、元组等。</p><h2 id="切片（Slices）"><a href="#切片（Slices）" class="headerlink" title="切片（Slices）"></a>切片（Slices）</h2><p><strong>Go语言中的切片（Slices）</strong>： 对应于Python中的<strong>列表（List）</strong>。两者都是可变长度的序列，可以动态添加、删除或修改元素。Go语言中的切片虽然基于数组实现，但提供了更灵活的接口，无需预先指定固定长度，可以自由扩展。在Python中，列表支持索引访问、切片操作以及其他丰富的内置方法，如append、extend、pop等，这些功能与Go语言切片相似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指定长度为0 </span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//或者给定预期长度</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>切片会自动扩容</p><p>扩容策略一般为:</p><ul><li>若原容量小于1024,新容量为原容量的2倍</li><li>若原容量大于或等于1024,新容量增长1.25倍</li></ul><p>影响性能不报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// len=5, cap=10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// len=8, cap还是10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">4</span>) <span class="hljs-comment">// 超过cap,cap增加到20,重新分配内存</span><br></code></pre></td></tr></table></figure><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个长度为 n 的数组，元素类型为 T</span><br><span class="hljs-keyword">var</span> arr [n]T<br><br><span class="hljs-comment">// 示例：声明一个长度为 5 的整数数组</span><br><span class="hljs-keyword">var</span> numbers [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 或者同时初始化</span><br>numbers := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>在某些方面类似于Python中的<strong>元组（Tuples）</strong>，特别是当它们用来表示固定长度且不可变的数据序列时。然而，Go语言中的数组与Python中的元组有几个关键区别：</p><ul><li><p>Go语言的数组是固定长度的，一旦创建后不能改变长度；</p></li><li><p>Python的元组虽然是不可变序列，但一般不强调其内部元素必须是同一类型，而Go语言的数组要求所有元素必须是同一类型；</p></li><li><p>Python中没有与Go语言数组完全一一对应的结构，因为Python的列表和元组都可以包含多种类型的元素，而且元组虽然不可变，但长度可以变化（通过组合多个元组形成新元组）。</p></li><li><p>数组长度固定，创建后不可变；切片长度可变。</p></li><li><p>数组是值类型；切片是引用类型（类似于指针）。</p></li><li><p>数组通过索引访问；切片除了索引访问外，还可以通过切片表达式创建新的切片视图。</p></li><li><p>切片是对数组的部分引用，更灵活，适用于动态变化的序列数据处理场景。</p></li></ul><h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><p>在Go语言中，结构体（struct）相当于Python中的类实例或命名元组（namedtuple）。结构体是用来封装多个字段的复合数据类型，每个字段都有一个名称和对应的类型</p><p>在Go语言中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br>p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p>在Python中，使用类定义类似的数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>或者使用命名元组（collections.namedtuple）实现更轻量级的、不可变的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])<br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>两者都可以用来表示具有固定属性的数据对象。不过，需要注意的是，Go语言中的结构体默认不包含方法，如果需要添加行为（如函数），可以为结构体定义方法；而Python类则通常包含了数据属性和方法，更加面向对象。</p><p>在Go语言中，为结构体定义方法的案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个结构体Person</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 为Person结构体定义一个SayHello方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SayHello() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hello, my name is %s and I am %d years old.\n&quot;</span>, p.Name, p.Age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个Person实例</span><br>    alice := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">25</span>&#125;<br><br>    <span class="hljs-comment">// 调用Person实例的方法</span><br>    alice.SayHello() <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 25 years old.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="make和new有什么区别"><a href="#make和new有什么区别" class="headerlink" title="make和new有什么区别"></a>make和new有什么区别</h2><p><strong>new 创建一个该类型的实例，并且返回指向该实例的指针。new 函数是内建函数，函数定义：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span></span> *Type<br></code></pre></td></tr></table></figure><ul><li>使用 new 函数来分配空间</li><li>传递给 new 函数的是一个类型，而不是一个值</li><li>返回值是指向这个新分配的地址的指针</li></ul><p><strong>示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">pInt := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)         <span class="hljs-comment">// 分配一个 int 类型的零值，并返回指向它的指针</span><br>*pInt = <span class="hljs-number">42</span>               <span class="hljs-comment">// 解引用指针，给 int 类型的值赋值</span><br>pSlice := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)     <span class="hljs-comment">// 分配一个切片的零值，也就是 nil，但通常不这么用</span><br></code></pre></td></tr></table></figure><p><strong>make 的作用是为 slice, map or chan 的初始化 然后返回引用make 函数是内建函数，函数定义：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(Type, size IntegerType)</span></span> Type<br></code></pre></td></tr></table></figure><ul><li>make(T, args)函数的目的和 new(T)不同 仅仅用于创建 slice, map,channel 而且返回类型是实例</li></ul><p><strong>示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)     <span class="hljs-comment">// 创建一个长度为5的切片，初始化为零值</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">// 创建一个空的映射</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)   <span class="hljs-comment">// 创建一个带缓冲的通道</span><br></code></pre></td></tr></table></figure><h2 id="接口类型（interface）"><a href="#接口类型（interface）" class="headerlink" title="接口类型（interface）"></a>接口类型（interface）</h2><p>在 Go 语言中，<code>interface&#123;&#125;</code> 类型被称为“空接口”，它不包含任何方法签名。由于任何类型都至少实现了零个方法（即不实现任何方法），所以任何 Go 语言中的类型都能赋值给 <code>interface&#123;&#125;</code> 类型的变量。这使得 <code>interface&#123;&#125;</code> 成为了一个通用的类型容器，能够在不知道具体类型的情况下存储任意类型的值，从而起到解耦类型的作用，增强了代码的灵活性和扩展性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br>any = <span class="hljs-string">&quot;Hello, World!&quot;</span>  <span class="hljs-comment">// 字符串类型</span><br>any = <span class="hljs-number">42</span>               <span class="hljs-comment">// 整数类型</span><br>any = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;       <span class="hljs-comment">// 空结构体类型</span><br>any = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;        <span class="hljs-comment">// 函数类型</span><br><br><span class="hljs-comment">// 在运行时，可通过类型断言或类型 switches 来确定并操作 any 中的实际类型</span><br>value, ok := any.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然 <code>interface&#123;&#125;</code> 可以存储任何类型的值，但在取出值后，如果不做类型断言还原成具体的类型，就无法访问该类型的任何方法或字段。此外，Go 语言直到 Go 1.18 版本才引入了真正的泛型支持，而在此之前，<code>interface&#123;&#125;</code> 一直是 Go 语言实现泛型编程能力的一种有限方式。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li><p><strong>定义</strong>:</p><ul><li>泛型允许你在函数、方法或类型定义中使用类型参数，这样就可以编写可以工作在多种类型上的代码，而无需为每种类型重复定义代码。</li><li>类型参数 (Type Parameters)<ul><li><strong><code>T</code></strong>: 一般用于泛型函数或类型中，表示一个通用的类型参数，可以代表任何类型，只要该类型满足泛型定义中的约束条件。</li><li><strong><code>V</code></strong>: 常用于表示泛型结构体或接口中的第二个类型参数，特别是在涉及键值对或者多个类型的组合时。</li><li><strong><code>K</code></strong>: 通常用于表示映射(Map)中的键类型，与 <code>V</code> 一起使用，其中 <code>V</code> 表示映射的值类型。</li></ul></li></ul></li><li><p><strong>约束 (Constraints)</strong>:</p><ul><li><p>泛型中的类型参数可以带有约束，这意味着你可以指定类型参数必须满足的条件，例如实现特定的接口。这增强了类型安全性。</p></li><li><p>预定义约束</p><p>Go 标准库提供了几个预定义的约束接口，用于方便地指定类型参数的通用属性：</p><ul><li><strong><code>constraints.Ordered</code></strong>: 表示类型参数必须是可以排序的，例如整数、浮点数、字符串等。</li><li><strong><code>constraints.Integer</code></strong>: 表示类型参数必须是整数类型。</li><li><strong><code>constraints.Float</code></strong>: 表示类型参数必须是浮点数类型。</li><li><strong><code>constraints.Complex</code></strong>: 表示类型参数必须是复数类型。</li><li><strong><code>constraints.Signer</code></strong>: 表示类型参数必须是有符号数类型。</li></ul></li><li><p>自定义约束</p><p>定义自己的约束接口，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Printable <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在泛型声明中使用它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span>[<span class="hljs-title">T</span> <span class="hljs-title">Printable</span>]<span class="hljs-params">(t T)</span></span> &#123;<br>    fmt.Println(t.String())<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>实例化</strong>:</p><ul><li>当你使用泛型函数或类型时，你必须为类型参数提供具体的类型。编译器会生成针对这些具体类型的代码，这称为实例化。</li></ul></li><li><p><strong>示例</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从 Go 1.18 开始支持泛型</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span><br>)<br><br><span class="hljs-comment">// PrintValue 是一个泛型函数，可以打印任何实现了 fmt.Stringer 接口或基本类型（如 int, string 等）的值。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintValue</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span> | <span class="hljs-title">any</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>fmt.Println(value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> anyVar <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, World!&quot;</span> <span class="hljs-comment">// 字符串类型</span><br>PrintValue(anyVar)                       <span class="hljs-comment">// 输出: Hello, World!</span><br><br>anyVar = <span class="hljs-number">42</span>                              <span class="hljs-comment">// 整数类型</span><br>PrintValue(anyVar)                       <span class="hljs-comment">// 输出: 42</span><br><br>anyVar = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;                      <span class="hljs-comment">// 空结构体类型</span><br>PrintValue(anyVar)                       <span class="hljs-comment">// 输出: &#123;&#125;</span><br><br>anyFunc := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;                     <span class="hljs-comment">// 函数类型</span><br><span class="hljs-comment">// 注意：不能直接打印函数，这里只是为了演示泛型函数可以接收函数类型</span><br><span class="hljs-comment">// PrintValue(anyFunc)  // 这一行会编译失败，因为函数类型不能转换为 fmt.Stringer</span><br><br><span class="hljs-comment">// 使用泛型直接处理各种类型，无需通过 interface&#123;&#125; 中转</span><br>PrintValue[<span class="hljs-type">string</span>](<span class="hljs-string">&quot;Hello, World!&quot;</span>) <span class="hljs-comment">// 输出: Hello, World!</span><br>PrintValue[<span class="hljs-type">int</span>](<span class="hljs-number">42</span>)                <span class="hljs-comment">// 输出: 42</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>泛型函数 <code>PrintValue</code></strong>:</p><ul><li><code>PrintValue</code> 函数定义了一个类型参数 <code>T</code>，并且使用了联合约束 <code>constraints.Ordered | any</code>。这意味着 <code>T</code> 可以是任何有序类型（如整数、浮点数）或任何类型（<code>any</code>），这使得 <code>PrintValue</code> 函数可以处理非常广泛的类型。</li><li>函数体中，<code>PrintValue</code> 直接使用 <code>fmt.Println(value)</code> 来打印传入的值。由于 <code>value</code> 的类型是 <code>T</code>，这意味着它能够打印任何类型参数 <code>T</code> 可以表示的值。</li></ul></li><li><p><strong>使用 <code>interface&#123;&#125;</code></strong>:</p><ul><li>在主函数中，<code>anyVar</code> 是一个 <code>interface&#123;&#125;</code> 类型的变量，它可以接收任何类型的值。然后，我们可以将 <code>anyVar</code> 传递给 <code>PrintValue</code> 函数，这是因为 <code>PrintValue</code> 的类型参数 <code>T</code> 可以是 <code>any</code>，包含了 <code>interface&#123;&#125;</code> 的所有可能性。</li></ul></li><li><p><strong>直接使用泛型</strong>:</p><ul><li>在示例的最后部分，我们直接使用了泛型函数 <code>PrintValue</code> 处理具体类型的值，如字符串 <code>&quot;Hello, World!&quot;</code> 和整数 <code>42</code>。这展示了泛型函数的灵活性和类型安全性，因为你必须在调用时明确指定类型参数 <code>T</code> 的具体类型。</li></ul></li></ol><ul><li><strong>接口</strong> 提供了类型间的多态性，允许你编写可以接受多种类型参数的函数，只要这些类型实现了指定的接口。</li><li><strong>泛型</strong> 允许你编写可以工作在多种类型上的代码，通过类型参数和约束来指定泛型函数或类型的适用范围。</li></ul><h2 id="Go语言中的init作用"><a href="#Go语言中的init作用" class="headerlink" title="Go语言中的init作用"></a>Go语言中的init作用</h2><p>在 Go 语言中，<code>init</code> 函数是一个特殊的函数，它主要用于在包被加载时自动执行初始化动作。<code>init</code> 函数有以下特性：</p><ol><li><strong>自动调用</strong>：<code>init</code> 函数没有返回值，也不需要显式调用。当一个 Go 包被导入时，该包中的所有顶级（非内嵌）<code>init</code> 函数（若有多个的话）会按照它们在源代码中出现的顺序依次执行。</li><li><strong>隐式执行</strong>：<code>init</code> 函数不能被其他函数调用，也无法被外部引用。</li><li><strong>用于初始化</strong>：通常在 <code>init</code> 函数中执行那些需要在程序运行初期完成的准备工作，例如初始化全局变量、连接数据库、设置日志系统、注册系统组件等。</li><li><strong>优先级</strong>：<code>init</code> 函数在 main 函数之前执行，如果一个包被导入，那么该包的 <code>init</code> 函数将在 main 包的 <code>init</code> 函数之前运行。</li></ol><p>举例说明：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;Initialized by init&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Executing init function in example package&quot;</span>)<br>    <span class="hljs-comment">// 可以在这里进行初始化操作</span><br>    <span class="hljs-comment">// 例如，设置全局变量、初始化连接、注册函数等</span><br>    globalVar = <span class="hljs-string">&quot;Updated during init&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当导入 <code>example</code> 包时，<code>init</code> 函数会被自动执行，并输出一条消息，同时更新全局变量 <code>globalVar</code> 的值。</p><p><code>setup</code> 函数和 <code>init</code> 函数在 Go 语言中都用于初始化，但它们之间有明显的区别：</p><ol><li><strong>init 函数</strong>：<ul><li>是 Go 语言内置的特殊函数，每个包都可以有多个 <code>init</code> 函数，它们没有返回值，也没有接收者。</li><li><code>init</code> 函数在包被导入时自动调用，并按照它们在源码中的定义顺序执行。</li><li><code>init</code> 函数主要用于包内部的一些必要初始化工作，例如初始化全局变量、设置日志系统、初始化数据库连接等。</li><li>用户不能直接调用 <code>init</code> 函数，由 Go 语言运行时自动执行。</li></ul></li><li><strong>setup 函数</strong>：<ul><li>是用户自定义的普通函数，通常用于整个应用程序或模块的一次性初始化工作。</li><li><code>setup</code> 函数可以有返回值和接收者，具体取决于其实现。</li><li>用户需要在合适的地方主动调用 <code>setup</code> 函数来完成初始化。</li><li>由于 <code>setup</code> 是自定义函数，它的功能和用途更为灵活多样，可以根据应用场景自行设计。</li></ul></li></ol><p>总结：</p><ul><li><code>init</code> 函数是 Go 语言规范的一部分，用于在包加载时进行初始化，执行时机不由用户控制。</li><li><code>setup</code> 函数是程序员自定义的初始化逻辑，执行时机和内容完全由开发者决定，通常用于较为复杂的初始化流程或跨包的全局初始化操作。</li></ul><h2 id="单双引号"><a href="#单双引号" class="headerlink" title="单双引号"></a>单双引号</h2><ul><li><strong>单引号 <code>&#39;</code></strong> 用于表示单个 <code>rune</code> 类型的字符，常用于处理单个Unicode码点，不支持转义字符。</li><li><strong>双引号 <code>&quot;</code></strong> 用于表示 <code>string</code> 类型的字符串，可以包含多个字符及转义序列，适合处理多字符文本和需要转义的场景。</li></ul><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>在Go语言中，&#96;&#96; 符号（通常被称为反引号或背引号）用于创建一个<strong>原生字符串字面量（raw string literal）</strong>。原生字符串字面量具有以下特点：</p><ol><li><strong>包围字符串</strong>：使用一对反引号（&#96;&#96;）来包围字符串内容，与双引号（””）或单引号（’’）包围的字符串不同。</li><li><strong>不支持转义字符</strong>：原生字符串内部的任何字符都不会被解析为转义序列。也就是说，即使你写了类似 <code>\n</code>、<code>\t</code> 或 <code>\&quot;</code> 这样的序列，它们也会被当作普通字符对待，不会转换成换行符、制表符或双引号。</li><li><strong>保留换行和空格</strong>：原生字符串中包含的所有换行符、制表符和空格都将原样保留。当你需要编写多行文本或者包含大量特殊空白字符的字符串时，原生字符串特别有用，因为无需使用转义序列来插入这些字符。</li><li><strong>包含特殊字符无障碍</strong>：由于不解析转义字符，原生字符串尤其适合包含需要原样输出的特殊字符、正则表达式模式、HTML代码、JSON或XML片段等，避免了因转义导致的混淆或错误。</li></ol><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 原生字符串字面量</span><br>sqlQuery := <span class="hljs-string">`</span><br><span class="hljs-string">    SELECT id, name, email</span><br><span class="hljs-string">    FROM users</span><br><span class="hljs-string">    WHERE active = true</span><br><span class="hljs-string">`</span><br><br>regexPattern := <span class="hljs-string">`^https?://[a-zA-Z0-9._-]+(\.[a-zA-Z]&#123;2,&#125;)+/`</span><br></code></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li><code>sqlQuery</code> 是一个多行SQL查询语句，原生字符串确保了换行符被正确地包含在字符串中，使得查询语句格式清晰且无需手动添加 <code>\n</code> 转义序列。</li><li><code>regexPattern</code> 是一个正则表达式，其中的斜线（<code>/</code>）和特殊字符无需转义，直接写入原生字符串即可。</li></ul><p>总之，在Go语言中，&#96;&#96; 符号用于创建原生字符串字面量，提供了一种方便的方式来编写包含复杂或特殊字符的字符串，且无需考虑转义问题。这对于需要保留原始文本格式或包含特殊字符的场景尤为有用。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1.匿名函数 "></a>1.匿名函数<code> </code></h3><ul><li><p>有时候我们想要完成某一特定功能，但该功能只在一个包中用到几次，我们可以不用将其封装为包级别的函数，而是使用匿名函数</p></li><li><p>匿名函数，就是可以省略函数名的函数</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123; <span class="hljs-comment">// 匿名函数不需要函数名</span><br><span class="hljs-keyword">return</span> i<br>&#125;(<span class="hljs-number">5</span>) <span class="hljs-comment">// 匿名函数通过后面的()向函数传参</span><br>fmt.Println(r) <span class="hljs-comment">// 输出5</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>go语言是一种强类型语言，我们知道了函数的类型，就可以将其作为参数传入另一个函数,我们称这种函数为回调函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br> <br><span class="hljs-keyword">type</span> FuncType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">//先用FuncType代表有两个int型参数和有一个int型返回值的函数，不用管该函数是否存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//加法</span><br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minus</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//减法</span><br><span class="hljs-keyword">return</span> a - b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiple</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//乘法</span><br><span class="hljs-keyword">return</span> a * b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//除法</span><br><span class="hljs-keyword">return</span> a / b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, fType FuncType)</span></span> (result <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//fType表示一个函数类型变量</span><br>result = fType(a, b)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>fmt.Print(<span class="hljs-string">&quot;请输入两个数：&quot;</span>)<br>fmt.Scan(&amp;x, &amp;y)<br>fmt.Println(<span class="hljs-string">&quot;这两个数之和为：&quot;</span>, Calculate(x, y, add))<br>fmt.Println(<span class="hljs-string">&quot;这两个数之差为：&quot;</span>, Calculate(x, y, minus))<br>fmt.Println(<span class="hljs-string">&quot;这两个数之积为：&quot;</span>, Calculate(x, y, multiple))<br>fmt.Println(<span class="hljs-string">&quot;这两个数之商为：&quot;</span>, Calculate(x, y, divide))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><p>在一个函数中返回值是另外一个函数，我们称之为闭包。</p><ul><li><p>闭包的理解：内部函数访问外部函数的变量</p></li><li><p>闭包的作用：改变临时变量的生命周期</p></li><li><p>闭包示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 考虑这样一种应用场景，公司其他部门的同事提供给你API,该API要求输入参数为一个func()类型(无参数无返回值)</span><br><span class="hljs-comment">// 现在你有一个func(i int)类型的函数，如何才能调用上述的API呢，这就需要用到闭包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f6</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span></span>)&#123;<br>fmt.Println(<span class="hljs-string">&quot;I am f6()&quot;</span>)<br>f()<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f7</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 可以看到，该匿名函数中并没有关于变量i的声明与定义，它引用了外部f7()的变量，延长了变量i的生命周期</span><br>fmt.Printf(<span class="hljs-string">&quot;I am f7(),i have a parameter:%v\n&quot;</span>,i)<br>&#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    f6(f7(<span class="hljs-number">9</span>)) <span class="hljs-comment">// 输出:I am f6() \n I am f7(),i have a parameter:9</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h3><ul><li><p>函数在处理过程中调用自身，称之为递归。</p></li><li><p>递归必须有结束条件，否则会陷入死循环。</p></li><li><p>使用递归前，最好把问题进行数学抽象</p></li><li><p>递归示例：斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 首先进行数学抽象，明确该函数返回值的意义</span><br><span class="hljs-comment">// 该函数返回值是斐波那契数列中第i个位置的值</span><br><span class="hljs-comment">// 根据斐波那契数列的数学规律，我们知道第i个位置的值等于其前两个位置值之和，即fibonacci(i-1)+fibonacci(i-2)</span><br><span class="hljs-comment">// 当处于第一或第二个位置时，由于其前面不足两个元素，因此要单独考虑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">2</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> fibonacci(i<span class="hljs-number">-1</span>)+fibonacci(i<span class="hljs-number">-2</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++&#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>,fibonacci(i)) <span class="hljs-comment">// 输出：1 1 2 3 5 8 13 21 34 55</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数（Function）：在包级别定义，不依赖于特定的接收者（receiver），可以在任何地方调用。</p></li><li><p>方法（Method）：与一个具体类型相关联，定义在类型内部，并有一个接收者（receiver）参数，通常用来扩展类型的行为。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 赋值</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>var createUser DevUser声明了一个未初始化的<code>DevUser</code>变量<code>createUser</code>，其内部所有字段的值均为各自类型的零值。</li><li>createUser :&#x3D; DevUser{}    使用了简短变量声明（short variable declaration）<code>:=</code>，同时完成了变量声明和初始化。这里<code>createUser</code>变量被赋予了一个<code>DevUser</code>类型的零值实例，即一个所有字段均为零值的新<code>DevUser</code>对象。<code>DevUser&#123;&#125;</code>是创建一个空结构体实例的写法，相当于调用了<code>DevUser</code>类型的零值构造函数。</li></ol><p><strong>总结</strong></p><ul><li><strong>情况一</strong>中，<code>createUser</code>变量未被初始化，其内部字段值为各自的零值。</li><li><strong>情况二</strong>中，<code>createUser</code>变量被初始化为一个所有字段均为零值的<code>DevUser</code>实例。</li></ul><h2 id="引用传递和值传递"><a href="#引用传递和值传递" class="headerlink" title="引用传递和值传递"></a>引用传递和值传递</h2><p><strong>值传递</strong></p><p>在 Go 中，当函数调用发生时，所有的参数都是按值传递的。这意味着函数接收到的是参数的值的副本，而不是原始值本身。对于基本数据类型（如 <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code> 等），这通常意味着创建一个完全独立的副本，对函数内的参数所做的任何修改都不会影响到外部的原始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 形参为 int类型的 x</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addOne</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> &#123;<br>    x++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">10</span><br>    <span class="hljs-comment">// 实参为 n</span><br>    addOne(n)<br>    fmt.Println(n) <span class="hljs-comment">// 输出 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用传递（实际上是一种共享引用）</strong></p><p>尽管 Go 没有真正的“引用传递”，但在处理复合类型（如切片、map、channel 和接口）时，情况有所不同。当传递这些类型时，实际上是传递了指向这些复合类型数据的引用。这意味着，虽然函数内部的操作是在局部变量上进行的，但由于这些局部变量持有原始数据的引用，所以对它们的修改会影响到外部的原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendItem</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>    slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">42</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    numbers := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    appendItem(numbers)<br>    fmt.Println(numbers) <span class="hljs-comment">// 输出 [1 2 3 42]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>指针的使用</strong></p><p>为了在函数间传递引用并允许直接修改原始数据，Go 支持指针类型。当你将一个指针传递给函数时，你实际上是传递了指向某个值的地址，这允许函数直接修改那个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">movePoint</span><span class="hljs-params">(p *Point)</span></span> &#123;<br>    p.X++<br>    p.Y++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pt := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    movePoint(&amp;pt)<br>    fmt.Println(pt) <span class="hljs-comment">// 输出 &#123;2 3&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化和没有初始化的区别主要体现在变量或对象的状态以及其在程序中的可用性方面。下面是详细的对比：</p><p><strong>未初始化：</strong></p><ol><li><strong>状态未知</strong>：当一个变量没有经过初始化时，它的值是不确定的。在很多编程语言中（如C、C++、Java、Go等），未初始化的变量会持有其类型的默认值（通常称为零值），如整型为0、浮点型为0.0、布尔型为false、字符串为””（空字符串）、指针为nil等。尽管这些默认值有一定的规律，但对于用户自定义类型（如结构体、类等）或特定情况下的内置类型，未初始化的值可能并不符合预期，甚至可能导致程序逻辑错误或运行时异常。</li><li><strong>不可靠使用</strong>：未初始化的变量值是不确定的，直接使用这样的变量会导致程序行为不可预测。例如，对未初始化的字符串进行拼接、对未初始化的数值进行计算，或者对未初始化的指针进行解引用等，都可能导致错误的结果或程序崩溃。</li><li><strong>资源管理问题</strong>：对于一些需要分配和管理资源（如内存、文件句柄、网络连接等）的变量（如动态分配的数组、打开的文件、创建的数据库连接等），未初始化可能导致资源泄露，因为没有明确的初始化过程来确保资源的合理分配和释放。</li><li><strong>编程规范与调试难度</strong>：未初始化的变量违反了良好的编程实践，使得代码难以阅读、理解和维护。未初始化的变量在调试时也更难追踪其状态变化，增加了定位问题的复杂度。</li></ol><p><strong>初始化：</strong></p><ol><li><strong>确定状态</strong>：初始化后的变量具有明确的初始值，这个值由程序员在声明变量时显式指定或通过构造函数、初始化器等机制赋予。初始化确保了变量在使用前已经有了一个预期的、有意义的值。</li><li><strong>可靠使用</strong>：初始化后的变量可以直接在程序中安全使用，因为它们的值是已知且符合预期的。这有助于保证程序逻辑的正确性和稳定性。</li><li><strong>资源有效管理</strong>：对于需要管理资源的变量，初始化过程通常会伴随着资源的正确分配和设置初始状态。这样可以避免资源泄露，确保程序资源的有效利用和正确清理。</li><li><strong>遵循编程规范与易于调试</strong>：初始化变量遵循了良好的编程习惯，使得代码更具可读性、可维护性。初始化的变量在调试时，其状态变化更为清晰，有助于快速识别和解决问题。</li></ol><p>总之，初始化与未初始化的主要区别在于变量是否具有明确、预期的初始值，以及由此带来的对程序行为的可预测性、资源管理的正确性、代码质量的提升以及调试难度的降低。在实际编程中，应始终确保变量在使用前得到适当的初始化。</p><h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><ul><li>range循环每个元素都会拷贝一份到变量中</li><li>修改变量内部值不影响原结构体</li><li>应使用索引直接操作原始结构体对应元素</li><li>这样才能实现更新原始数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, field := <span class="hljs-keyword">range</span> schemaMeta.Fields &#123;<br><span class="hljs-keyword">if</span> field.FieldPath == <span class="hljs-string">&quot;CSZ10&quot;</span> &#123;<br><span class="hljs-keyword">var</span> newTerms []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, term := <span class="hljs-keyword">range</span> field.GlossaryTerms.Terms &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;urn:li:glossaryTerm:网络身份标识&quot;</span> != term[<span class="hljs-string">&quot;urn&quot;</span>] &#123;<br>newTerms = <span class="hljs-built_in">append</span>(newTerms, term)<br>&#125;<br>&#125;<br>fmt.Println(newTerms)<br>schemaMeta.Fields[i].GlossaryTerms.Terms = newTerms<br><span class="hljs-comment">//field.GlossaryTerms.Terms = newTerms</span><br>fmt.Println(schemaMeta.Fields[i].GlossaryTerms.Terms)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strconv包转换类型"><a href="#strconv包转换类型" class="headerlink" title="strconv包转换类型"></a>strconv包转换类型</h2><p><strong>字符串转整数：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转整数</span><br>str := <span class="hljs-string">&quot;123&quot;</span><br>i, err := strconv.Atoi(str)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为整数：&quot;</span>, i)<br>&#125;<br><br><span class="hljs-comment">// 大整数转换</span><br>bigStr := <span class="hljs-string">&quot;12345678901234567890&quot;</span><br>bigInt, err := strconv.ParseInt(bigStr, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;大整数转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;大字符串转换为 int64 整数：&quot;</span>, bigInt)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>整数转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 整数转字符串</span><br>num := <span class="hljs-number">456</span><br>str := strconv.Itoa(num)<br>fmt.Println(<span class="hljs-string">&quot;整数转换为字符串：&quot;</span>, str)<br><br><span class="hljs-comment">// int64 转字符串</span><br>bigNum := <span class="hljs-type">int64</span>(<span class="hljs-number">12345678901234567890</span>)<br>bigStr := strconv.FormatInt(bigNum, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;int64 整数转换为字符串：&quot;</span>, bigStr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串转浮点数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转浮点数</span><br>floatStr := <span class="hljs-string">&quot;3.14&quot;</span><br>f, err := strconv.ParseFloat(floatStr, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为浮点数：&quot;</span>, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浮点数转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 浮点数转字符串</span><br>pi := <span class="hljs-number">3.141592653589793238</span><br>formatStr := strconv.FormatFloat(pi, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">64</span>) <span class="hljs-comment">// &#x27;f&#x27; 表示固定精度模式，-1 表示使用默认精度</span><br>fmt.Println(<span class="hljs-string">&quot;浮点数转换为字符串：&quot;</span>, formatStr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串转布尔值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转布尔值</span><br>boolStr := <span class="hljs-string">&quot;true&quot;</span><br>b, err := strconv.ParseBool(boolStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为布尔值：&quot;</span>, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>布尔值转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 布尔值转字符串</span><br>flag := <span class="hljs-literal">true</span><br>str := strconv.FormatBool(flag)<br>fmt.Println(<span class="hljs-string">&quot;布尔值转换为字符串：&quot;</span>, str)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reflect打印变量类型"><a href="#reflect打印变量类型" class="headerlink" title="reflect打印变量类型"></a>reflect打印变量类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 打印变量 a、b 和 c 的类型</span><br>fmt.Printf(<span class="hljs-string">&quot;a 的类型是: %s\n&quot;</span>, reflect.TypeOf(a).Name())<br>fmt.Printf(<span class="hljs-string">&quot;b 的类型是: %s\n&quot;</span>, reflect.TypeOf(b).Name())<br>fmt.Printf(<span class="hljs-string">&quot;c 的类型是: %s\n&quot;</span>, reflect.TypeOf(c).Name())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在Go语言中，断言（Assertion）主要用于类型转换和接口值类型的判断。主要有以下两种形式的断言：</p><ol><li><p><strong>类型断言</strong>： 类型断言应用于接口类型变量，用于检测接口值是否具有特定类型，并可选择地将其转换为该类型。基本语法如下：</p><p>Go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">value, ok := interfaceVariable.(typeName)<br></code></pre></td></tr></table></figure><p>其中，<code>interfaceVariable</code> 是一个接口类型的变量，<code>typeName</code> 是你希望它实际具有的类型。如果接口变量的动态类型确实与<code>typeName</code>一致，那么<code>value</code>将得到接口值对应的底层值，<code>ok</code>将被设为<code>true</code>；如果不匹配，<code>ok</code>将为<code>false</code>，且<code>value</code>的值将是相应类型的零值。</p><p>例如：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, world!&quot;</span><br>s, ok := i.(<span class="hljs-type">string</span>)<br><span class="hljs-comment">// s == &quot;Hello, world!&quot;, ok == true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>类型断言在接口间转换</strong>： 类型断言也可用于将一个接口类型转换为另一个接口类型，只要它们的底层类型能够满足转换要求。</p></li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>简单讲：反射就是在程序运行时，可以访问自身结构并且做出修改的一种能力（审视自身）。</p><p>在golang中，反射是通过<code>reflect</code>包来实现</p><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><p>要打印变量的类型，你可以使用<code>reflect.TypeOf()</code>函数结合<code>fmt.Println()</code>。<code>reflect.TypeOf()</code>会返回一个代表类型信息的<code>reflect.Type</code>对象，然后通过它的<code>String()</code>方法得到类型名字符串。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> myInt <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br><span class="hljs-keyword">var</span> myString <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span><br><br>fmt.Println(<span class="hljs-string">&quot;myInt的类型是:&quot;</span>, reflect.TypeOf(myInt).String())<br>fmt.Println(<span class="hljs-string">&quot;myString的类型是:&quot;</span>, reflect.TypeOf(myString).String())<br>    <span class="hljs-comment">//或者</span><br>    fmt.Printf(<span class="hljs-string">&quot;myInt的类型是:%T\n&quot;</span>, myInt)<span class="hljs-comment">// myInt的类型是：int</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><ol><li><p><strong>使用<code>+</code>操作符</strong>: 这是最直接的方式，但当拼接大量字符串时可能导致性能问题，因为它会产生许多临时字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">name := <span class="hljs-string">&quot;Alice&quot;</span><br>age := <span class="hljs-number">30</span><br>result := <span class="hljs-string">&quot;My name is &quot;</span> + name + <span class="hljs-string">&quot;, and I am &quot;</span> + strconv.Itoa(age) + <span class="hljs-string">&quot; years old.&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>fmt.Sprintf</code></strong>: 更灵活，适合格式化输出，性能优于连续的<code>+</code>操作符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result := fmt.Sprintf(<span class="hljs-string">&quot;My name is %s, and I am %d years old.&quot;</span>, name, age)<br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>strings.Builder</code></strong>: 对于大量字符串拼接操作，<code>strings.Builder</code>提供了更好的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> builder strings.Builder<br>builder.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br>builder.WriteString(name)<br>builder.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br>builder.WriteString(strconv.Itoa(age))<br>builder.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br>result := builder.String()<br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>bytes.Buffer</code></strong>: 类似于<code>strings.Builder</code>，但在处理字节层面，适用于二进制数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<br>buffer.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br>buffer.WriteString(name)<br>buffer.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br>buffer.WriteString(strconv.Itoa(age))<br>buffer.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br>result := buffer.String()<br></code></pre></td></tr></table></figure></li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul><li><code>%s</code>: 字符串（string）</li><li><code>%d</code>: 十进制整数（int）</li><li><code>%f</code>: 浮点数，默认保留小数点后6位</li><li><code>%e</code> 或 <code>%E</code>: 科学记数法表示的浮点数</li><li><code>%T</code>: 任何值的类型信息</li><li><code>%g</code> 或 <code>%G</code>: 简化的科学记数法或浮点数，自动根据值的大小选择</li><li><code>%x</code>: 十六进制表示的整数，小写字母</li><li><code>%X</code>: 十六进制表示的整数，大写字母</li><li><code>%o</code>: 八进制表示的整数</li><li><code>%p</code>: 指针地址，以十六进制表示并前缀<code>0x</code></li><li><code>%q</code>: 引号包围的字符串，任何特殊字符都会被转义</li><li><code>%v</code>: 默认格式，根据值的具体类型选择合适的格式化方式</li><li><code>%%</code>: 输出百分号自身（而非作为占位符）</li><li><code>%[width]</code>: 指定输出的最小宽度，不足则左补空格</li><li><code>%-[width]</code>: 左对齐（默认是右对齐）</li><li><code>%.[precision]f</code>: 对浮点数指定小数点后的位数</li><li><code>%[flags][width][.precision]specifier</code>: 组合使用，如<code>%05d</code>表示至少5位宽，不足前导零填充的十进制整数。</li></ul><h2 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h2><p><strong>进程（process）</strong></p><ul><li>进程是资源分配的最小单位</li><li>进程间不共享内存，每个进程拥有自己独立的内存</li><li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li><li>新开进程开销大，并且 CPU 切换进程成本也大</li><li>进程由操作系统调度</li><li>多进程方式比多线程更加稳定</li></ul><p><strong>线程（thread）</strong></p><ul><li>线程是程序执行流的最小单位</li><li>线程是来自于进程的，一个进程下面可以开多个线程</li><li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li><li>线程因为是在同一个进程内的，可以共享内存</li><li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li><li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li><li>某个线程发生致命错误会导致整个进程崩溃</li><li>线程间读写变量存在锁的问题处理起来相对麻烦</li></ul><p><strong>协程（coroutine）</strong></p><ul><li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li><li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li><li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li><li>协程比线程更轻量级</li></ul><h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>通道（channel）是一种用于在goroutine之间传递数据的安全方式，支持同步通信。通道可以被声明为有缓冲或无缓冲的，具体写法和使用方式如下：</p><h3 id="通道的声明与初始化"><a href="#通道的声明与初始化" class="headerlink" title="通道的声明与初始化"></a>通道的声明与初始化</h3><p><strong>1. 无缓冲通道</strong>：数据的发送和接收操作必须同时发生，即发送者会阻塞，直到有接收者准备好接收数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 无缓冲通道，类型为int</span><br></code></pre></td></tr></table></figure><p><strong>2. 有缓冲通道</strong>：可以在没有接收者立即接收的情况下发送一定数量的数据，缓冲区满后，再发送数据将会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 有缓冲通道，类型为int，缓冲区大小为5</span><br></code></pre></td></tr></table></figure><h3 id="发送数据到通道"><a href="#发送数据到通道" class="headerlink" title="发送数据到通道"></a>发送数据到通道</h3><ul><li><p><strong>基础发送</strong>：使用<code>&lt;-&quot;channel&quot;</code>语法发送数据到通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- value <span class="hljs-comment">// 将value发送到通道ch</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="从通道接收数据"><a href="#从通道接收数据" class="headerlink" title="从通道接收数据"></a>从通道接收数据</h3><ul><li><p><strong>基础接收</strong>：使用<code>value := &lt;-channel</code>语法从通道接收数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">receivedValue := &lt;-ch <span class="hljs-comment">// 从通道ch接收数据并存储在receivedValue中</span><br></code></pre></td></tr></table></figure></li></ul><p>​ 多goroutines读取通道数据，取决于Go 的调度器分配，可能会出现第一个写入的数据可能被第一个读取的 goroutine读取，第二个数据可能被第二个读取的 goroutine读取</p><p>​      当从一个通道进行接收操作时如果通道中没有数据可接收且通道未被关闭，该接收操作将会阻塞。这种阻塞本身并不会抛出异常或错误，而是会使当前的 goroutine 暂停执行，直到通道中有数据可用或通道被关闭。</p><p><strong>阻塞问题：</strong></p><ol><li><p><strong>死锁</strong>：</p><p>如果程序的逻辑设计不当，可能导致多个 goroutine 互相等待对方释放资源或发送&#x2F;接收数据，从而形成死锁。在这种情况下，程序将停止响应，因为没有任何 goroutine 能够继续执行。</p></li><li><p><strong>性能问题:</strong></p><p>过度的阻塞可能会导致性能下降，尤其是在高并发的系统中。如果大量 goroutines 因为等待通道数据而阻塞，可能会影响系统的响应时间和吞吐量。</p></li><li><p><strong>资源浪费</strong>：</p><p>长时间的阻塞也可能导致 CPU 时间片和其他系统资源的浪费，因为被阻塞的 goroutine 占用了调度器的注意力，而实际上它无法执行任何工作。</p></li><li><p><strong>逻辑错误</strong>：</p><p><strong>逻辑错误</strong>： 如果预期一个通道应该有数据可接收，但实际上没有，这可能是程序逻辑上的错误。例如，可能有 goroutine 应该向通道发送数据，但由于某种原因未能执行。</p></li></ol><p>为了避免这些问题，通常可以采用以下策略：</p><ul><li><strong>使用 select 语句</strong>：结合 default case 使用 select 语句可以防止无限期的阻塞，使 goroutine 在没有数据可接收时能够继续执行其他操作。</li><li><strong>关闭通道</strong>：当不再需要向通道发送数据时，应该关闭通道。这可以通知所有等待接收数据的 goroutines，让它们知道没有更多数据可接收，从而避免无限期的阻塞。</li><li><strong>超时机制</strong>：通过使用定时器或上下文（context）来限制等待时间，可以防止长时间的阻塞。</li></ul><h3 id="多路复用与默认选择"><a href="#多路复用与默认选择" class="headerlink" title="多路复用与默认选择"></a>多路复用与默认选择</h3><ul><li><p><strong>多路复用</strong>：在<code>select</code>语句中，可以监听多个通道上的发送或接收操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch1 &lt;- value:<br>    <span class="hljs-comment">// 发送到ch1成功</span><br><span class="hljs-keyword">case</span> ch2 &lt;- value:<br>    <span class="hljs-comment">// 发送到ch2成功</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>带default的select</strong>：用于非阻塞接收或发送，或者执行默认操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> value := &lt;-ch:<br>    <span class="hljs-comment">// 从ch接收数据</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 没有数据可接收时执行</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h3><ul><li><p><strong>关闭通道</strong>：使用<code>close(channel)</code>可以关闭一个通道，表明不再会有数据发送到该通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 关闭通道ch</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>唯一关闭原则：应该只有一个goroutine负责关闭管道。重复关闭管道会导致运行时panic（<code>panic: close of closed channel</code>）。</li><li>接收者可以通过<code>v, ok := &lt;-ch</code>来检查通道是否已经关闭（<code>ok</code>为<code>false</code>表示通道已关闭且没有更多数据可接收）。</li><li>向一个已关闭的通道发送数据会导致运行时panic，尝试从一个已关闭的无缓冲通道接收数据（如果没有其他发送者等待）也会导致接收操作立即返回零值和<code>false</code>的<code>ok</code>。</li></ul><h2 id="Switch-Select-区别"><a href="#Switch-Select-区别" class="headerlink" title="Switch\Select 区别"></a>Switch\Select 区别</h2><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><ul><li><strong>用途</strong>：主要用于基于不同条件（通常是变量的值）执行不同的代码路径。它可以处理多种情况，并且可以有一个可选的默认分支（<code>default</code> case）。</li><li><strong>适用场景</strong>：当你需要根据某个表达式的值来做决策时，比如处理枚举类型、错误码等。</li><li><strong>控制流</strong>：顺序执行，从上到下匹配<code>case</code>，一旦匹配成功执行相应代码块后（除非有<code>break</code>），会继续检查下一个<code>case</code>，直到遇到<code>break</code>或者执行完所有匹配的<code>case</code>（如果没有<code>break</code>）。</li><li><strong>特点</strong>：不涉及并发，纯粹用于逻辑控制。</li></ul><h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><ul><li><p><strong>用途</strong>：专门用于处理channel的操作，如接收或发送数据。它是Go语言并发模型中的一个重要组件，用于实现非阻塞的IO多路复用。</p></li><li><p><strong>适用场景</strong>：当你需要同时监听多个channel上的事件并作出响应时，比如在处理网络连接、信号量或是其他并发任务的协调时。</p></li><li><p><strong>控制流</strong>：非确定性选择，当有多个channel操作准备就绪时，会选择一个随机的（实际上是由运行时决定的）channel执行。如果没有channel准备好，select会阻塞，直到至少有一个channel可操作。</p></li><li><p>特点</p><p>：</p><ul><li>可以有default子句，用于在没有任何channel操作准备就绪时执行。</li><li>如果有多个channel同时就绪，select会随机选择一个执行，这对于需要公平性的情况需要注意。</li><li>可以用来实现超时机制，通过配合time.After函数的channel。</li></ul></li></ul><p>总结来说，<code>switch</code>是用于控制流程的决策，基于表达式的值；而<code>select</code>则专注于并发编程中的通信，特别是与channel相关的操作，提供了在多个并发活动之间进行选择的能力。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go语言中的<code>strings</code>包提供了许多用于操作字符串的实用函数。以下是一些最常用的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go">**<span class="hljs-string">`Contains(s, substr string) bool`</span>**<br>- 检查字符串<span class="hljs-string">`s`</span>是否包含子字符串<span class="hljs-string">`substr`</span>。如果包含，返回<span class="hljs-string">`true`</span>；否则返回<span class="hljs-string">`false`</span>。<br><br>**<span class="hljs-string">`Count(s, sep string) int`</span>**<br>- 计算字符串<span class="hljs-string">`s`</span>中非重叠的<span class="hljs-string">`sep`</span>出现次数。如果<span class="hljs-string">`sep`</span>为空，则返回<span class="hljs-string">`s`</span>中字符（非字节）的数量加一。<br><br>**<span class="hljs-string">`EqualFold(s, t string) bool`</span>**<br>- 比较<span class="hljs-string">`s`</span>和<span class="hljs-string">`t`</span>是否相等，忽略大小写。<br><br>**<span class="hljs-string">`Fields(s string) []string`</span>**<br>- 根据空白字符分割字符串<span class="hljs-string">`s`</span>，返回一个由字段组成的切片。<br><br>**<span class="hljs-string">`FieldsFunc(s string, f func(rune) bool) []string`</span>**<br>- 使用函数<span class="hljs-string">`f`</span>作为分隔符来分割<span class="hljs-string">`s`</span>，其中<span class="hljs-string">`f`</span>应该返回<span class="hljs-string">`true`</span>以指示分隔符。<br><br>**<span class="hljs-string">`Index(s, sep string) int`</span>**<br>- 返回<span class="hljs-string">`s`</span>中<span class="hljs-string">`sep`</span>第一次出现的索引，如果未找到则返回<span class="hljs-string">`-1`</span>。<br><br>**<span class="hljs-string">`Join(a []string, sep string) string`</span>**<br>- 使用<span class="hljs-string">`sep`</span>连接切片<span class="hljs-string">`a`</span>中的字符串元素。<br><br>**<span class="hljs-string">`LastIndex(s, sep string) int`</span>**<br>- 返回<span class="hljs-string">`s`</span>中最后一次<span class="hljs-string">`sep`</span>出现的索引，如果未找到则返回<span class="hljs-string">`-1`</span>。<br><br>**<span class="hljs-string">`Map(f func(rune) rune, s string) string`</span>**<br>- 将函数<span class="hljs-string">`f`</span>应用于<span class="hljs-string">`s`</span>中的每个字符，然后返回结果字符串。<br><br>**<span class="hljs-string">`Repeat(s string, count int) string`</span>**<br>- 返回<span class="hljs-string">`s`</span>重复<span class="hljs-string">`count`</span>次的结果。<br><br>**<span class="hljs-string">`Replace(s, old, new string, n int) string`</span>**<br>- 将<span class="hljs-string">`s`</span>中的前<span class="hljs-string">`n`</span>个<span class="hljs-string">`old`</span>替换为<span class="hljs-string">`new`</span>。如果<span class="hljs-string">`n`</span>小于<span class="hljs-number">0</span>，则替换所有出现。<br><br>**<span class="hljs-string">`Split(s, sep string) []string`</span>**<br>- 根据<span class="hljs-string">`sep`</span>分割<span class="hljs-string">`s`</span>，返回一个由子字符串组成的切片。<br><br>**<span class="hljs-string">`SplitAfter(s, sep string) []string`</span>**<br>- 类似于<span class="hljs-string">`Split`</span>，但在每个分割点之后保留<span class="hljs-string">`sep`</span>。<br><br>**<span class="hljs-string">`SplitN(s, sep string, n int) []string`</span>**<br>- 类似于<span class="hljs-string">`Split`</span>，但最多分割<span class="hljs-string">`n-1`</span>次，从而得到<span class="hljs-string">`n`</span>个元素。<br><br>**<span class="hljs-string">`Title(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为标题大小写，即每个单词的第一个字母大写，其余小写。<br><br>**<span class="hljs-string">`ToLower(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为小写。<br><br>**<span class="hljs-string">`ToUpper(s string) string`</span>**<br>- 将<span class="hljs-string">`s`</span>转换为大写。<br><br>**<span class="hljs-string">`Trim(s string, cutset string) string`</span>**<br>- 移除<span class="hljs-string">`s`</span>前后两端的<span class="hljs-string">`cutset`</span>字符。<br><br>**<span class="hljs-string">`TrimSpace(s string) string`</span>**<br>- 移除<span class="hljs-string">`s`</span>前后两端的空白字符。<br><br>**<span class="hljs-string">`HasPrefix(s, prefix string) bool`</span>**<br>- 检查<span class="hljs-string">`s`</span>是否以<span class="hljs-string">`prefix`</span>开始。<br><br>**<span class="hljs-string">`HasSuffix(s, suffix string) bool`</span>**<br>   - 检查<span class="hljs-string">`s`</span>是否以<span class="hljs-string">`suffix`</span>结束。<br></code></pre></td></tr></table></figure><p>这些函数提供了强大的字符串处理能力，可以满足大多数字符串操作的需求</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>版本更新特性</title>
    <link href="/2024/12/10/go/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/12/10/go/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="版本更新特性"><a href="#版本更新特性" class="headerlink" title="版本更新特性"></a>版本更新特性</h1><h2 id="Golang-1-22-对-for-循环作了两处更新"><a href="#Golang-1-22-对-for-循环作了两处更新" class="headerlink" title="Golang 1.22 对 for 循环作了两处更新"></a>Golang 1.22 对 for 循环作了两处更新</h2><ul><li><p>不再共享循环变量</p><p>Go 1.22 之前，<code>for</code> 循环声明的变量仅会创建一次，而在每次迭代时对变量值进行更新。Go 1.22 改为每次迭代时都创建新的变量。</p></li><li><p>支持对整数进行 <code>range</code> 遍历</p><p>Go 1.22 支持在 <code>for</code> 循环中对整数进行 <code>range</code> 遍历了。</p></li></ul><h3 id="1-不再共享循环变量"><a href="#1-不再共享循环变量" class="headerlink" title="1 不再共享循环变量"></a>1 不再共享循环变量</h3><p><strong>Go 1.22 之前的情况</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// for_1_21.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-comment">// for each iteration, start a goroutine to print i</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i)<br>&#125;()<br>&#125;<br><br><span class="hljs-comment">// waiting for 3 seconds</span><br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出结果 2 2 2</span><br></code></pre></td></tr></table></figure><p>这是为什么呢？这是因为 <code>for</code> 循环的 <code>i</code> 变量只在初始化块内声明了一次，而在每次迭代时对其重新赋值。这样，启动虽有顺序但执行却是异步的 <code>3</code> 个子 <code>goroutine</code> 访问的其实是同一个内存地址，所以打印的值有可能会相同。</p><p>老版本解决方案：可以通过给闭包函数增加一个参数或者新声明一个变量来解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// for_modified_1_21.go</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>  <span class="hljs-comment">// for each iteration, start a goroutine to print i</span><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(i)<br>  &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-支持对整数进行range遍历"><a href="#2-支持对整数进行range遍历" class="headerlink" title="2 支持对整数进行range遍历"></a>2 支持对整数进行range遍历</h3><p>在 Go 1.22 版本之前， <code>for</code> 仅支持对 <code>array</code>（或 <code>slice</code>）、<code>string</code>、<code>map</code> 和 <code>channel</code> 类型进行 <code>range</code> 遍历，而 Go 1.22 支持了对整数的 <code>range</code> 遍历，这样对于打印一个连续数值序列的写法就变得简单多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// for_range_int_1_22.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> <span class="hljs-number">3</span> &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用三方库</title>
    <link href="/2024/12/10/go/%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <url>/2024/12/10/go/%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常用三方库"><a href="#常用三方库" class="headerlink" title="常用三方库"></a>常用三方库</h1><h2 id="gjson"><a href="#gjson" class="headerlink" title="gjson"></a>gjson</h2><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/tidwall/gjson<br></code></pre></td></tr></table></figure><p>后使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/tidwall/gjson&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  json := <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br>  lastName := gjson.Get(json, <span class="hljs-string">&quot;name.last&quot;</span>)<br>  fmt.Println(<span class="hljs-string">&quot;last name:&quot;</span>, lastName.String())<br><br>  age := gjson.Get(json, <span class="hljs-string">&quot;age&quot;</span>)<br>  fmt.Println(<span class="hljs-string">&quot;age:&quot;</span>, age.Int())<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用很简单，只需要传入 JSON 串和要读取的键路径即可。注意一点细节，因为<code>gjson.Get()</code>函数实际上返回的是<code>gjson.Result</code>类型，我们要调用其相应的方法进行转换对应的类型。如上面的<code>String()</code>和<code>Int()</code>方法。</p><p>如果是直接打印输出，其实可以省略<code>String()</code>，<code>fmt</code>包的大部分函数都可以对实现<code>fmt.Stringer</code>接口的类型调用<code>String()</code>方法。</p><h3 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h3><p>键路径实际上是以<code>.</code>分隔的一系列键。<code>gjson</code>支持在键中包含通配符<code>*</code>和<code>?</code>，<code>*</code>匹配任意多个字符，<code>?</code>匹配单个字符，例如<code>ca*</code>可以匹配<code>cat/cate/cake</code>等以<code>ca</code>开头的键，<code>ca?</code>只能匹配<code>cat/cap</code>等以<code>ca</code>开头且后面只有一个字符的键。</p><p>数组使用<strong>键名 + <code>.</code> + 索引</strong>（索引从 0 开始）的方式读取元素，如果键<code>pets</code>对应的值是一个数组，那么<code>pets.0</code>读取数组的第一个元素，<code>pets.1</code>读取第二个元素。</p><p>数组长度使用<strong>键名 + <code>.</code> + <code>#</code></strong> 获取，例如<code>pets.#</code>返回数组<code>pets</code>的长度。</p><p>如果键名中出现<code>.</code>，那么需要使用<code>\</code>进行转义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&#123;&quot;first&quot;:&quot;Tom&quot;, &quot;last&quot;: &quot;Anderson&quot;&#125;,</span><br><span class="hljs-string">  &quot;age&quot;: 37,</span><br><span class="hljs-string">  &quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;],</span><br><span class="hljs-string">  &quot;fav.movie&quot;: &quot;Dear Hunter&quot;,</span><br><span class="hljs-string">  &quot;friends&quot;: [</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Dale&quot;, &quot;last&quot;:&quot;Murphy&quot;, &quot;age&quot;: 44, &quot;nets&quot;: [&quot;ig&quot;, &quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68, &quot;nets&quot;: [&quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Jane&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 47, &quot;nets&quot;: [&quot;ig&quot;, &quot;tw&quot;]&#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;last name:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;name.last&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;age:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;age&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;children:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;children count:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children.#&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;second child:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children.1&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;third child*:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;child*.2&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;first c?ild:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;c?ildren.0&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;fav.moive&quot;</span>, gjson.Get(json, <span class="hljs-string">`fav.\moive`</span>))<br>  fmt.Println(<span class="hljs-string">&quot;first name of friends:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;friends.#.first&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;last name of second friend:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;friends.1.last&quot;</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>前 3 个比较简单，就不赘述了。看后面几个：</p><ul><li><code>children.#</code>：返回数组<code>children</code>的长度；</li><li><code>children.1</code>：读取数组<code>children</code>的第 2 个元素（注意索引从 0 开始）；</li><li><code>child*.2</code>：首先<code>child*</code>匹配<code>children</code>，<code>.2</code>读取第 3 个元素；</li><li><code>c?ildren.0</code>：<code>c?ildren</code>匹配到<code>children</code>，<code>.0</code>读取第一个元素；</li><li><code>fav.\moive</code>：因为键名中含有<code>.</code>，故需要<code>\</code>转义；</li><li><code>friends.#.first</code>：如果数组后<code>#</code>后还有内容，则以后面的路径读取数组中的每个元素，返回一个新的数组。所以该查询返回的数组所有<code>friends</code>的<code>first</code>字段组成；</li><li><code>friends.1.last</code>：读取<code>friends</code>第 2 个元素的<code>last</code>字段。</li></ul><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">last name: Anderson<br>age: <span class="hljs-number">37</span><br>children: [<span class="hljs-string">&quot;Sara&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>]<br>children count: <span class="hljs-number">3</span><br>second child: Alex<br>third child*: Jack<br>first c?ild: Sara<br>fave.moive <br>first name of friends: [<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Roger&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>]<br>last name of second friend: Craig<br></code></pre></td></tr></table></figure><p>对于数组，<code>gjson</code>还支持按条件查询元素，<code>#(条件)</code>返回第一个满足条件的元素，<code>#(条件)#</code>返回所有满足条件的元素。括号内的条件可以有<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>，还有简单的模式匹配<code>%</code>（符合某个模式），<code>!%</code>（不符合某个模式）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(last=&quot;Murphy&quot;).first`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(last=&quot;Murphy&quot;)#.first`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends.#(age&gt;45)#.last&quot;</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(first%&quot;D*&quot;).last`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(first!%&quot;D*&quot;).last`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(nets.#(==&quot;fb&quot;))#.first`</span>))<br><br></code></pre></td></tr></table></figure><p>还是使用上面的 JSON 串。</p><ul><li><code>friends.#(last=&quot;Murphy&quot;).first</code>：<code>friends.#(last=&quot;Murphy&quot;)</code>返回数组<code>friends</code>中第一个<code>last</code>为<code>Murphy</code>的元素，<code>.first</code>表示取出该元素的<code>first</code>字段返回；</li><li><code>friends.#(last=&quot;Murphy&quot;)#.first</code>：<code>friends.#(last=&quot;Murphy&quot;)#</code>返回数组<code>friends</code>中所有的<code>last</code>为<code>Murphy</code>的元素，然后读取它们的<code>first</code>字段放在一个数组中返回。注意与上面一个的区别；</li><li><code>friends.#(age&gt;45)#.last</code>：<code>friends.#(age&gt;45)#</code>返回数组<code>friends</code>中所有年龄大于 45 的元素，然后读取它们的<code>last</code>字段返回；</li><li><code>friends.#(first%&quot;D*&quot;).last</code>：<code>friends.#(first%&quot;D*&quot;)</code>返回数组<code>friends</code>中第一个<code>first</code>字段满足模式<code>D*</code>的元素，取出其<code>last</code>字段返回；</li><li><code>friends.#(first!%&quot;D*&quot;).last</code>：&#96;&#96;friends.#(first!%”D_”)<code>返回数组</code>friends<code>中第一个</code>first<code>字段**不**满足模式</code>D_<code>的元素，读取其</code>last&#96;字段返回；</li><li><code>friends.#(nets.#(==&quot;fb&quot;))#.first</code>：这是个嵌套条件，<code>friends.#(nets.#(==&quot;fb&quot;))#</code>返回数组<code>friends</code>的元素的<code>nets</code>字段中有<code>fb</code>的所有元素，然后取出<code>first</code>字段返回。</li></ul><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">Dale<br>[<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>]<br>[<span class="hljs-string">&quot;Craig&quot;</span>,<span class="hljs-string">&quot;Murphy&quot;</span>]<br>Murphy<br>Craig<br>[<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Roger&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>修饰符</strong>是<code>gjson</code>提供的非常强大的功能，和键路径搭配使用。<code>gjson</code>提供了一些内置的修饰符：</p><ul><li><code>@reverse</code>：翻转一个数组；</li><li><code>@ugly</code>：移除 JSON 中的所有空白符；</li><li><code>@pretty</code>：使 JSON 更易用阅读；</li><li><code>@this</code>：返回当前的元素，可以用来返回根元素；</li><li><code>@valid</code>：校验 JSON 的合法性；</li><li><code>@flatten</code>：数组平坦化，即将<code>[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;]]</code>转为<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>；</li><li><code>@join</code>：将多个对象合并到一个对象中。</li></ul><p>修饰符的语法和管道类似，以<code>|</code>分隔键路径和分隔符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&#123;&quot;first&quot;:&quot;Tom&quot;, &quot;last&quot;: &quot;Anderson&quot;&#125;,</span><br><span class="hljs-string">  &quot;age&quot;: 37,</span><br><span class="hljs-string">  &quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;],</span><br><span class="hljs-string">  &quot;fav.movie&quot;: &quot;Dear Hunter&quot;,</span><br><span class="hljs-string">  &quot;friends&quot;: [</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Dale&quot;, &quot;last&quot;:&quot;Murphy&quot;, &quot;age&quot;: 44, &quot;nets&quot;: [&quot;ig&quot;, &quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68, &quot;nets&quot;: [&quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Jane&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 47, &quot;nets&quot;: [&quot;ig&quot;, &quot;tw&quot;]&#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@reverse&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@reverse|0&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends|@ugly&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends|@pretty&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;@this&quot;</span>))<br><br>  nestedJSON := <span class="hljs-string">`&#123;&quot;nested&quot;: [&quot;one&quot;, &quot;two&quot;, [&quot;three&quot;, &quot;four&quot;]]&#125;`</span><br>  fmt.Println(gjson.Get(nestedJSON, <span class="hljs-string">&quot;nested|@flatten&quot;</span>))<br><br>  userJSON := <span class="hljs-string">`&#123;&quot;info&quot;:[&#123;&quot;name&quot;:&quot;dj&quot;, &quot;age&quot;:18&#125;,&#123;&quot;phone&quot;:&quot;123456789&quot;,&quot;email&quot;:&quot;dj@example.com&quot;&#125;]&#125;`</span><br>  fmt.Println(gjson.Get(userJSON, <span class="hljs-string">&quot;info|@join&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>children|@reverse</code>先读取数组<code>children</code>，然后使用修饰符<code>@reverse</code>翻转之后返回，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-string">&quot;Alex&quot;</span>,<span class="hljs-string">&quot;Sara&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>children|@reverse|0</code>在上面翻转的基础上读取第一个元素，即原数组的最后一个元素，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Jack<br></code></pre></td></tr></table></figure><p><code>friends|@ugly</code>移除<code>friends</code>数组中的所有空白字符，返回一行长长的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Murphy&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">44</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;ig&quot;</span>,<span class="hljs-string">&quot;fb&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Roger&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Craig&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">68</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;fb&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Murphy&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">47</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;ig&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;]<br></code></pre></td></tr></table></figure><p><code>friends|@pretty</code>格式化<code>friends</code>数组，使之更易读：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dale&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Murphy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">44</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ig&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;fb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Roger&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Craig&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">68</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;fb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Murphy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">47</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ig&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><br></code></pre></td></tr></table></figure><p><code>@this</code>返回原始的 JSON 串。</p><p><code>@flatten</code>将数组<code>nested</code>的内层数组平坦到外层后返回，即将所有内层数组的元素依次添加到外层数组后面并移除内层数组，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>@join</code>将一个数组中的各个对象合并到一个中，例子中将数组中存放的部分个人信息合并成一个对象返回：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;dj&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<span class="hljs-string">&quot;phone&quot;</span>:<span class="hljs-string">&quot;123456789&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;dj@example.com&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰符参数"><a href="#修饰符参数" class="headerlink" title="修饰符参数"></a>修饰符参数</h3><p>修饰符还可以有参数，通过在修饰符后加<code>:</code>后跟参数。如果我们在格式化 JSON 串时，想要对键进行排序，那么可以使用<code>@pretty</code>修饰符的<code>sortKeys</code>参数。我们还是拿上面的 JSON 数据举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span><br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends|@pretty:&#123;&quot;sortKeys&quot;:true&#125;`</span>))<br></code></pre></td></tr></table></figure><p>最终按键名顺序输出 JSON 串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">[<br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">44</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Dale&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Murphy&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;ig&quot;</span>, <span class="hljs-string">&quot;fb&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">68</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Roger&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Craig&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;fb&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">47</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Jane&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Murphy&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;ig&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>当然还可以指定每行缩进<code>indent</code>（默认两个空格），每行开头字符串<code>prefix</code>（默认为空串）和一行最多显示字符数<code>width</code>（默认 80 字符）。下面在每行前增加两个空格：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span><br><br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends|@pretty:&#123;&quot;sortKeys&quot;:true,&quot;prefix&quot;:&quot;  &quot;&#125;`</span>))<br></code></pre></td></tr></table></figure><h3 id="自定义修饰符"><a href="#自定义修饰符" class="headerlink" title="自定义修饰符"></a>自定义修饰符</h3><p>如此强大的功当然要支持自定义！<code>gjson</code>使用<code>AddModifier()</code>添加一个修饰符，传入一个名字和类型为<code>func(json arg string) string</code>的处理函数。处理函数接受待处理的 JSON 值和修饰符参数，返回处理后的结果。下面编写一个转换大小写的修饰符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  gjson.AddModifier(<span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(json, arg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> arg == <span class="hljs-string">&quot;upper&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> strings.ToUpper(json)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> arg == <span class="hljs-string">&quot;lower&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> strings.ToLower(json)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> json<br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;]&#125;`</span><br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@case:upper&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@case:lower&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;SARA&quot;</span>, <span class="hljs-string">&quot;ALEX&quot;</span>, <span class="hljs-string">&quot;JACK&quot;</span>]<br>[<span class="hljs-string">&quot;sara&quot;</span>, <span class="hljs-string">&quot;alex&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="JSON-行"><a href="#JSON-行" class="headerlink" title="JSON 行"></a>JSON 行</h3><p><code>gjson</code>提供<code>..</code>语法可以将多行数据看成一个数组，每行数据是一个元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Gilbert&quot;, &quot;age&quot;: 61&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Alexa&quot;, &quot;age&quot;: 34&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;May&quot;, &quot;age&quot;: 57&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Deloise&quot;, &quot;age&quot;: 44&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..#&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..1&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..#.name&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">`..#(name=&quot;May&quot;).age`</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>..#</code>：返回有多少行 JSON 数据；</li><li><code>..1</code>：返回第一行，即<code>&#123;&quot;name&quot;: &quot;Gilbert&quot;, &quot;age&quot;: 61&#125;</code>；</li><li><code>..#.name</code>：<code>#</code>后再接路径，表示对数组中每个元素读取后面的路径，将读取到的值组成一个新数组返回；<code>..#.name</code>表示读取每一行中的<code>name</code>字段，最终返回<code>[&quot;Gilbert&quot;,&quot;Alexa&quot;,&quot;May&quot;,&quot;Deloise&quot;]</code>；</li><li><code>..#(name=&quot;May&quot;).age</code>：括号中的内容<code>(name=&quot;May&quot;)</code>表示条件，所以该条含义为取<code>name</code>为<code>&quot;May&quot;</code>的行中的<code>age</code>字段。</li></ul><p><code>gjson</code>还提供了遍历 JSON 行的方法：<code>gjson.ForEachLine()</code>，参数为 JSON 串和类型为<code>func(line gjson.Result) bool</code>的回调函数。回调返回<code>false</code>时遍历停止。下面代码读取输出每一行的<code>name</code>字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">gjson.ForEachLine(json, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(line gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;name:&quot;</span>, gjson.Get(line.String(), <span class="hljs-string">&quot;name&quot;</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>上面我们介绍了遍历 JSON 行的方式，实际上<code>gjson</code>还提供了通用的遍历数组和对象的方式。<code>gjson.Get()</code>方法返回一个<code>gjson.Result</code>类型的对象，<code>json.Result</code>提供了<code>ForEach()</code>方法用于遍历。该方法接受一个类型为<code>func (key, value gjson.Result) bool</code>的回调函数。遍历对象时<code>key</code>和<code>value</code>分别为对象的键和值；遍历数组时，<code>value</code>为数组元素，<code>key</code>为空（<strong>不是索引</strong>）。回调返回<code>false</code>时，遍历停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&quot;dj&quot;,</span><br><span class="hljs-string">  &quot;age&quot;:18,</span><br><span class="hljs-string">  &quot;pets&quot;: [&quot;cat&quot;, &quot;dog&quot;],</span><br><span class="hljs-string">  &quot;contact&quot;: &#123;</span><br><span class="hljs-string">    &quot;phone&quot;: &quot;123456789&quot;,</span><br><span class="hljs-string">    &quot;email&quot;: &quot;dj@example.com&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  pets := gjson.Get(json, <span class="hljs-string">&quot;pets&quot;</span>)<br>  pets.ForEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_, pet gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>    fmt.Println(pet)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;)<br><br>  contact := gjson.Get(json, <span class="hljs-string">&quot;contact&quot;</span>)<br>  contact.ForEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>    fmt.Println(key, value)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="校验-JSON"><a href="#校验-JSON" class="headerlink" title="校验 JSON"></a>校验 JSON</h3><p>调用<code>gjson.Get()</code>时，<code>gjson</code>假设我们传入的 JSON 串是合法的。如果 JSON 非法也不会<code>panic</code>，这时会返回不确定的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;name&quot;:dj,age:18&#125;`</span><br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面 JSON 串是非法的，<code>dj</code>和<code>age</code>都没有加上双引号（实际上习惯了 Go 语言<code>map</code>的写法，很容易把 JSON 写成这样😭）。上面代码输出<strong>18</strong>，显然是错误的。我们可以使用<code>gjson.Valid()</code>检测 JSON 串是否合法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> !gjson.Valid(json) &#123;<br>  fmt.Println(<span class="hljs-string">&quot;error&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次获取多个值"><a href="#一次获取多个值" class="headerlink" title="一次获取多个值"></a>一次获取多个值</h3><p>调用<code>gjson.Get()</code>一次只能读取一个值，多次调用又比较麻烦，<code>gjson</code>提供了<code>GetMany()</code>可以一次读取多个值，返回一个数组<code>[]gjson.Result</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&quot;dj&quot;,</span><br><span class="hljs-string">  &quot;age&quot;:18,</span><br><span class="hljs-string">  &quot;pets&quot;: [&quot;cat&quot;, &quot;dog&quot;],</span><br><span class="hljs-string">  &quot;contact&quot;: &#123;</span><br><span class="hljs-string">    &quot;phone&quot;: &quot;123456789&quot;,</span><br><span class="hljs-string">    &quot;email&quot;: &quot;dj@example.com&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  results := gjson.GetMany(json, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;pets.#&quot;</span>, <span class="hljs-string">&quot;contact.phone&quot;</span>)<br>  <span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<br>    fmt.Println(result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go-如何使用Resty"><a href="#Go-如何使用Resty" class="headerlink" title="Go - 如何使用Resty"></a>Go - 如何使用Resty</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>RESTful API</code>已成为现代<code>Web</code>开发的基石，实现了客户端和服务器之间的无缝通信。在本文中，我们将探索使用<code>Resty</code>这个流行的<code>HTTP</code>客户端库在<code>Go</code>中执行常见操作，如<code>GET</code>、<code>POST</code>、<code>UPDATE</code>和<code>DELETE</code>请求的强大和简单性。我们还将学习如何在请求中传递头部，以便自定义和增强我们的<code>API</code>交互。</p><h3 id="安装Resty"><a href="#安装Resty" class="headerlink" title="安装Resty"></a>安装Resty</h3><p>首先，我们需要在<code>Go</code>环境中安装<code>Resty</code>。我们可以使用以下命令安装<code>Resty</code>包：</p><p>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/go-resty/resty/v2<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h3 id="发起GET请求"><a href="#发起GET请求" class="headerlink" title="发起GET请求"></a>发起GET请求</h3><p>以下代码片段演示了一个简单的<code>GET</code>请求，并将响应绑定到一个结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> users []DevUser<br><br>    response, err := resty.New().R().SetResult(&amp;users).Get(<span class="hljs-string">&quot;https://api.example.com/users&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;GET响应:&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;检索到%d个用户:\n&quot;</span>, <span class="hljs-built_in">len</span>(users))<br>    <span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;用户ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, user.ID, user.Name, user.Email)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起POST请求"><a href="#发起POST请求" class="headerlink" title="发起POST请求"></a>发起POST请求</h3><p>下面的示例演示了如何发送带有<code>JSON</code>负载的<code>POST</code>请求，并将响应绑定到结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> createdUser DevUser<br><br>    payload := DevUser&#123;<br>        Name:  <span class="hljs-string">&quot;John Doe&quot;</span>,<br>        Email: <span class="hljs-string">&quot;johndoe@example.com&quot;</span>,<br>    &#125;<br><br>    response, err := resty.New().R().<br>        SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>        SetBody(&amp;payload).<br>        SetResult(&amp;createdUser).<br>        Post(<span class="hljs-string">&quot;https://api.example.com/users&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;POST响应：&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;创建的用户：ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, createdUser.ID, createdUser.Name, createdUser.Email)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起UPDATE（PUT）请求"><a href="#发起UPDATE（PUT）请求" class="headerlink" title="发起UPDATE（PUT）请求"></a>发起UPDATE（PUT）请求</h3><p>下面的示例演示了如何发送带有<code>JSON</code>负载的<code>PUT</code>请求，并将响应绑定到结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> updatedUser DevUser<br><br>    payload := DevUser&#123;<br>        Name:  <span class="hljs-string">&quot;Updated Name&quot;</span>,<br>        Email: <span class="hljs-string">&quot;updated@example.com&quot;</span>,<br>    &#125;<br><br>    response, err := resty.New().R().<br>        SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>        SetBody(&amp;payload).<br>        SetResult(&amp;updatedUser).<br>        Put(<span class="hljs-string">&quot;https://api.example.com/users/123&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;PUT响应：&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;更新的用户：ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, updatedUser.ID, updatedUser.Name, updatedUser.Email)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起DELETE请求"><a href="#发起DELETE请求" class="headerlink" title="发起DELETE请求"></a>发起DELETE请求</h3><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    response, err := resty.New().R().Delete(<span class="hljs-string">&quot;https://api.example.com/users/123&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;DELETE响应：&quot;</span>, response.Status())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传递头部"><a href="#传递头部" class="headerlink" title="传递头部"></a>传递头部</h3><p><code>Resty v2</code>允许我们在请求中包含自定义头部。下面的代码片段演示了如何使用<code>Resty v2</code>传递头部：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client := resty.New()<br>    client.SetHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer YOUR_TOKEN&quot;</span>)<br><br>    response, err := client.R().Get(<span class="hljs-string">&quot;https://api.example.com/protected-resource&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;带有头部的GET响应：&quot;</span>, response.Status())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个全面的指南中，我们探索了如何利用<code>Resty v2</code>这个易于使用的<code>HTTP</code>客户端库，在<code>Go</code>中执行<code>GET</code>、<code>POST</code>、<code>UPDATE</code>和<code>DELETE</code>请求。我们还学习了如何传递头部以增强我们的<code>API</code>交互，提供更高的定制性和安全性。此外，我们还了解了如何将<code>API</code>响应绑定到<code>Go</code>结构体中，以便轻松处理和操作数据。<code>Resty v2</code>简化了<code>RESTful API</code>的使用，使我们能够专注于构建强大和高效的应用程序。</p><h2 id="sjson"><a href="#sjson" class="headerlink" title="sjson"></a>sjson</h2><h3 id="快速使用-1"><a href="#快速使用-1" class="headerlink" title="快速使用"></a>快速使用</h3><p>先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/tidwall/sjson<br></code></pre></td></tr></table></figure><p>后使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/tidwall/sjson&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  value, _ := sjson.Set(json, <span class="hljs-string">&quot;name.last&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码通过<code>sjson.Set()</code>将 JSON 串中<code>name.last</code>对应的值设置为<code>dajun</code>。与<code>gjson</code>一样，<code>sjson</code>也通过<strong>键路径</strong>指定具体的位置，键路径即为一系列以<code>.</code>分隔的键。<code>sjson</code>支持的键路径语法是<code>gjson</code>的一个子集，sjson.Set()&#96;返回设置之后的 JSON 串。最终程序输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">`<span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;dajun&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span> `<br></code></pre></td></tr></table></figure><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><p><code>sjson</code>支持的类型包括<code>nil/bool/int/float/string</code>等。如果传入<code>sjson</code>不支持的类型，<code>sjson</code>会调用<code>json.Marshal</code>，然后将生成的字符串设置到对应的键路径上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  nilJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-literal">nil</span>)<br>  fmt.Println(nilJSON)<br><br>  boolJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-literal">false</span>)<br>  fmt.Println(boolJSON)<br><br>  intJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>)<br>  fmt.Println(intJSON)<br><br>  floatJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">10.5</span>)<br>  fmt.Println(floatJSON)<br><br>  strJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>  fmt.Println(strJSON)<br><br>  mapJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>&#125;)<br>  fmt.Println(mapJSON)<br><br>  u := User&#123;Name: <span class="hljs-string">&quot;dj&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>  structJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, u)<br>  fmt.Println(structJSON)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们传入一个空字符串，<code>sjson.Set()</code>会生成一个空对象，然后按照键路径依次设置值。下面分析上述程序输出：</p><ul><li><code>nil</code>：在 JSON 中用<code>null</code>表示，输出<code>&#123;&quot;key&quot;:null&#125;</code>；</li><li><code>false</code>：在 JSON 中布尔值用<code>true/false</code>表示，输出<code>&#123;&quot;key&quot;:false&#125;</code>；</li><li><code>1</code>和<code>10.5</code>：整数和浮点数在 JSON 中都用<code>number</code>表示，分别输出<code>&#123;&quot;key&quot;:1&#125;</code>和<code>&#123;&quot;key&quot;:10.5&#125;</code>；</li><li><code>hello</code>：输出<code>&#123;&quot;key&quot;:&quot;hello&quot;&#125;</code>；</li><li><code>map[string]interface&#123;&#125;</code>：<code>sjson</code>并不原生支持<code>map</code>类型，故通过<code>json.Marshal</code>将其序列化为<code>&#123;&quot;hello&quot;:&quot;world&quot;&#125;</code>再设置到键<code>key</code>上，输出<code>&#123;&quot;key&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;</code>；</li><li><code>User</code>对象：先通过<code>json.Marshal</code>序列化为<code>&#123;&quot;name&quot;:&quot;dj&quot;,&quot;age&quot;:18&#125;</code>再设置；</li></ul><h3 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h3><p>修改数组可以通过在键路径后添加索引，有两种特殊情况：</p><ul><li>使用<code>-1</code>或数组长度为索引表示在数组后添加一个新元素；</li><li>使用的索引超出数组的长度，会在数组中添加很多<code>null</code>值。</li></ul><p>看下面示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fruits := <span class="hljs-string">`&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;`</span><br><br>  <span class="hljs-keyword">var</span> newValue <span class="hljs-type">string</span><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.1&quot;</span>, <span class="hljs-string">&quot;grape&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.3&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.-1&quot;</span>, <span class="hljs-string">&quot;strawberry&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.5&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>)<br>  fmt.Println(newValue)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>fruits.1</code>：设置第二个水果为<code>grape</code>（<strong>索引从 0 开始</strong>），输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;grape&quot;, &quot;banana&quot;]&#125;</code>；</li><li><code>fruits.3</code>：由于数组长度为 3，使用 3 表示在数组后添加一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;,&quot;pear&quot;]&#125;</code>；</li><li><code>fruits.-1</code>：使用<code>-1</code>同样表示在数组后添加一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;,&quot;strawberry&quot;]&#125;</code>;</li><li><code>fruits.5</code>：索引 5 已经大于数组长度 3 了，所以会多出两个<code>null</code>，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;,null,null,&quot;watermelon&quot;]&#125;</code>。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除数组元素需要调用<code>sjson.Delete()</code>方法，键路径语法相同。如果键路径对应的值不存在，则<code>Delete()</code>无效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> newValue <span class="hljs-type">string</span><br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br><br>  newValue, _ = sjson.Delete(user, <span class="hljs-string">&quot;name.first&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(user, <span class="hljs-string">&quot;name.full&quot;</span>)<br>  fmt.Println(newValue)<br><br>  fruits := <span class="hljs-string">`&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;`</span><br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.1&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.-1&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.5&quot;</span>)<br>  fmt.Println(newValue)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>name.first</code>：删除字段<code>name.first</code>，输出<code>&#123;&quot;name&quot;:&#123;&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;</code>；</li><li><code>name.full</code>：由于字段<code>name.full</code>不存在，无效果，输出<code>&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;</code>；</li><li><code>fruits.1</code>：删除数组<code>fruits</code>的第二个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;banana&quot;]&#125;</code>；</li><li><code>fruits.-1</code>：删除数组最后一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;]&#125;</code>；</li><li><code>fruits.5</code>：索引 5 超出数组长度 3，无效果，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;</code>。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>使用<code>sjson</code>出现的错误分为两种，一种是传入的 JSON 串不是合法的串，另一种是键路径语法错误。<code>Set()</code>和<code>Delete()</code>方法返回的第二个参数为错误，只有非法的键路径会返回错误，非法 JSON 串不会。</p><h3 id="非法-JSON-串"><a href="#非法-JSON-串" class="headerlink" title="非法 JSON 串"></a>非法 JSON 串</h3><p>同<code>gjson</code>一样，<code>sjson</code>同样不会检查传入的 JSON 串的合法性，它假设传入的是合法的串。如果传入一个非法的 JSON 串，程序输出不确定的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:dj,age:18&#125;`</span><br>  newValue, err := sjson.Set(user, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(err, newValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中，我故意传入一个非法的 JSON 串（<code>dj</code>和<code>age</code>漏掉了双引号）。最终程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;<span class="hljs-literal">nil</span>&gt; &#123;<span class="hljs-string">&quot;name&quot;</span>:dj,age:<span class="hljs-string">&quot;dajun&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>将<code>age</code>变为了<code>dajun</code>，显然不正确。然而此时返回的<code>err = nil</code>。</p><h3 id="非法键路径"><a href="#非法键路径" class="headerlink" title="非法键路径"></a>非法键路径</h3><p>与<code>gjson</code>相比，<code>sjson</code>能使用的键路径语法比较有限，不能使用通配符和一些条件语法。如果传入的键路径非法，将返回非空的错误值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:&quot;dj&quot;,&quot;age&quot;:18&#125;`</span><br>  newValue, err := sjson.Set(user, <span class="hljs-string">&quot;na?e&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(err, newValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>上次使用通配符<code>?</code>，输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>wildcard characters not allowed in path <br><br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>sjson</code>比较简单易用，性能不俗。我们在确定 JSON 串合法的情况下，可使用它快速设置值。</p><h2 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h2><p>在Go语言中，对slice和map是我们最常用的数据结构。比如，计算两个切片的交集、差集；判断切片中的元素是否都满足某个条件的等。我推荐大家使用这个包：<code>[elliotchance/pie](https://github.com/elliotchance/pie)</code>。</p><p>该包封装了<strong>对切片和map的常用操作,能满足工作中的大部分需求</strong>。比如计算切片的交集、差集；对切片中元素按条件过滤的Filter函数；对切片中元素进行数据转换的Each、Map函数等。</p><p>同时具有<strong>高性能</strong>、<strong>类型安全</strong>的特点。实现中对各函数的参数都做了类型的限制。比如Average函数就只能对整型和浮点型参数有效。</p><h3 id="使用pie包的要求："><a href="#使用pie包的要求：" class="headerlink" title="使用pie包的要求："></a>使用pie包的要求：</h3><p>pie v2版本需要Go 1.18+。Go1.17及以下版本需要使用v1版本。</p><h3 id="pie包的目标："><a href="#pie包的目标：" class="headerlink" title="pie包的目标："></a>pie包的目标：</h3><ul><li><strong>类型安全</strong>：无论是在v1版本还是v2版本的泛型中，都对类型做了限制，所以不会遇到运行时类型错误。</li><li><strong>高性能</strong>：该库需要跟原生的Go实现一样快，否则该库封装就没有意义。</li><li><strong>Nil安全</strong>：该库的所有函数都能接收nil参数，并将其视为空切片，而不会引起panic。</li><li><strong>对原切片无副作用</strong>：所有的函数对传入的切片参数都不会做修改。</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>go 版本在1.18及以上，会使用pie&#x2F;v2包，该包使用的是泛型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/elliotchance/pie/v2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    name := pie.Of([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Sally&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;).<br>    FilterNot(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> strings.HasPrefix(name, <span class="hljs-string">&quot;J&quot;</span>)<br>    &#125;).<br>    Map(strings.ToUpper).<br>    Last()<br><br>    fmt.Println(name) <span class="hljs-comment">// &quot;SALLY&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>go1.17及以下版本需要使用pie&#x2F;v1包。因为在1.17之前go还不支持泛型，所以函数只能针对特定类型的切片。在该v1包中，pie实际上是定义了一组类型切片。比如，代表string切片的pie.Strings类型。代表float64切片的pie.Float64s类型。那么该版本在使用时需要先定义切片的类型。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/elliotchance/pie/pie&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> names pie.Strings <span class="hljs-comment">//看pie的源码Strings的底层类型是[]string</span><br>    names = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Sally&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;<br><br>    name := names.FilterNot(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> strings.HasPrefix(name, <span class="hljs-string">&quot;J&quot;</span>)<br>    &#125;).<br>    Map(strings.ToUpper).<br>    Last()<br><br>    fmt.Println(name) <span class="hljs-comment">// &quot;SALLY&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pie包支持的功能："><a href="#pie包支持的功能：" class="headerlink" title="pie包支持的功能："></a>pie包支持的功能：</h3><ul><li>切片中的元素是否全部或任意一个满足指定的条件。</li><li>All函数：判断切片中的元素是否都满足指定的条件。</li><li>Any函数：判断切片中的元素只要有1个满足指定条件即可。</li><li>对切片元素进行排序功能。</li><li>AreSorted函数：判断切片是否是有序的</li><li>Sort函数：对切片元素进行排序。</li><li>SortStableUsing函数：使用指定的条件对切片进行排序，并且具有稳定性。</li><li>SortUsing函数</li><li>对切片中的元素去重。</li><li>判断切片中的元素是否不重复的AreUnique函数、去重函数Unique</li><li>对切片进行前、后截取。</li><li>Bottom函数：取切片后n个元素</li><li>Top函数：取切片前n个元素</li><li>DropTop函数：丢掉切片的前n个元素，并返回剩余的元素切片</li><li>两个或多个切片之间的集合运算</li><li>Diff函数：计算两个切片中的差集</li><li>Intersect函数：计算两个或多个切片的交集</li><li>切片元素进行算数运算功能（只针对Integer和float类型的切片有效）。</li><li>Max函数：返回切片中的最大元素</li><li>Min函数：返回切片中的最小元素</li><li>Product函数：对切片所有元素进行乘积运算</li><li>Sum函数：对切片中所有元素进行求和运算</li><li>Average函数：求所有元素的平均值</li><li>对切片中的元素进行数据转换功能：Each、Map、Filter、Flat、Reducer</li><li>针对map的操作：</li><li>Keys函数：获取map的所有键</li><li>Values函数：获取map的所有值</li></ul><p>更多、更详细的功能请参考pie包的源码。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>pie包几乎把slice经常用到的功能都做了封装，可谓是给开发者节省了大量时间。同时，v2包利用了泛型中的类型限制，保证了类型的安全。在性能方面，该包采用了很多策略：在已知切片长度的情况下尽可能给slice<strong>分配固定长度</strong>的内存，减少在使用append时内存申请的次数；使用<strong>切片截取</strong>的形式，避免内存再次分配。</p><h2 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h2><p>viper是go一个强大的流行的配置解决方案的库。viper是spf13的另外一个重量级库。有大量项目都使用该库，比如hugo, docker等。 它基本上可以处理所有类型的配置需求和格式, viper支持功能</p><ul><li><p>支持 JSON&#x2F;TOML&#x2F;YAML&#x2F;HCL&#x2F;envfile&#x2F;Java properties 等多种格式的配置文件；</p></li><li><p>可以设置监听配置文件的修改，修改时自动加载新的配置；</p></li><li><p>从环境变量、命令行选项和<code>io.Reader</code>中读取配置；</p></li><li><p>从远程配置系统中读取和监听修改，如 etcd&#x2F;Consul；</p></li><li><p>代码逻辑中显示设置键值。</p></li></ul><h3 id="快速使用-2"><a href="#快速使用-2" class="headerlink" title="快速使用"></a>快速使用</h3><p>安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/spf13/viper<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>  viper.SetDefault(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">6381</span>)# 默认值可以调用viper.SetDefault设置<br>  err := viper.ReadInConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>  &#125;<br><br>  fmt.Println(viper.Get(<span class="hljs-string">&quot;app_name&quot;</span>))<br>  fmt.Println(viper.Get(<span class="hljs-string">&quot;log_level&quot;</span>))<br><br>  fmt.Println(<span class="hljs-string">&quot;mysql ip: &quot;</span>, viper.Get(<span class="hljs-string">&quot;mysql.ip&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;mysql port: &quot;</span>, viper.Get(<span class="hljs-string">&quot;mysql.port&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;mysql user: &quot;</span>, viper.Get(<span class="hljs-string">&quot;mysql.user&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;mysql password: &quot;</span>, viper.Get(<span class="hljs-string">&quot;mysql.password&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;mysql database: &quot;</span>, viper.Get(<span class="hljs-string">&quot;mysql.database&quot;</span>))<br><br>  fmt.Println(<span class="hljs-string">&quot;redis ip: &quot;</span>, viper.Get(<span class="hljs-string">&quot;redis.ip&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;redis port: &quot;</span>, viper.Get(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="读取键"><a href="#读取键" class="headerlink" title="读取键"></a>读取键</h3><p>viper 提供了多种形式的读取方法。在上面的例子中，我们看到了<code>Get</code>方法的用法。<code>Get</code>方法返回一个<code>interface&#123;&#125;</code>的值，使用有所不便。</p><p><code>GetType</code>系列方法可以返回指定类型的值。 其中，Type 可以为<code>Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice</code>。 但是请注意，</p><p><strong>如果指定的键不存在或类型不正确，<code>GetType</code>方法返回对应类型的零值</strong>。</p><p>如果要判断某个键是否存在，使用<code>IsSet</code>方法。 另外，<code>GetStringMap</code>和<code>GetStringMapString</code>直接以 map 返回某个键下面所有的键值对，前者返回<code>map[string]interface&#123;&#125;</code>，后者返回<code>map[string]string</code>。 <code>AllSettings</code>以<code>map[string]interface&#123;&#125;</code>返回所有设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 省略包名和 import 部分</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>  err := viper.ReadInConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>  &#125;<br><br>  fmt.Println(<span class="hljs-string">&quot;protocols: &quot;</span>, viper.GetStringSlice(<span class="hljs-string">&quot;server.protocols&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;ports: &quot;</span>, viper.GetIntSlice(<span class="hljs-string">&quot;server.ports&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;timeout: &quot;</span>, viper.GetDuration(<span class="hljs-string">&quot;server.timeout&quot;</span>))<br><br>  fmt.Println(<span class="hljs-string">&quot;mysql ip: &quot;</span>, viper.GetString(<span class="hljs-string">&quot;mysql.ip&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;mysql port: &quot;</span>, viper.GetInt(<span class="hljs-string">&quot;mysql.port&quot;</span>))<br><br>  <span class="hljs-keyword">if</span> viper.IsSet(<span class="hljs-string">&quot;redis.port&quot;</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;redis.port is set&quot;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;redis.port is not set&quot;</span>)<br>  &#125;<br><br>  fmt.Println(<span class="hljs-string">&quot;mysql settings: &quot;</span>, viper.GetStringMap(<span class="hljs-string">&quot;mysql&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;redis settings: &quot;</span>, viper.GetStringMap(<span class="hljs-string">&quot;redis&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;all settings: &quot;</span>, viper.AllSettings())# 获取所有配置值<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置键值"><a href="#设置键值" class="headerlink" title="设置键值"></a>设置键值</h3><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><p><code>viper.Set</code></p><p>如果某个键通过<code>viper.Set</code>设置了值，那么这个值的优先级最高。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.Set(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">5381</span>)<br></code></pre></td></tr></table></figure><p><code>命令行选项</code></p><p>如果一个键没有通过<code>viper.Set</code>显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在<code>init</code>方法中定义选项，并且调用<code>viper.BindPFlags</code>绑定选项到配置中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  pflag.Int(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">8381</span>, <span class="hljs-string">&quot;Redis port to connect&quot;</span>)<br><br>  <span class="hljs-comment">// 绑定命令行</span><br>  viper.BindPFlags(pflag.CommandLine)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在<code>main</code>方法开头处调用<code>pflag.Parse</code>解析选项。</p><p>编译、运行程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./main.exe --redis.port 9381<br>awesome web<br>DEBUG<br>mysql ip:  127.0.0.1<br>mysql port:  3306<br>mysql user:  dj<br>mysql password:  123456<br>mysql database:  awesome<br>redis ip:  127.0.0.1<br>redis port:  9381<br></code></pre></td></tr></table></figure><p><code>环境变量</code></p><p>如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。</p><p>在<code>init</code>方法中调用<code>AutomaticEnv</code>方法绑定全部环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 绑定环境变量</span><br>  viper.AutomaticEnv()<br>&#125;<br></code></pre></td></tr></table></figure><p>为了验证是否绑定成功，我们在<code>main</code>方法中将环境变量 GOPATH 打印出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 省略部分代码</span><br><br>  fmt.Println(<span class="hljs-string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="hljs-string">&quot;GOPATH&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以单独绑定环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 绑定环境变量</span><br>  viper.BindEnv(<span class="hljs-string">&quot;redis.port&quot;</span>)<br>  viper.BindEnv(<span class="hljs-string">&quot;go.path&quot;</span>, <span class="hljs-string">&quot;GOPATH&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 省略部分代码</span><br>  fmt.Println(<span class="hljs-string">&quot;go path: &quot;</span>, viper.Get(<span class="hljs-string">&quot;go.path&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>BindEnv</code>方法，如果只传入一个参数，则这个参数既表示键名，又表示环境变量名。 如果传入两个参数，则第一个参数表示键名，第二个参数表示环境变量名。</p><p>还可以通过<code>viper.SetEnvPrefix</code>方法设置环境变量前缀，这样一来，通过<code>AutomaticEnv</code>和一个参数的<code>BindEnv</code>绑定的环境变量， 在使用<code>Get</code>的时候，viper 会自动加上这个前缀再从环境变量中查找。</p><p>如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名<code>gopath</code>也能读取环境变量<code>GOPATH</code>的值。</p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>从<code>io.Reader</code>中读取</p><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;bytes&quot;</span><br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  tomlConfig := []<span class="hljs-type">byte</span>(<span class="hljs-string">`</span><br><span class="hljs-string">app_name = &quot;awesome web&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># possible values: DEBUG, INFO, WARNING, ERROR, FATAL</span><br><span class="hljs-string">log_level = &quot;DEBUG&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">[mysql]</span><br><span class="hljs-string">ip = &quot;127.0.0.1&quot;</span><br><span class="hljs-string">port = 3306</span><br><span class="hljs-string">user = &quot;dj&quot;</span><br><span class="hljs-string">password = 123456</span><br><span class="hljs-string">database = &quot;awesome&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">[redis]</span><br><span class="hljs-string">ip = &quot;127.0.0.1&quot;</span><br><span class="hljs-string">port = 7381</span><br><span class="hljs-string">`</span>)<br>  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>  &#125;<br><br>  fmt.Println(<span class="hljs-string">&quot;redis port: &quot;</span>, viper.GetInt(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Unmarshal</code></p><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>  AppName  <span class="hljs-type">string</span><br>  LogLevel <span class="hljs-type">string</span><br><br>  MySQL    MySQLConfig<br>  Redis    RedisConfig<br>&#125;<br><br><span class="hljs-keyword">type</span> MySQLConfig <span class="hljs-keyword">struct</span> &#123;<br>  IP       <span class="hljs-type">string</span><br>  Port     <span class="hljs-type">int</span><br>  User     <span class="hljs-type">string</span><br>  Password <span class="hljs-type">string</span><br>  Database <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> RedisConfig <span class="hljs-keyword">struct</span> &#123;<br>  IP   <span class="hljs-type">string</span><br>  Port <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>  err := viper.ReadInConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> c Config<br>  viper.Unmarshal(&amp;c)<br><br>  fmt.Println(c.MySQL)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h3><p>有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！</p><ul><li><code>WriteConfig</code>：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖；</li><li><code>WriteConfigAs</code>：保存配置到指定路径，如果文件存在，则覆盖；</li><li><code>SafeWriteConfigAs</code>：与上面功能一样，但是入股配置文件存在，则不覆盖。</li></ul><p>下面我们通过程序生成一个<code>config.toml</code>配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;log&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br><br>  viper.Set(<span class="hljs-string">&quot;app_name&quot;</span>, <span class="hljs-string">&quot;awesome web&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;log_level&quot;</span>, <span class="hljs-string">&quot;DEBUG&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;mysql.ip&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;mysql.port&quot;</span>, <span class="hljs-number">3306</span>)<br>  viper.Set(<span class="hljs-string">&quot;mysql.user&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;mysql.password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;mysql.database&quot;</span>, <span class="hljs-string">&quot;awesome&quot;</span>)<br><br>  viper.Set(<span class="hljs-string">&quot;redis.ip&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>)<br>  viper.Set(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">6381</span>)<br><br>  err := viper.SafeWriteConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;write config failed: &quot;</span>, err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h3><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>  viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>  viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>  err := viper.ReadInConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>  &#125;<br><br>  viper.WatchConfig()<br><br>  fmt.Println(<span class="hljs-string">&quot;redis port before sleep: &quot;</span>, viper.Get(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>  time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>  fmt.Println(<span class="hljs-string">&quot;redis port after sleep: &quot;</span>, viper.Get(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要调用<code>viper.WatchConfig</code>，viper 会自动监听配置修改。如果有修改，重新加载的配置。</p><p>上面程序中，我们先打印<code>redis.port</code>的值，然后<code>Sleep</code> 10s。在这期间修改配置中<code>redis.port</code>的值，<code>Sleep</code>结束后再次打印。 发现打印出修改后的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">redis port before sleep:  <span class="hljs-number">7381</span><br>redis port after sleep:  <span class="hljs-number">73810</span><br></code></pre></td></tr></table></figure><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.OnConfigChange(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e fsnotify.Event)</span></span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;Config file:%s Op:%s\n&quot;</span>, e.Name, e.Op)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><p>viper 使用<a href="https://link.juejin.cn/?target=https://github.com/fsnotify/fsnotify">fsnotify</a>这个库来实现监听文件修改的功能。</p><h3 id="viper之坑"><a href="#viper之坑" class="headerlink" title="viper之坑"></a>viper之坑</h3><ul><li>yaml空值，修改完成之后会丢失</li><li>key全部自动转成小写，docker-compose里面容器大小写敏感</li></ul><h2 id="golang-set包"><a href="#golang-set包" class="headerlink" title="golang-set包"></a>golang-set包</h2><p>Set是一种基本的数据结构,它具备确定性、互异性、无序性三个特点。因此，在开发过程中我们通常用它来判断一些数据的集合与另一个数据集合或者元素的包含关系。在大部分开发语言中set都是一种基本的数据结构，但是golang不提供set类型。通常情况下，我们都会用map[interface{}]struct{}{}来代替set实现包含关系的判断。但事实上，我们在github上会发现一些第三方的开源包。例如<a href="https://links.jianshu.com/go?to=https://github.com/deckarep/golang-set">golang-set</a>就是一个相对成熟的包。截止到2021年3月份已经有1.8k的star和160+的fork。同时这个包本身也已经应用于docker项目中。是一个可用性和可靠性都经过验证的第三方包，可以放心使用</p><p>golang-set包本身也是基于map[interface{}]struct{}{}结构实现的，同时golang-set包提供了线程安全和不保证安全的两种set类型，相比于线程安全的set对象，不保证安全的set对象执行效率会更高一点。</p><h3 id="快速使用-3"><a href="#快速使用-3" class="headerlink" title="快速使用"></a>快速使用</h3><p>golang-set的使用也非常简单，只需导入该包然后创建set对象即可开始使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> mapset <span class="hljs-string">&quot;github.com/deckarep/golang-set&quot;</span><br><br>set := mapset.NewSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>set.Add(<span class="hljs-number">6</span>)<br><br>set.Contains(<span class="hljs-number">5</span>)<br>set.Remove(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h3><p>golang 提供了两种set类型，一种是普通的集合对象，一种是线程安全的集合对象，通过结构嵌套的方式为普通集合对象新增了一个全局锁，实现了线程安全。具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> threadSafeSet <span class="hljs-keyword">struct</span> &#123;<br>    s threadUnsafeSet<br>    sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newThreadSafeSet</span><span class="hljs-params">()</span></span> threadSafeSet &#123;<br>    <span class="hljs-keyword">return</span> threadSafeSet&#123;s: newThreadUnsafeSet()&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>golang-set包提供的集合操作方法包含如下23个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">interface</span> &#123;<br>    Add(i <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span><br>    Cardinality() <span class="hljs-type">int</span><br>    Clear()<br>    Clone() Set<br>    Contains(i ...<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span><br>    Difference(other Set) Set<br>    Equal(other Set) <span class="hljs-type">bool</span><br>    Intersect(other Set) Set<br>    IsProperSubset(other Set) <span class="hljs-type">bool</span><br>    IsProperSuperset(other Set) <span class="hljs-type">bool</span><br>    IsSubset(other Set) <span class="hljs-type">bool</span><br>    IsSuperset(other Set) <span class="hljs-type">bool</span><br>    Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span>)<br>    Iter() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>    Iterator() *Iterator<br>    Remove(i <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    String() <span class="hljs-type">string</span><br>    SymmetricDifference(other Set) Set<br>    Union(other Set) Set<br>    Pop() <span class="hljs-keyword">interface</span>&#123;&#125;<br>    PowerSet() Set<br>    CartesianProduct(other Set) Set<br>    ToSlice() []<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体含义如下：</p><ul><li><p>Add(i interface{}) bool:用于向集合中添加某些元素</p></li><li><p>Cardinality() int ：返回集合元素个数</p></li><li><p>Clear() ：清空集合中全部元素，剩下一个空的集合，使用不需要通过NewSet进行初始化</p></li><li><p>Clone() Set ：复制一个一模一样的集合对象</p></li><li><p>Contains(i …interface{}) bool ：返回是否参数元素全部包含于集合中</p></li><li><p>Difference(other Set) Set ：将返回当前集合与参数集合的全部差异元素，这些元素包含于本集合但是不包含于参数集合。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>Equal(other Set) bool ：如果参数集合与当前集合的容量和全部元素是相同的，那么会被然认为是相同的，无需考虑元素的顺序。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>Intersect(other Set) Set：将返回两个集合的交集。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>IsProperSubset(other Set) bool：判断当前set是否为参数set的真子集（包含但不相等）。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>IsProperSuperset(other Set) bool：判断参数set是否为当前set的真子集（包含但不相等）。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>IsSubset(other Set) bool：判断当前set是否为参数set的子集（包含，允许相等）。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>IsSuperset(other Set) bool：判断参数set是否为当前set的子集（包含，允许相等）。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>Each(func(interface{}) bool)：遍历元素，并对每个元素执行传递的func。如果传递的func返回true，则此时停止迭代。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//clone a</span><br>b := NewSet()<br>a.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(elem <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>    b.Add(elem)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>Iter() &lt;-chan interface{}：返回一个可以遍历set的channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">b := NewSet()<br><span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> a.Iter() &#123;<br>    b.Add(val)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Iterator() *Iterator：返回一个Iterator对象，用于遍历set的全部参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">b := NewThreadUnsafeSet()<br><span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> a.Iterator().C &#123;<br>    b.Add(val)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Remove(i interface{}) :从当前集合中移除某个元素</p></li><li><p>String() string：返回集合的string格式，set:{}用于查看该集合</p></li><li><p>SymmetricDifference(other Set) Set：返回当前集合与参数集合的对称差集（对称差集中的元素要么包含于本集合，要么包含于参数集合，但是不能属于两者的交集）。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>Union(other Set) Set：返回当前集合与参数集合的并集。注意：入参的set类型与方法接受者set的类型必须一致，否则将导致panic。</p></li><li><p>Pop() interface{}：移除并返回一个随机的元素</p></li><li><p>PowerSet() Set：返回当前集合的全部子集</p></li><li><p>CartesianProduct(other Set) Set：返回当前集合与参数集合的笛卡尔积结果集合</p></li><li><p>ToSlice() []interface{}：返回当前集合的切片对象。</p></li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>由上文可知，golang-set提供了普通和线程安全两种类型的集合对象。其中线程安全的集合对象，通过结构嵌套的方式为普通集合对象新增了一个全局锁，实现了线程安全。因此针对方法的实现主要通过普通集合对象的实现来介绍。</p><p>golang-set包的具体实现其实非常简单，基于golang-set原生的map结构作为基本的存储结构，value以一个不占用内存空间的struct{}{}为值。其中一个我认为值得我们借鉴的开发技巧就是golang-set的遍历方法，具体源码如下所示：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(set *threadUnsafeSet)</span></span> Iter() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> elem := <span class="hljs-keyword">range</span> *set &#123;<br>            ch &lt;- elem<br>        &#125;<br>        <span class="hljs-built_in">close</span>(ch)<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> ch<br>&#125;<br></code></pre></td></tr></table></figure><p>它通过创建一个协程去遍历set对象，同时返回一个channel 由用户去读取set的遍历结果，是的读取较大set对象时，用户无需等待，而直接读取，具有较高的效率，但是他的缺点也十分明显，那就是这个方式无法中途退出，也就是说，在使用该方法遍历时，用户必须保证会执行完全部的遍历结果。否则，由于返回的channel是无缓冲的channel,用户不读取时，Iterator()方法中的遍历协程将阻塞，而无法退出，就会发生内存泄漏，</p><p>为了方便遍历方法的中途退出，golang-set又提供了另外一个遍历方法，通过返回一个美枚举对象来实现set对象的异步遍历。具体源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Iterator <span class="hljs-keyword">struct</span> &#123;<br>    C    &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>    stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newIterator</span><span class="hljs-params">()</span></span> (*Iterator, <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">interface</span>&#123;&#125;, &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    itemChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    stopChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> &amp;Iterator&#123;<br>        C:    itemChan,<br>        stop: stopChan,<br>    &#125;, itemChan, stopChan<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(set *threadUnsafeSet)</span></span> Iterator() *Iterator &#123;<br>    iterator, ch, stopCh := newIterator()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    L:<br>        <span class="hljs-keyword">for</span> elem := <span class="hljs-keyword">range</span> *set &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-stopCh:<br>                <span class="hljs-keyword">break</span> L<br>            <span class="hljs-keyword">case</span> ch &lt;- elem:<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">close</span>(ch)<br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> iterator<br>&#125;<br></code></pre></td></tr></table></figure><p>其中枚举对象Iterator中的C channel用于异步读取遍历结果，stop channel用于主动停止遍历协程，从而避免内存泄漏。具体的使用方法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">it := a.Iterator()<br><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> it.C &#123;<br>    <span class="hljs-comment">//退出条件</span><br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">10</span>)&#123;<br>        it.stop()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="gopsutil"><a href="#gopsutil" class="headerlink" title="gopsutil"></a>gopsutil</h2><p>gopsutil是psutil的go语言版本实现，主要功能是获取系统上各项监控信息，包括不限于cpu,内存，磁盘，网络，进程，docker等等</p><p>gopsutil支持跨平台多架构，包括i386&#x2F;amd64&#x2F;arm架构，以及windows,linux等各种系统，其中对linux的支持项最多</p><p>gopsutil最新为v3版本，默认是v2版本</p><h3 id="快速使用-4"><a href="#快速使用-4" class="headerlink" title="快速使用"></a>快速使用</h3><p>安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/shirou/gopsutil<br></code></pre></td></tr></table></figure><p>由于<code>gopsutil</code>库用到了<code>golang.org/x/sys</code>，后者在墙外，如果有类似下面的报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">cannot find <span class="hljs-keyword">package</span> <span class="hljs-string">&quot;golang.org/x/sys/windows&quot;</span><br></code></pre></td></tr></table></figure><p>可使用下面的命令下载<code>golang.org/x/sys</code>在 GitHub 上的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:golang/sys.git <span class="hljs-variable">$GOPATH</span>/src/golang.org/x/sys<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/shirou/gopsutil/mem&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  v, _ := mem.VirtualMemory()<br><br>  fmt.Printf(<span class="hljs-string">&quot;Total: %v, Available: %v, UsedPercent:%f%%\n&quot;</span>, v.Total, v.Available, v.UsedPercent)<br><br>  fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gopsutil</code>将不同的功能划分到不同的子包中：</p><ul><li><code>cpu</code>：CPU 相关；</li><li><code>disk</code>：磁盘相关；</li><li><code>docker</code>：docker 相关；</li><li><code>host</code>：主机相关；</li><li><code>mem</code>：内存相关；</li><li><code>net</code>：网络相关；</li><li><code>process</code>：进程相关；</li><li><code>winservices</code>：Windows 服务相关。</li></ul><p>想要使用对应的功能，要导入对应的子包。例如，上面代码中，我们要获取内存信息，导入的是<code>mem</code>子包。<code>mem.VirtualMemory()</code>方法返回内存信息结构<code>mem.VirtualMemoryStat</code>，该结构有丰富的字段，我们最常使用的无外乎<code>Total</code>（总内存）、<code>Available</code>（可用内存）、<code>Used</code>（已使用内存）和<code>UsedPercent</code>（内存使用百分比）。<code>mem.VirtualMemoryStat</code>还实现了<code>fmt.Stringer</code>接口，以 JSON 格式返回内存信息。语句<code>fmt.Println(v)</code>会自动调用<code>v.String()</code>，将返回信息输出。程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Total: <span class="hljs-number">31252709376</span>, Available: <span class="hljs-number">18457317376</span>, UsedPercent:<span class="hljs-number">36.622837</span>%<br>&#123;<span class="hljs-string">&quot;total&quot;</span>:<span class="hljs-number">31252709376</span>,<span class="hljs-string">&quot;available&quot;</span>:<span class="hljs-number">18457317376</span>,<span class="hljs-string">&quot;used&quot;</span>:<span class="hljs-number">11445628928</span>,<span class="hljs-string">&quot;usedPercent&quot;</span>:<span class="hljs-number">36.62283736842822</span>,<span class="hljs-string">&quot;free&quot;</span>:<span class="hljs-number">3926921216</span>,<span class="hljs-string">&quot;active&quot;</span>:<span class="hljs-number">16073904128</span>,<span class="hljs-string">&quot;inactive&quot;</span>:<span class="hljs-number">9631600640</span>,<span class="hljs-string">&quot;wired&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;laundry&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;buffers&quot;</span>:<span class="hljs-number">991232000</span>,<span class="hljs-string">&quot;cached&quot;</span>:<span class="hljs-number">14888927232</span>,<span class="hljs-string">&quot;writeback&quot;</span>:<span class="hljs-number">4096</span>,<span class="hljs-string">&quot;dirty&quot;</span>:<span class="hljs-number">66256896</span>,<span class="hljs-string">&quot;writebacktmp&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;shared&quot;</span>:<span class="hljs-number">891125760</span>,<span class="hljs-string">&quot;slab&quot;</span>:<span class="hljs-number">1062789120</span>,<span class="hljs-string">&quot;sreclaimable&quot;</span>:<span class="hljs-number">760090624</span>,<span class="hljs-string">&quot;sunreclaim&quot;</span>:<span class="hljs-number">302698496</span>,<span class="hljs-string">&quot;pagetables&quot;</span>:<span class="hljs-number">108027904</span>,<span class="hljs-string">&quot;swapcached&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;commitlimit&quot;</span>:<span class="hljs-number">47626792960</span>,<span class="hljs-string">&quot;committedas&quot;</span>:<span class="hljs-number">38288269312</span>,<span class="hljs-string">&quot;hightotal&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;highfree&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;lowtotal&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;lowfree&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;swaptotal&quot;</span>:<span class="hljs-number">32000438272</span>,<span class="hljs-string">&quot;swapfree&quot;</span>:<span class="hljs-number">32000438272</span>,<span class="hljs-string">&quot;mapped&quot;</span>:<span class="hljs-number">3175104512</span>,<span class="hljs-string">&quot;vmalloctotal&quot;</span>:<span class="hljs-number">35184372087808</span>,<span class="hljs-string">&quot;vmallocused&quot;</span>:<span class="hljs-number">100999168</span>,<span class="hljs-string">&quot;vmallocchunk&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;hugepagestotal&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;hugepagesfree&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;hugepagesize&quot;</span>:<span class="hljs-number">2097152</span>&#125;<br></code></pre></td></tr></table></figure><p>单位为字节，我的电脑内存 32GB，当前使用百分比为 36%，可用内存 18457317376（即 18GB）。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>我们知道 CPU 的核数有两种，一种是物理核数，一种是逻辑核数。物理核数就是主板上实际有多少个 CPU，一个物理 CPU 上可以有多个核心，这些核心被称为逻辑核。<code>gopsutil</code>中 CPU 相关功能在<code>cpu</code>子包中，<code>cpu</code>子包提供了获取物理和逻辑核数、CPU 使用率的接口：</p><p><code>Counts(logical bool)</code>：传入<code>false</code>，返回物理核数，传入<code>true</code>，返回逻辑核数；</p><p><code>Percent(interval time.Duration, percpu bool)</code>：表示获取<code>interval</code>时间间隔内的 CPU 使用率，<code>percpu</code>为<code>false</code>时，获取总的 CPU 使用率，<code>percpu</code>为<code>true</code>时，分别获取每个 CPU 的使用率，返回一个<code>[]float64</code>类型的值。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  physicalCnt, _ := cpu.Counts(<span class="hljs-literal">false</span>)<br>  logicalCnt, _ := cpu.Counts(<span class="hljs-literal">true</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;physical count:%d logical count:%d\n&quot;</span>, physicalCnt, logicalCnt)<br><br>  totalPercent, _ := cpu.Percent(<span class="hljs-number">3</span>*time.Second, <span class="hljs-literal">false</span>)<br>  perPercents, _ := cpu.Percent(<span class="hljs-number">3</span>*time.Second, <span class="hljs-literal">true</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;total percent:%v per percents:%v&quot;</span>, totalPercent, perPercents)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码获取物理核数和逻辑核数，并获取 3s 内的总 CPU 使用率和每个 CPU 各自的使用率，程序输出（注意每次运行输出可能都不相同）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">physical count:<span class="hljs-number">8</span> logical count:<span class="hljs-number">16</span><br>total percent:[<span class="hljs-number">8.362730856991261</span>] per percents:[<span class="hljs-number">12.012987012975508</span> <span class="hljs-number">8.524590163938532</span> <span class="hljs-number">11.038961038943015</span> <span class="hljs-number">6.249999999988781</span> <span class="hljs-number">8.47457627121518</span> <span class="hljs-number">5.050505050493915</span> <span class="hljs-number">8.813559322011011</span> <span class="hljs-number">4.745762711875798</span> <span class="hljs-number">5.479452054789401</span> <span class="hljs-number">9.427609427602931</span> <span class="hljs-number">6.802721088430114</span> <span class="hljs-number">6.020066889640449</span> <span class="hljs-number">9.897610921502555</span> <span class="hljs-number">3.7542662116080683</span> <span class="hljs-number">8.135593220332085</span> <span class="hljs-number">5.4054054054020835</span>]<br></code></pre></td></tr></table></figure><p><strong>详细信息</strong></p><p>调用<code>cpu.Info()</code>可获取 CPU 的详细信息，返回<code>[]cpu.InfoStat</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  infos, _ := cpu.Info()<br>  <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> infos &#123;<br>    data, _ := json.MarshalIndent(info, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>    fmt.Print(<span class="hljs-type">string</span>(data))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便查看，我使用 JSON 输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;cpu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;vendorId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;GenuineIntel&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;family&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;198&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;model&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;stepping&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;physicalId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BFEBFBFF000906E9&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;coreId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;cores&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;modelName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;mhz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3601</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;cacheSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;flags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;microcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>由结果可以看出，CPU 是 Intel 的 i7-7700 系列，频率 3.60GHz。上面是我在 Windows 上运行的返回结果，内部使用了<code>github.com/StackExchange/wmi</code>库。在 Linux 下每个逻辑 CPU 都会返回一个<code>InfoStat</code>结构。</p><p><strong>时间占用</strong></p><p>调用<code>cpu.Times(percpu bool)</code>可以获取从开机算起，总 CPU 和 每个单独的 CPU 时间占用情况。传入<code>percpu=false</code>返回总的，传入<code>percpu=true</code>返回单个的。每个 CPU 时间占用情况是一个<code>TimeStat</code>结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/cpu/cpu.go</span><br><span class="hljs-keyword">type</span> TimesStat <span class="hljs-keyword">struct</span> &#123;<br>  CPU       <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;cpu&quot;`</span><br>  User      <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;user&quot;`</span><br>  System    <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;system&quot;`</span><br>  Idle      <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;idle&quot;`</span><br>  Nice      <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;nice&quot;`</span><br>  Iowait    <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;iowait&quot;`</span><br>  Irq       <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;irq&quot;`</span><br>  Softirq   <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;softirq&quot;`</span><br>  Steal     <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;steal&quot;`</span><br>  Guest     <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;guest&quot;`</span><br>  GuestNice <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;guestNice&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>CPU</code>：CPU 标识，如果是总的，该字段为<code>cpu-total</code>，否则为<code>cpu0</code>、<code>cpu1</code>…；</li><li><code>User</code>：用户时间占用（用户态）；</li><li><code>System</code>：系统时间占用（内核态）；</li><li><code>Idle</code>：空闲时间；</li><li>…</li></ul><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  infos, _ := cpu.Times(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> infos &#123;<br>    data, _ := json.MarshalIndent(info, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>    fmt.Print(<span class="hljs-type">string</span>(data))<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了方便查看，我用 JSON 输出结果，下面是其中一个输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br> <span class="hljs-string">&quot;cpu&quot;</span>: <span class="hljs-string">&quot;cpu0&quot;</span>,<br> <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-number">674.46875</span>,<br> <span class="hljs-string">&quot;system&quot;</span>: <span class="hljs-number">1184.984375</span>,<br> <span class="hljs-string">&quot;idle&quot;</span>: <span class="hljs-number">7497.1875</span>,<br> <span class="hljs-string">&quot;nice&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-string">&quot;iowait&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-string">&quot;irq&quot;</span>: <span class="hljs-number">75.578125</span>,<br> <span class="hljs-string">&quot;softirq&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-string">&quot;steal&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-string">&quot;guest&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-string">&quot;guestNice&quot;</span>: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>子包<code>disk</code>用于获取磁盘信息。<code>disk</code>可获取 IO 统计、分区和使用率信息。下面依次介绍。</p><p><strong>IO 统计</strong></p><p>调用<code>disk.IOCounters()</code>函数，返回的 IO 统计信息用<code>map[string]IOCountersStat</code>类型表示。每个分区一个结构，键为分区名，值为统计信息。这里摘取统计结构的部分字段，主要有读写的次数、字节数和时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/disk/disk.go</span><br><span class="hljs-keyword">type</span> IOCountersStat <span class="hljs-keyword">struct</span> &#123;<br>  ReadCount        <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;readCount&quot;`</span><br>  MergedReadCount  <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;mergedReadCount&quot;`</span><br>  WriteCount       <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;writeCount&quot;`</span><br>  MergedWriteCount <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;mergedWriteCount&quot;`</span><br>  ReadBytes        <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;readBytes&quot;`</span><br>  WriteBytes       <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;writeBytes&quot;`</span><br>  ReadTime         <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;readTime&quot;`</span><br>  WriteTime        <span class="hljs-type">uint64</span> <span class="hljs-string">`json:&quot;writeTime&quot;`</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  mapStat, _ := disk.IOCounters()<br>  <span class="hljs-keyword">for</span> name, stat := <span class="hljs-keyword">range</span> mapStat &#123;<br>    fmt.Println(name)<br>    data, _ := json.MarshalIndent(stat, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    fmt.Println(<span class="hljs-type">string</span>(data))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出包括所有分区，我这里只展示一个：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-symbol">nvme0</span><span class="hljs-symbol">n1</span>p<span class="hljs-number">3</span><br>&#123;<br>  <span class="hljs-string">&quot;readCount&quot;</span>: <span class="hljs-number">48</span>,<br>  <span class="hljs-string">&quot;mergedReadCount&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;writeCount&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;mergedWriteCount&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;readBytes&quot;</span>: <span class="hljs-number">598016</span>,<br>  <span class="hljs-string">&quot;writeBytes&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;readTime&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;writeTime&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;iopsInProgress&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;ioTime&quot;</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-string">&quot;weightedIO&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;nvme0n1p3&quot;</span>,<br>  <span class="hljs-string">&quot;serialNumber&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>注意，<code>disk.IOCounters()</code>可传入可变数量的字符串参数用于标识分区，<strong>此参数在 Windows 上无效</strong>。</p><p><strong>分区</strong></p><p>调用<code>disk.PartitionStat(all bool)</code>函数，返回分区信息。如果<code>all = false</code>，只返回实际的物理分区（包括硬盘、CD-ROM、USB），忽略其它的虚拟分区。如果<code>all = true</code>则返回所有的分区。返回类型为<code>[]PartitionStat</code>，每个分区对应一个<code>PartitionStat</code>结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/disk/</span><br><span class="hljs-keyword">type</span> PartitionStat <span class="hljs-keyword">struct</span> &#123;<br>  Device     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;device&quot;`</span><br>  Mountpoint <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;mountpoint&quot;`</span><br>  Fstype     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;fstype&quot;`</span><br>  Opts       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;opts&quot;`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>Device</code>：分区标识，在 Windows 上即为<code>C:</code>这类格式；</p><p><code>Mountpoint</code>：挂载点，即该分区的文件路径起始位置；</p><p><code>Fstype</code>：文件系统类型，Windows 常用的有 FAT、NTFS 等，Linux 有 ext、ext2、ext3等；</p><p><code>Opts</code>：选项，与系统相关。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  infos, _ := disk.Partitions(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> infos &#123;<br>    data, _ := json.MarshalIndent(info, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    fmt.Println(<span class="hljs-type">string</span>(data))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出包括所有分区，我这里只展示一个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;device&quot;</span>: <span class="hljs-string">&quot;/dev/nvme0n1p8&quot;</span>,<br>  <span class="hljs-string">&quot;mountpoint&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>  <span class="hljs-string">&quot;fstype&quot;</span>: <span class="hljs-string">&quot;ext4&quot;</span>,<br>  <span class="hljs-string">&quot;opts&quot;</span>: <span class="hljs-string">&quot;rw,relatime&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用率</strong></p><p>调用<code>disk.Usage(path string)</code>即可获得路径<code>path</code>所在磁盘的使用情况，返回一个<code>UsageStat</code>结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/disk.go</span><br><span class="hljs-keyword">type</span> UsageStat <span class="hljs-keyword">struct</span> &#123;<br>  Path              <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;path&quot;`</span><br>  Fstype            <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;fstype&quot;`</span><br>  Total             <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;total&quot;`</span><br>  Free              <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;free&quot;`</span><br>  Used              <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;used&quot;`</span><br>  UsedPercent       <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;usedPercent&quot;`</span><br>  InodesTotal       <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;inodesTotal&quot;`</span><br>  InodesUsed        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;inodesUsed&quot;`</span><br>  InodesFree        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;inodesFree&quot;`</span><br>  InodesUsedPercent <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;inodesUsedPercent&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Path</code>：路径，传入的参数；</li><li><code>Fstype</code>：文件系统类型；</li><li><code>Total</code>：该分区总容量；</li><li><code>Free</code>：空闲容量；</li><li><code>Used</code>：已使用的容量；</li><li><code>UsedPercent</code>：使用百分比</li></ul><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  info, _ := disk.Usage(<span class="hljs-string">&quot;/home&quot;</span>)<br>  data, _ := json.MarshalIndent(info, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>  fmt.Println(<span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure><p>由于返回的是磁盘的使用情况，所以路径<code>/home和/:</code>返回同样的结果，只是结构中的<code>Path</code>字段不同而已。程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>  <span class="hljs-string">&quot;fstype&quot;</span>: <span class="hljs-string">&quot;ext2/ext3&quot;</span>,<br>  <span class="hljs-string">&quot;total&quot;</span>: <span class="hljs-number">665553149952</span>,<br>  <span class="hljs-string">&quot;free&quot;</span>: <span class="hljs-number">535020593152</span>,<br>  <span class="hljs-string">&quot;used&quot;</span>: <span class="hljs-number">96649084928</span>,<br>  <span class="hljs-string">&quot;usedPercent&quot;</span>: <span class="hljs-number">15.300573746356008</span>,<br>  <span class="hljs-string">&quot;inodesTotal&quot;</span>: <span class="hljs-number">41345024</span>,<br>  <span class="hljs-string">&quot;inodesUsed&quot;</span>: <span class="hljs-number">1743985</span>,<br>  <span class="hljs-string">&quot;inodesFree&quot;</span>: <span class="hljs-number">39601039</span>,<br>  <span class="hljs-string">&quot;inodesUsedPercent&quot;</span>: <span class="hljs-number">4.218125499213642</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>子包<code>host</code>可以获取主机相关信息，如开机时间、内核版本号、平台信息等等</p><p><strong>开机时间</strong></p><p><code>host.BootTime()</code>返回主机开机时间的时间戳：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  timestamp, _ := host.BootTime()<br>  t := time.Unix(<span class="hljs-type">int64</span>(timestamp), <span class="hljs-number">0</span>)<br>  fmt.Println(t.Local().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面先获取开机时间，然后通过<code>time.Unix()</code>将其转为<code>time.Time</code>类型，最后输出<code>2006-01-02 15:04:05</code>格式的时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024-08-12 08:54:18<br></code></pre></td></tr></table></figure><p><strong>内核版本和平台信息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>version, _ := host.KernelVersion()<br>fmt.Println(version)<br><br>platform, family, version, _ := host.PlatformInformation()<br>fmt.Println(<span class="hljs-string">&quot;platform:&quot;</span>, platform)<br>fmt.Println(<span class="hljs-string">&quot;family:&quot;</span>, family)<br>fmt.Println(<span class="hljs-string">&quot;version:&quot;</span>, version)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">6.5</span><span class="hljs-number">.0</span><span class="hljs-number">-28</span>-generic<br>platform: debian<br>family: debian<br>version: bookworm/sid<br></code></pre></td></tr></table></figure><p><strong>终端用户</strong></p><p><code>host.Users()</code>返回终端连接上来的用户信息，每个用户一个<code>UserStat</code>结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/host/host.go</span><br><span class="hljs-keyword">type</span> UserStat <span class="hljs-keyword">struct</span> &#123;<br>  User     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user&quot;`</span><br>  Terminal <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;terminal&quot;`</span><br>  Host     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;host&quot;`</span><br>  Started  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;started&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  users, _ := host.Users()<br>  <span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>    data, _ := json.MarshalIndent(user, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>    fmt.Println(<span class="hljs-type">string</span>(data))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br> <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;gond&quot;</span>,<br> <span class="hljs-string">&quot;terminal&quot;</span>: <span class="hljs-string">&quot;tty2&quot;</span>,<br> <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;tty2&quot;</span>,<br> <span class="hljs-string">&quot;started&quot;</span>: <span class="hljs-number">1723424126</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>在<code>快速使用</code>中，我们演示了如何使用<code>mem.VirtualMemory()</code>来获取内存信息。该函数返回的只是物理内存信息。我们还可以使用<code>mem.SwapMemory()</code>获取交换内存的信息，信息存储在结构<code>SwapMemoryStat</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// src/github.com/shirou/gopsutil/mem/</span><br><span class="hljs-keyword">type</span> SwapMemoryStat <span class="hljs-keyword">struct</span> &#123;<br>  Total       <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;total&quot;`</span><br>  Used        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;used&quot;`</span><br>  Free        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;free&quot;`</span><br>  UsedPercent <span class="hljs-type">float64</span> <span class="hljs-string">`json:&quot;usedPercent&quot;`</span><br>  Sin         <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;sin&quot;`</span><br>  Sout        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;sout&quot;`</span><br>  PgIn        <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;pgin&quot;`</span><br>  PgOut       <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;pgout&quot;`</span><br>  PgFault     <span class="hljs-type">uint64</span>  <span class="hljs-string">`json:&quot;pgfault&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字段含义很容易理解，<code>PgIn/PgOut/PgFault</code>这三个字段我们重点介绍一下。交换内存是以<strong>页</strong>为单位的，如果出现缺页错误(<code>page fault</code>)，操作系统会将磁盘中的某些页载入内存，同时会根据特定的机制淘汰一些内存中的页。<code>PgIn</code>表征载入页数，<code>PgOut</code>淘汰页数，<code>PgFault</code>缺页错误数。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  swapMemory, _ := mem.SwapMemory()<br>  data, _ := json.MarshalIndent(swapMemory, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>  fmt.Println(<span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><code>process</code>可用于获取系统当前运行的进程信息，创建新进程，对进程进行一些操作等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> rootProcess *process.Process<br>  processes, _ := process.Processes()<br>  <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> processes &#123;<br>    <span class="hljs-keyword">if</span> p.Pid == <span class="hljs-number">0</span> &#123;<br>      rootProcess = p<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br><br>  fmt.Println(rootProcess)<br><br>  fmt.Println(<span class="hljs-string">&quot;children:&quot;</span>)<br>  children, _ := rootProcess.Children()<br>  <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> children &#123;<br>    fmt.Println(p)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先调用<code>process.Processes()</code>获取当前系统中运行的所有进程，然后找到<code>Pid</code>为 0 的进程，即操作系统的第一个进程，最后调用<code>Children()</code>返回其子进程。还有很多方法可获取进程信息，感兴趣可查看文档了解</p><h2 id="ants-协程池"><a href="#ants-协程池" class="headerlink" title="ants(协程池)"></a>ants(协程池)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>处理大量并发是 Go 语言的一大优势。语言内置了方便的并发语法，可以非常方便的创建很多个轻量级的 goroutine 并发处理任务。相比于创建多个线程，goroutine 更轻量、资源占用更少、切换速度更快、无线程上下文切换开销更少。但是受限于资源总量，系统中能够创建的 goroutine 数量也是受限的。默认每个 goroutine 占用 8KB 内存，一台 8GB 内存的机器满打满算也只能创建 8GB&#x2F;8KB &#x3D; 1000000 个 goroutine，更何况系统还需要保留一部分内存运行日常管理任务，go 运行时需要内存运行 gc、处理 goroutine 切换等。使用的内存超过机器内存容量，系统会使用交换区（swap），导致性能急速下降</p><h3 id="快速使用-5"><a href="#快速使用-5" class="headerlink" title="快速使用"></a>快速使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/panjf2000/ants/v2<br></code></pre></td></tr></table></figure><p>ants的使用有四种方式，分别如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240904161834137.png?raw=true" alt="image-20240904161834137"></p><p>这四种使用方式，前两种最常用，基本能满足日常系统的开发需要，第四种默认池，简单的场景也可以用，但不推荐，多池的情况还没想到特别合适的应用场景。</p><h3 id="使用方式详解"><a href="#使用方式详解" class="headerlink" title="使用方式详解"></a>使用方式详解</h3><h4 id="默认池"><a href="#默认池" class="headerlink" title="默认池"></a>默认池</h4><p>ants在启动时，会默认初始化一个协程池，这部分代码位于ants.go文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// ErrLackPoolFunc will be returned when invokers don&#x27;t provide function for pool.</span><br>ErrLackPoolFunc = errors.New(<span class="hljs-string">&quot;must provide function for pool&quot;</span>)<br> <br><span class="hljs-comment">// ErrInvalidPoolExpiry will be returned when setting a negative number as the periodic duration to purge goroutines.</span><br>ErrInvalidPoolExpiry = errors.New(<span class="hljs-string">&quot;invalid expiry for pool&quot;</span>)<br> <br><span class="hljs-comment">// ErrPoolClosed will be returned when submitting task to a closed pool.</span><br>ErrPoolClosed = errors.New(<span class="hljs-string">&quot;this pool has been closed&quot;</span>)<br> <br><span class="hljs-comment">// ErrPoolOverload will be returned when the pool is full and no workers available.</span><br>ErrPoolOverload = errors.New(<span class="hljs-string">&quot;too many goroutines blocked on submit or Nonblocking is set&quot;</span>)<br> <br><span class="hljs-comment">// ErrInvalidPreAllocSize will be returned when trying to set up a negative capacity under PreAlloc mode.</span><br>ErrInvalidPreAllocSize = errors.New(<span class="hljs-string">&quot;can not set up a negative capacity under PreAlloc mode&quot;</span>)<br> <br><span class="hljs-comment">// ErrTimeout will be returned after the operations timed out.</span><br>ErrTimeout = errors.New(<span class="hljs-string">&quot;operation timed out&quot;</span>)<br> <br><span class="hljs-comment">// ErrInvalidPoolIndex will be returned when trying to retrieve a pool with an invalid index.</span><br>ErrInvalidPoolIndex = errors.New(<span class="hljs-string">&quot;invalid pool index&quot;</span>)<br> <br><span class="hljs-comment">// ErrInvalidLoadBalancingStrategy will be returned when trying to create a MultiPool with an invalid load-balancing strategy.</span><br>ErrInvalidLoadBalancingStrategy = errors.New(<span class="hljs-string">&quot;invalid load-balancing strategy&quot;</span>)<br> <br><span class="hljs-comment">// workerChanCap determines whether the channel of a worker should be a buffered channel</span><br><span class="hljs-comment">// to get the best performance. Inspired by fasthttp at</span><br><span class="hljs-comment">// https://github.com/valyala/fasthttp/blob/master/workerpool.go#L139</span><br>workerChanCap = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// Use blocking channel if GOMAXPROCS=1.</span><br><span class="hljs-comment">// This switches context from sender to receiver immediately,</span><br><span class="hljs-comment">// which results in higher performance (under go1.5 at least).</span><br><span class="hljs-keyword">if</span> runtime.GOMAXPROCS(<span class="hljs-number">0</span>) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br> <br><span class="hljs-comment">// Use non-blocking workerChan if GOMAXPROCS&gt;1,</span><br><span class="hljs-comment">// since otherwise the sender might be dragged down if the receiver is CPU-bound.</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;()<br> <br><span class="hljs-comment">// log.Lmsgprefix is not available in go1.13, just make an identical value for it.</span><br>logLmsgprefix = <span class="hljs-number">64</span><br>defaultLogger = Logger(log.New(os.Stderr, <span class="hljs-string">&quot;[ants]: &quot;</span>, log.LstdFlags|logLmsgprefix|log.Lmicroseconds))<br> <br><span class="hljs-comment">// Init an instance pool when importing ants.</span><br>defaultAntsPool, _ = NewPool(DefaultAntsPoolSize)<br>)<br></code></pre></td></tr></table></figure><p>使用起来就比较简单，直接往池子里提交任务即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/panjf2000/ants/v2&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 默认池</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addsum</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; d; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;sum is ：&quot;</span>, sum)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>now := time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>ants.Submit(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>addsum(<span class="hljs-number">1000000000</span>)<br>wg.Done()<br>&#125;)<br>&#125;<br><br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;协程池运行时间:&quot;</span>, time.Since(now))<br>now = time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>addsum(<span class="hljs-number">1000000000</span>)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;主线程运行时间:&quot;</span>, time.Since(now))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>协程池运行时间: <span class="hljs-number">460.392277</span>ms<br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>sum is ： <span class="hljs-number">499999999500000000</span><br>主线程运行时间: <span class="hljs-number">2.176051363</span>s<br></code></pre></td></tr></table></figure><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>普通模式和使用默认池非常类似，但是需要自己创建一个线程池：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p, _ := ants.NewPool(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>函数参数为协程池协程个数，测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br> <br><span class="hljs-string">&quot;github.com/panjf2000/ants/v2&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; d; i++ &#123;<br>sum += i<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>now := time.Now()<br>p, _ := ants.NewPool(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>p.Submit(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(<span class="hljs-number">10000000000</span>)<br>wg.Done()<br>&#125;)<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;协程池运行：&quot;</span>, time.Since(now))<br>now = time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>add(<span class="hljs-number">10000000000</span>)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环运行：&quot;</span>, time.Since(now))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">协程池运行： <span class="hljs-number">221.90558</span>ms<br>循环运行： <span class="hljs-number">1.059491865</span>s<br></code></pre></td></tr></table></figure><h4 id="带参函数"><a href="#带参函数" class="headerlink" title="带参函数"></a>带参函数</h4><p>带参函数，重点是往worker中传递函数执行的参数，每个workder中都是同一个执行函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br> <br><span class="hljs-string">&quot;github.com/panjf2000/ants/v2&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; d; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;the sum is: &quot;</span>, sum)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>now := time.Now()<br>p, _ := ants.NewPoolWithFunc(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>add(i.(<span class="hljs-type">int</span>))<br>wg.Done()<br>&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>p.Invoke(<span class="hljs-number">1000000000</span>)<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;循环运行：&quot;</span>, time.Since(now))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>协程池运行： <span class="hljs-number">448.830883</span>ms<br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>循环运行： <span class="hljs-number">2.142860462</span>s<br></code></pre></td></tr></table></figure><h4 id="多池多协程"><a href="#多池多协程" class="headerlink" title="多池多协程"></a>多池多协程</h4><p>这种模式，就是声明了多个协程池，每个池子里有多个协程在跑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/panjf2000/ants/v2&quot;</span><br>)<br><br><span class="hljs-comment">// 多池多协程</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addsum3</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; d; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;the sum is: &quot;</span>, sum)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>runTimes := <span class="hljs-number">10</span><br>now := time.Now()<br>mpf, _ := ants.NewMultiPoolWithFunc(<span class="hljs-number">10</span>, runTimes/<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">// size 代表要创建的子协程池的总数 sizePerPool（runTimes/5）每个子协程池中的工作线程数量</span><br>addsum3(i.(<span class="hljs-type">int</span>))<br>wg.Done()<br>&#125;, ants.LeastTasks)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runTimes; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>mpf.Invoke(<span class="hljs-number">1000000000</span>)<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;协程池运行时间:&quot;</span>, time.Since(now))<br>now = time.Now()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runTimes; i++ &#123;<br>addsum3(<span class="hljs-number">1000000000</span>)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;主线程运行时间:&quot;</span>, time.Since(now))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>协程池运行时间: <span class="hljs-number">739.516116</span>ms<br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>the sum is:  <span class="hljs-number">499999999500000000</span><br>主线程运行时间: <span class="hljs-number">4.2396312</span>s<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>普通模式、带参数函数是推荐的使用方式，使用协程池，可以有效的控制系统硬件资源的使用，防止机器被打满，对于高并发服务非常推荐使用。</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reflect反射笔记</title>
    <link href="/2024/12/10/go/reflect%E5%8C%85%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/12/10/go/reflect%E5%8C%85%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="reflect反射机制"><a href="#reflect反射机制" class="headerlink" title="reflect反射机制"></a>reflect反射机制</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>反射是一种让程序在运行时自省（introspect）和修改自身结构和行为的机制。虽然这听起来有点像“自我观察”，但实际上，反射在许多现代编程语言中都是一个非常强大和重要的工具。Go语言也不例外。在Go语言中，反射不仅能帮助你更深入地理解语言本身，而且还能极大地增加代码的灵活性和可维护性。</p><h2 id="2、什么是反射"><a href="#2、什么是反射" class="headerlink" title="2、什么是反射"></a>2、什么是反射</h2><p>反射（Reflection）在编程中通常被定义为在运行时检查程序的能力。这种能力使得一个程序能够操纵像变量、数据结构、方法和类型这样的对象的各种属性和行为。这一机制在Go中主要通过**<code>reflect</code>**标准库实现。</p><h3 id="反射与类型系统"><a href="#反射与类型系统" class="headerlink" title="反射与类型系统"></a><strong>反射与类型系统</strong></h3><p>反射紧密地与类型系统联系在一起。在静态类型语言（例如Go）中，每一个变量都有预先定义的类型，这些类型在编译期就确定。但反射允许你在运行时去查询和改变这些类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：查询变量的类型和值</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br>    t := reflect.TypeOf(x)<br>    v := reflect.ValueOf(x)<br>    fmt.Println(<span class="hljs-string">&quot;Type:&quot;</span>, t)<br>    fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, v)<br>&#125;<br><span class="hljs-comment">// 输出: Type: int</span><br><span class="hljs-comment">// 输出: Value: 42</span><br></code></pre></td></tr></table></figure><h3 id="反射和接口"><a href="#反射和接口" class="headerlink" title="反射和接口"></a><strong>反射和接口</strong></h3><p>在Go中，接口（interface）和反射是紧密相关的。事实上，你可以认为接口是实现反射的“入口”。当你将一个具体类型的变量赋给一个接口变量时，这个接口变量内部存储了这个具体变量的类型信息和数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：接口与反射</span><br><span class="hljs-keyword">type</span> Any <span class="hljs-keyword">interface</span>&#123;&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inspect</span><span class="hljs-params">(a Any)</span></span> &#123;<br>    t := reflect.TypeOf(a)<br>    v := reflect.ValueOf(a)<br>    fmt.Println(<span class="hljs-string">&quot;Type:&quot;</span>, t, <span class="hljs-string">&quot;Value:&quot;</span>, v)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = <span class="hljs-number">20.0</span><br>    inspect(x) <span class="hljs-comment">// Type: int Value: 10</span><br>    inspect(y) <span class="hljs-comment">// Type: float64 Value: 20</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射的分类"><a href="#反射的分类" class="headerlink" title="反射的分类"></a>反射的分类</h3><p>射在Go中主要有两个方向：</p><ol><li><strong>类型反射（Type Reflection）</strong>: 主要关注于程序运行时获取变量的类型信息。</li><li><strong>值反射（Value Reflection）</strong>: 主要关注于程序运行时获取或设置变量的值。</li></ol><h4 id="类型反射"><a href="#类型反射" class="headerlink" title="类型反射"></a>类型反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：类型反射</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 使用自定义类型</span><br><span class="hljs-keyword">var</span> x MyStruct<br>t := reflect.TypeOf(x)<br>fmt.Println(<span class="hljs-string">&quot;Type Name:&quot;</span>, t.Name()) <span class="hljs-comment">// 输出: Type Name: MyStruct</span><br>fmt.Println(<span class="hljs-string">&quot;Type Kind:&quot;</span>, t.Kind()) <span class="hljs-comment">// 输出: Type Kind: Struct</span><br><br><span class="hljs-comment">// 使用预定义类型</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">int</span><br>t = reflect.TypeOf(y)<br>fmt.Println(<span class="hljs-string">&quot;Type Name:&quot;</span>, t.Name()) <span class="hljs-comment">// 输出: Type Name: </span><br>fmt.Println(<span class="hljs-string">&quot;Type Kind:&quot;</span>, t.Kind()) <span class="hljs-comment">// 输出: Type Kind: Int</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="值反射"><a href="#值反射" class="headerlink" title="值反射"></a>值反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：值反射</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inspectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    v := reflect.ValueOf(x)<br>    fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, v)<br>    fmt.Println(<span class="hljs-string">&quot;Is Zero:&quot;</span>, v.IsZero())<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    inspectValue(<span class="hljs-number">42</span>)       <span class="hljs-comment">// Value: 42, Is Zero: false</span><br>    inspectValue(<span class="hljs-string">&quot;&quot;</span>)       <span class="hljs-comment">// Value: , Is Zero: true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射的限制与警告"><a href="#反射的限制与警告" class="headerlink" title="反射的限制与警告"></a>反射的限制与警告</h3><p>尽管反射非常强大，但也有其局限性和风险，比如性能开销、代码可读性下降等。因此，在使用反射时，需要谨慎评估是否真的需要使用反射，以及如何最有效地使用它。</p><h2 id="3、为什么需要反射"><a href="#3、为什么需要反射" class="headerlink" title="3、为什么需要反射"></a>3、为什么需要反射</h2><p>虽然反射是一个强大的特性，但它也常常被批评为影响代码可读性和性能。那么，何时以及为何需要使用反射呢？</p><h4 id="提升代码灵活性"><a href="#提升代码灵活性" class="headerlink" title="提升代码灵活性"></a>提升代码灵活性</h4><p>使用反射，你可以编写出更加通用和可配置的代码，因此可以在不修改源代码的情况下，对程序行为进行调整。</p><h4 id="配置化"><a href="#配置化" class="headerlink" title="配置化"></a>配置化</h4><p>反射使得从配置文件动态加载代码设置成为可能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 代码示例：从JSON配置文件动态加载设置</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>    Field1 <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;field1&quot;`</span><br>    Field2 <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;field2&quot;`</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadConfig</span><span class="hljs-params">(jsonStr <span class="hljs-type">string</span>, config *Config)</span></span> &#123;<br>    v := reflect.ValueOf(config).Elem()<br>    t := v.Type()<br>    <span class="hljs-comment">// 省略JSON解析步骤</span><br>    <span class="hljs-comment">// 动态设置字段值</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>        field := t.Field(i)<br>        jsonTag := field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br>        <span class="hljs-comment">// 使用jsonTag从JSON数据中获取相应的值，并设置到结构体字段</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>反射能够使得程序更容易支持插件，提供了一种动态加载和执行代码的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：动态加载插件</span><br><span class="hljs-keyword">type</span> Plugin <span class="hljs-keyword">interface</span> &#123;<br>    PerformAction()<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadPlugin</span><span class="hljs-params">(pluginName <span class="hljs-type">string</span>)</span></span> Plugin &#123;<br>    <span class="hljs-comment">// 使用反射来动态创建插件实例</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解耦"><a href="#代码解耦" class="headerlink" title="代码解耦"></a>代码解耦</h4><p>反射也被广泛用于解耦代码，特别是在框架和库的设计中。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>许多现代框架使用反射来实现依赖注入，从而减少代码间的硬编码关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 代码示例：依赖注入</span><br><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">interface</span> &#123;<br>    Query()<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Inject</span><span class="hljs-params">(db Database)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> db Database<br>    <span class="hljs-comment">// 使用反射来动态创建Database的实例</span><br>    Inject(db)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态方法调用"><a href="#动态方法调用" class="headerlink" title="动态方法调用"></a>动态方法调用</h4><p>反射可以用于动态地调用方法，这在构建灵活的API或RPC系统中特别有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：动态方法调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallMethod</span><span class="hljs-params">(instance <span class="hljs-keyword">interface</span>&#123;&#125;, methodName <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    v := reflect.ValueOf(instance)<br>    method := v.MethodByName(methodName)<br>    <span class="hljs-comment">// 转换args并调用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能与安全性的权衡"><a href="#性能与安全性的权衡" class="headerlink" title="性能与安全性的权衡"></a>性能与安全性的权衡</h4><p>使用反射的确会有一些性能开销，但这通常可以通过合理的架构设计和优化来缓解。同时，由于反射可以让你访问或修改私有字段和方法，因此需要注意安全性问题。</p><h2 id="4、Go中反射的实现"><a href="#4、Go中反射的实现" class="headerlink" title="4、Go中反射的实现"></a>4、Go中反射的实现</h2><p>变量是由两部分组成：变量的类型和变量的值。</p><p><code>reflect.Type</code> 和 <code>reflect.Value</code> 是反射的两大基本要素，他们的关系如下：</p><ul><li><p>任意类型都可以转换成 <code>Type</code> 和 <code>Value</code></p></li><li><p><code>Value</code> 可以转换成 <code>Type</code></p><ul><li><p><code>reflect.Value</code>可以很容易地转换为<code>reflect.Type</code>，这主要是为了获取<code>Value</code>所表示的值的类型信息。你可以通过调用<code>reflect.Value</code>的<code>Type()</code>方法来获取其代表的类型的<code>reflect.Type</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v := reflect.ValueOf(<span class="hljs-number">123</span>)<br>t := v.Type()<br>fmt.Printf(<span class="hljs-string">&quot;Type: %s\n&quot;</span>, t) <span class="hljs-comment">// 输出: Type: int</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>Value</code> 可以转换成 <code>Interface</code></p><ul><li><p><code>reflect.Value</code>可以转换为<code>interface&#123;&#125;</code>，这使得你能够从反射世界返回到常规的Go编程世界。<code>reflect.Value</code>的<code>Interface()</code>方法用于这种转换。这在你需要将反射得到的值作为普通值使用时非常有用，例如当你需要将值传递给一个期望具体类型的函数时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v := reflect.ValueOf(<span class="hljs-number">123</span>)<br>i := v.Interface()<br>fmt.Printf(<span class="hljs-string">&quot;Value: %T, %v\n&quot;</span>, i, i) <span class="hljs-comment">// 输出: Value: int, 123</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://github.com/gondmhd/blogImage/blob/main/img//image-20240722141955691.png?raw=true" alt="类型和值"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v := reflect.ValueOf(<span class="hljs-number">123</span>)<br>t := v.Type()<br>fmt.Printf(<span class="hljs-string">&quot;Type: %s\n&quot;</span>, t) <span class="hljs-comment">// 输出: Type: int</span><br></code></pre></td></tr></table></figure><h3 id="reflect-Value-转换为-interface"><a href="#reflect-Value-转换为-interface" class="headerlink" title="reflect.Value 转换为 interface{}"></a><code>reflect.Value</code> 转换为 <code>interface&#123;&#125;</code></h3><h3 id="reflect包的核心组件"><a href="#reflect包的核心组件" class="headerlink" title="reflect包的核心组件"></a>reflect包的核心组件</h3><h4 id="Type接口"><a href="#Type接口" class="headerlink" title="Type接口"></a>Type接口</h4><p><code>reflect.Type</code> 实际上是一个接口，它提供很多 <code>api</code>(方法) 让你获取变量的各种信息。<code>reflect.TypeOf</code> 返回一个 <code>reflect.Type</code> 类型的值，这个值只包含了传入参数的类型信息。<code>reflect.Type</code> 描述了类型的各种特性，如类型名称、字段列表、方法集等，但它不包含任何具体的值信息。<code>reflect.Type</code> 主要用于类型检查和类型转换，例如：</p><ul><li>检查一个值是否是特定类型</li><li>在运行时创建新的值（例如使用 <code>reflect.New</code> 或 <code>reflect.MakeSlice</code>）</li><li>获取类型信息，如字段数量、字段名、字段类型等</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：使用Type接口</span><br>t := reflect.TypeOf(<span class="hljs-number">42</span>)<br>fmt.Println(t.Name()) <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>fmt.Println(t.Kind()) <span class="hljs-comment">// 输出 &quot;int&quot;</span><br></code></pre></td></tr></table></figure><p>不同类型可以使用的方法如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240722142418874.png?raw=true" alt="type方法"></p><p>每种类型可以使用的方法都是不一样的，错误的使用会引发 <code>panic</code></p><p>1.21版本已经支持slice的len方法</p><h4 id="Value结构"><a href="#Value结构" class="headerlink" title="Value结构"></a>Value结构</h4><p><code>reflect.ValueOf</code> 返回一个 <code>reflect.Value</code> 类型的值，这个值包含了传入参数的运行时信息，不仅包括类型信息，还包括具体的值。<code>reflect.Value</code> 提供了一组丰富的方法，允许你检查和修改值的各个方面，例如：</p><ul><li>调用方法</li><li>访问结构体字段</li><li>修改变量的值</li><li>检查变量是否可寻址</li><li>操作切片、数组、映射等复合类型</li></ul><p><code>reflect.ValueOf</code> 主要用于动态地操作和检查值，例如在运行时解析复杂的结构或执行类型无关的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：使用Value结构</span><br>v := reflect.ValueOf(<span class="hljs-number">42</span>)<br>fmt.Println(v.Type())  <span class="hljs-comment">// 输出 &quot;int&quot;</span><br>fmt.Println(v.Int())   <span class="hljs-comment">// 输出 42</span><br></code></pre></td></tr></table></figure><h3 id="反射的操作步骤"><a href="#反射的操作步骤" class="headerlink" title="反射的操作步骤"></a>反射的操作步骤</h3><p>在Go中进行反射操作通常涉及以下几个步骤：</p><ol><li><strong>获取<code>Type</code>和<code>Value</code></strong>: 使用**<code>reflect.TypeOf()</code><strong>和</strong><code>reflect.ValueOf()</code>**。</li><li><strong>类型和值的查询</strong>: 通过**<code>Type</code><strong>和</strong><code>Value</code>**接口方法。</li><li><strong>修改值</strong>: 使用**<code>Value</code><strong>的</strong><code>Set()</code>**方法（注意可导出性）。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：反射的操作步骤</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br> <br>v := reflect.ValueOf(x)<br>fmt.Println(<span class="hljs-string">&quot;Setting a value:&quot;</span>)<br>v.SetFloat(<span class="hljs-number">7.1</span>)  <span class="hljs-comment">// 运行时会报错，因为v不是可设置的（settable）</span><br></code></pre></td></tr></table></figure><p>使用反射（reflection）来操作变量时，需要确保你正在操作的值是可设置的（settable）。当你获取一个变量的反射值时，这个值默认是不可设置的，这意味着你不能直接修改它的值。为了能够修改一个值，你需要通过<code>reflect.ValueOf</code>获取一个指向该值的指针的反射值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br><br><span class="hljs-comment">// 获取指向x的指针的反射值</span><br>p := reflect.ValueOf(&amp;x).Elem()<br><br>fmt.Println(<span class="hljs-string">&quot;Setting a value:&quot;</span>)<br>p.SetFloat(<span class="hljs-number">7.1</span>) <span class="hljs-comment">// 这里可以成功设置新值，因为p现在是可设置的</span><br><br>fmt.Println(<span class="hljs-string">&quot;New value of x:&quot;</span>, x) <span class="hljs-comment">// 输出新的x值</span><br></code></pre></td></tr></table></figure><h3 id="动态方法调用和字段访问"><a href="#动态方法调用和字段访问" class="headerlink" title="动态方法调用和字段访问"></a>动态方法调用和字段访问</h3><p>反射不仅可以用于基础类型和结构体，还可以用于动态地调用方法和访问字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：动态方法调用</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SayHello() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, p.Name)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := &amp;Person&#123;Name: <span class="hljs-string">&quot;John&quot;</span>&#125;<br>    value := reflect.ValueOf(p)<br>    method := value.MethodByName(<span class="hljs-string">&quot;SayHello&quot;</span>)<br>    method.Call(<span class="hljs-literal">nil</span>)  <span class="hljs-comment">// 输出 &quot;Hello, my name is John&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射的底层机制"><a href="#反射的底层机制" class="headerlink" title="反射的底层机制"></a>反射的底层机制</h3><p>Go的反射实现依赖于底层的数据结构和算法，这些通常是不暴露给最终用户的。然而，了解这些可以帮助我们更加精确地掌握反射的工作原理。</p><h4 id="接口的内部结构"><a href="#接口的内部结构" class="headerlink" title="接口的内部结构"></a>接口的内部结构</h4><p>Go中的接口实际上是一个包含两个指针字段的结构体：一个指向值的类型信息，另一个指向值本身。</p><h4 id="反射API与底层的映射"><a href="#反射API与底层的映射" class="headerlink" title="反射API与底层的映射"></a>反射API与底层的映射</h4><p>**<code>reflect</code>**包的API其实是底层实现的一层封装，这样用户就不需要直接与底层数据结构和算法交互。</p><h2 id="5、基础操作"><a href="#5、基础操作" class="headerlink" title="5、基础操作"></a>5、基础操作</h2><h3 id="类型查询与断言"><a href="#类型查询与断言" class="headerlink" title="类型查询与断言"></a>类型查询与断言</h3><p>在反射中，获取对象的类型是最基础的操作之一。</p><h4 id="获取类型"><a href="#获取类型" class="headerlink" title="获取类型"></a>获取类型</h4><p>使用**<code>reflect.TypeOf()</code>**函数，你可以获得任何对象的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：获取类型</span><br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>t := reflect.TypeOf(str)<br>fmt.Println(t)  <span class="hljs-comment">// 输出 &quot;string&quot;</span><br></code></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>反射提供了一种机制，用于断言类型，并在运行时做出相应的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：类型断言</span><br>v := reflect.ValueOf(str)<br><span class="hljs-keyword">if</span> v.Kind() == reflect.String &#123;<br>    fmt.Println(<span class="hljs-string">&quot;The variable is a string!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字段与方法操作"><a href="#字段与方法操作" class="headerlink" title="字段与方法操作"></a>字段与方法操作</h3><p>反射可以用于动态地访问和修改对象的字段和方法。</p><h4 id="字段访问"><a href="#字段访问" class="headerlink" title="字段访问"></a>字段访问</h4><p><strong>通过值类型访问字段</strong></p><p>如果结构体实例是一个值类型，你可以直接使用<code>reflect.Value</code>的<code>Field</code>或<code>FieldByName</code>方法来访问其字段。但是，需要注意的是，如果你打算修改这些字段的值，那么结构体实例必须是可寻址的（即，你必须有指向这个结构体的指针，或者这个结构体是在可修改的上下文中定义的，如局部变量）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>Field1 <span class="hljs-type">string</span><br>Field2 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ms := MyStruct&#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">42</span>&#125;<br>v := reflect.ValueOf(ms)<br>field := v.FieldByName(<span class="hljs-string">&quot;Field1&quot;</span>)<br>fmt.Println(field.String()) <span class="hljs-comment">// 输出: Hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过指针类型访问字段</strong></p><p>如果结构体实例是通过指针访问的，或者你需要修改字段的值，那么你应当使用指向结构体的指针的<code>reflect.Value</code>，然后使用<code>Elem</code>方法获取指向结构体的值，再使用<code>Field</code>或<code>FieldByName</code>方法来访问字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>Field1 <span class="hljs-type">string</span><br>Field2 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ms := MyStruct&#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">42</span>&#125;<br>v := reflect.ValueOf(&amp;ms) <span class="hljs-comment">// 注意这里使用的是指向结构体的指针</span><br>elem := v.Elem()          <span class="hljs-comment">// 获取指向的结构体值</span><br>field := elem.FieldByName(<span class="hljs-string">&quot;Field1&quot;</span>)<br>fmt.Println(field.String()) <span class="hljs-comment">// 输出: Hello</span><br><br><span class="hljs-comment">// 修改字段的值</span><br>field.SetString(<span class="hljs-string">&quot;Goodbye&quot;</span>)<br>fmt.Println(ms.Field1) <span class="hljs-comment">// 输出: Goodbye</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：方法调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Student)</span></span> SayHello() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, s.Name)<br>&#125;<br>value.MethodByName(<span class="hljs-string">&quot;SayHello&quot;</span>).Call(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><h3 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h3><p>反射还可以用于动态地创建新的对象实例。</p><h4 id="创建基础类型"><a href="#创建基础类型" class="headerlink" title="创建基础类型"></a>创建基础类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：创建基础类型</span><br>v := reflect.New(reflect.TypeOf(<span class="hljs-number">0</span>)).Elem()<br>v.SetInt(<span class="hljs-number">42</span>)<br>fmt.Println(v.Int())  <span class="hljs-comment">// 输出 42</span><br></code></pre></td></tr></table></figure><h4 id="创建复杂类型"><a href="#创建复杂类型" class="headerlink" title="创建复杂类型"></a>创建复杂类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码示例：创建复杂类型</span><br>t := reflect.TypeOf(Student&#123;&#125;)<br>v := reflect.New(t).Elem()<br>v.FieldByName(<span class="hljs-string">&quot;Name&quot;</span>).SetString(<span class="hljs-string">&quot;Bob&quot;</span>)<br>v.FieldByName(<span class="hljs-string">&quot;Age&quot;</span>).SetInt(<span class="hljs-number">25</span>)<br>fmt.Println(v.Interface())  <span class="hljs-comment">// 输出 &#123;Bob 25&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6、reflect-DeepEqual函数"><a href="#6、reflect-DeepEqual函数" class="headerlink" title="6、reflect.DeepEqual函数"></a>6、reflect.DeepEqual函数</h2><p><strong>1、介绍</strong></p><p>在Go语言中，<code>reflect</code>包提供了一套功能强大的工具来检查、操作和修改程序的运行时表示。<code>reflect.DeepEqual</code>是<code>reflect</code>包中的一个重要函数，它用于判断两个值是否深度相等。</p><p><strong>2、<code>reflect.DeepEqual</code>的基本使用</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240807100325879.png?raw=true" alt="可使用类型"></p><p><strong>2.1 什么是深度相等？</strong></p><p>深度相等是一种<a href="https://so.csdn.net/so/search?q=%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">比较方法</a>，旨在检查两个值的所有层级是否完全一致。这不仅仅包括表面值的比较，还涉及到内部所有元素的递归比较。简单来说，如果两个变量在结构和内容上完全一致，那么它们就是深度相等的。</p><p>浅层相等主要用于比较变量的直接值或引用，而不关注其内部的元素或结构是否相同。这种比较方式通常适用于<a href="https://so.csdn.net/so/search?q=%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">简单数据类型</a>或需要快速判断引用是否相同的情况。</p><p><code>reflect.DeepEqual</code>函数可以比较任何类型的两个值，并确定它们是否在深度上相等。这意味着不仅比较基本类型的值，还会递归地比较复合类型的所有元素，如<a href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020">结构体</a>、切片、映射等。</p><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br>    b := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br><br>    fmt.Println(reflect.DeepEqual(a, b)) <span class="hljs-comment">// 输出: true</span><br><br>    c := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    d := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;<br><br>    fmt.Println(reflect.DeepEqual(c, d)) <span class="hljs-comment">// 输出: false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 深入理解<code>reflect.DeepEqual</code></strong></p><p><code>reflect.DeepEqual</code>函数的比较逻辑如下：</p><ol><li><strong>基本类型</strong>：直接比较值是否相等。</li><li><strong>数组</strong>：比较每个元素是否相等。</li><li><strong>切片</strong>：比较切片长度和每个元素是否相等。</li><li><strong>映射</strong>：比较键值对的数量和每个键对应的值是否相等。</li><li><strong>结构体</strong>：比较每个字段是否相等。</li><li><strong>指针</strong>：比较指针指向的值是否相等。</li><li><strong>接口</strong>：比较接口的动态类型和值是否相等。</li></ol><p><strong>4. <code>reflect.DeepEqual</code>的局限性</strong></p><p>尽管<code>reflect.DeepEqual</code>非常强大，但在某些情况下可能会有意想不到的结果：</p><ul><li><strong>未导出字段</strong>：对于结构体的未导出字段，<code>reflect.DeepEqual</code>无法访问，因此无法比较。</li><li><strong>函数比较</strong>：如果结构体或容器中包含函数，<code>reflect.DeepEqual</code>不会比较函数逻辑是否相同，只会比较函数指针是否相等。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t1 := T&#123;f: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;&#125;<br>    t2 := T&#123;f: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;&#125;<br><br>    fmt.Println(reflect.DeepEqual(t1, t2)) <span class="hljs-comment">// 输出: false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，尽管<code>t1</code>和<code>t2</code>的函数逻辑相同，但<code>reflect.DeepEqual</code>比较的是函数的指针，因此返回<code>false</code>。</p><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>虽然反射很灵活（几乎可以干任何事情），下面有三点建议：</p><ul><li>可以只使用 reflect.TypeOf 的话，就不要使用 reflect.ValueOf</li><li>可以使用断言代替的话，就不要使用反射</li><li>如果有可能应当避免使用反射</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gorm笔记</title>
    <link href="/2024/12/10/go/gorm%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/10/go/gorm%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="gorm笔记"><a href="#gorm笔记" class="headerlink" title="gorm笔记"></a>gorm笔记</h1><h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><p>Object Relational Mapping：对象关系映射</p><p>结构体 和 SQL数据库存在映射，这个时候就有了ORM语句</p><p>一句话说：就是将数据库中的表数据和结构体进行对应的关系</p><h2 id="ORM的优缺点"><a href="#ORM的优缺点" class="headerlink" title="ORM的优缺点"></a>ORM的优缺点</h2><p><strong>优点：</strong></p><ul><li>提高开发效率</li></ul><p><strong>缺点:</strong></p><ul><li>牺牲执行性能【中间多了一个环节】</li><li>牺牲灵活性</li><li>弱化SQL能力</li></ul><h2 id="GORM基本示例"><a href="#GORM基本示例" class="headerlink" title="GORM基本示例"></a>GORM基本示例</h2><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>GORM 会在内部管理连接池，而不是单个连接。当您使用 <code>gorm.Open</code> 方法打开数据库连接时，GORM 会自动创建并管理一个连接池，而不是仅仅创建一个连接。因此，您无需显式地关闭连接或管理连接生命周期，除非您想要显式地关闭整个连接池。</p><p><strong>插入数据和关闭连接</strong></p><ol><li><p><strong>插入数据</strong>:</p><ul><li>当您使用 GORM 的 <code>db.Create</code> 或其他相关方法（如 <code>Save</code>, <code>Model</code> 等）插入数据时，GORM 会自动管理事务和连接池。</li><li>不需要显式关闭连接。</li></ul></li><li><p><strong>关闭连接池</strong>:</p><ul><li><p>如果您想要显式地关闭整个连接池，可以使用 <code>db.Close</code> 方法。这通常在应用关闭时执行。</p></li><li><p>示例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">defer <span class="hljs-keyword">db</span>.<span class="hljs-keyword">Close</span>()<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="GORM操作MySQL"><a href="#GORM操作MySQL" class="headerlink" title="GORM操作MySQL"></a>GORM操作MySQL</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-comment">// UserInfo 用户信息</span><br><span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-type">uint</span><br>Name   <span class="hljs-type">string</span><br>Gender <span class="hljs-type">string</span><br>Hobby  <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dsn := <span class="hljs-string">&quot;root:@tcp(127.0.0.1:3306)/gorm?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 自动迁移</span><br>err = db.AutoMigrate(&amp;UserInfo&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to migrate&quot;</span>)<br>&#125;<br><br>u1 := UserInfo&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;杨洋&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>&#125;<br><br><span class="hljs-comment">// 创建记录 Create创建</span><br>db.Create(&amp;u1)<br>db.Create(&amp;UserInfo&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;王楚然&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;足球&quot;</span>&#125;)<br>    <br>    <span class="hljs-comment">// 创建记录 Save创建</span><br>    db.Save(&amp;u1)<br><span class="hljs-comment">// 查询</span><br><span class="hljs-keyword">var</span> u = <span class="hljs-built_in">new</span>(UserInfo)<br>db.First(&amp;u, <span class="hljs-number">1</span>) <span class="hljs-comment">// 根据整型主键查找</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, u)<br><br><span class="hljs-keyword">var</span> uu UserInfo<br>db.First(&amp;uu, <span class="hljs-string">&quot;hobby=?&quot;</span>, <span class="hljs-string">&quot;足球&quot;</span>) <span class="hljs-comment">//查找 hobby 字段值为 足球 的记录</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, uu)<br><br>    <span class="hljs-keyword">var</span> us []UserInfo<br>    db.Find(&amp;us)<br>fmt.Printf(<span class="hljs-string">&quot;us: %+v\n&quot;</span>, users)<br>    <br><span class="hljs-comment">// 更新 适合修改模型中的特定字段情况</span><br>db.Model(&amp;u).Update(<span class="hljs-string">&quot;hobby&quot;</span>, <span class="hljs-string">&quot;排球&quot;</span>)<br>    db.Model(&amp;u).Where(<span class="hljs-string">&quot;id=?&quot;</span>, <span class="hljs-number">3</span>).Update(<span class="hljs-string">&quot;hobby&quot;</span>, <span class="hljs-string">&quot;排球&quot;</span>)<br><span class="hljs-comment">//Update - 更新多个字段 适合修改模型中的特定字段情况</span><br>db.Model(&amp;u).Updates(UserInfo&#123;Name: <span class="hljs-string">&quot;肖战&quot;</span>, Hobby: <span class="hljs-string">&quot;跳舞&quot;</span>&#125;) <span class="hljs-comment">// 仅更新非零值字段</span><br>db.Model(&amp;uu).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Hobby&quot;</span>: <span class="hljs-string">&quot;演戏&quot;</span>, <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;赵丽颖&quot;</span>&#125;)<br><br><span class="hljs-comment">// 删除</span><br>db.Delete(&amp;u, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Save方法</strong></p><ul><li>用法：<code>db.Save(&amp;data)</code></li><li>功能：根据提供的数据对象（结构体）执行插入或更新操作。如果提供的对象已经存在于数据库中（基于主键或唯一索引），则会执行更新操作；否则，会执行插入操作。</li><li>如果数据对象包含了主键或唯一索引字段，则 GORM 将使用这些字段来决定是执行插入还是更新操作。</li><li>在执行保存操作后，<code>Save</code> 方法会返回一个 <code>*gorm.DB</code> 对象，可以通过该对象的 <code>Error</code> 属性来检查是否发生错误。</li></ul><p><strong>Create方法</strong></p><ul><li>用法：<code>db.Create(&amp;data)</code></li><li>功能：将提供的数据对象插入到数据库中。它与 <code>Save</code> 方法的区别在于，它只执行插入操作，不会尝试进行更新操作。</li><li><code>Create</code> 方法会忽略数据对象中的主键和唯一索引字段，而是使用数据库生成的默认值（如自增 ID）或随机值来填充这些字段。</li><li>类似于 <code>Save</code> 方法，<code>Create</code> 方法也返回一个 <code>*gorm.DB</code> 对象，可以通过该对象的 <code>Error</code> 属性来检查是否发生错误。</li></ul><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><p>在 GORM 框架中，<code>Row</code>, <code>Exec</code>, 以及相关的函数被用来执行原始 SQL 查询或命令。这些方法允许你在 GORM 的 ORM 抽象之上直接使用 SQL，这对于需要更细粒度控制或执行无法通过 GORM ORM 方法轻易表达的复杂查询时特别有用。</p><ol><li><p><strong>Row</strong></p><ul><li><p><code>Row</code> 方法用于执行 SELECT 查询，并返回一个 <code>*sql.Row</code> 对象，这个对象可以用来扫描单行结果。如果查询返回多行，<code>Row</code> 将只返回第一行。、</p></li><li><p>使用 <code>Row</code> 后，需要调用 <code>Scan</code> 方法来将数据库查询的结果映射到 Go 结构体中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br>db.Raw(<span class="hljs-string">&quot;SELECT name FROM users WHERE id = ?&quot;</span>, <span class="hljs-number">1</span>).Row().Scan(&amp;name)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Rows</strong>:</p><ul><li><p><code>Rows</code> 方法也用于执行 SELECT 查询，但它返回一个 <code>*sql.Rows</code> 对象，可以迭代多行结果。</p></li><li><p>使用 <code>Rows</code> 后，可以循环遍历结果集，直到所有行都被读取完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">rows := db.Raw(<span class="hljs-string">&quot;SELECT name FROM users&quot;</span>).Rows()<br><span class="hljs-keyword">defer</span> rows.Close()<span class="hljs-comment">//关闭一个由sql.Rows类型表示的结果集</span><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>    <span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br>    err := rows.Scan(&amp;name)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 处理错误</span><br>    &#125;<br>    fmt.Println(name)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*sql.Rows对象维护了一个到数据库的活动连接，使得你可以逐行地扫描结果集。然而，这也会占用数据库连接池中的一个连接。一旦你完成了对结果集的操作，就应该调用rows.Close()方法来释放这个连接，让它可以被连接池重用，或者返回给数据库，以便其他查询可以使用。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Exec：</strong></p><ul><li><p><code>Exec</code> 方法用于执行不返回结果集的 SQL 命令，如 INSERT, UPDATE, DELETE 或其他 DDL（数据定义语言）语句。</p></li><li><p>它返回一个 <code>sql.Result</code> 对象，可以用来获取受影响的行数或最后插入的 ID。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">result := db.Exec(<span class="hljs-string">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>, <span class="hljs-string">&quot;New Name&quot;</span>, <span class="hljs-number">1</span>)<br>affected, _ := result.RowsAffected()<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="连接池（Connection-Pooling）"><a href="#连接池（Connection-Pooling）" class="headerlink" title="连接池（Connection Pooling）"></a>连接池（Connection Pooling）</h3><p>Gorm默认使用了数据库连接池，但我们也可以手动配置连接池的大小和其他参数。在初始化数据库连接时，可以指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;maxidleconns&quot;</span>:    <span class="hljs-number">10</span>,               <span class="hljs-comment">//最大空闲连接数</span><br><span class="hljs-string">&quot;maxopenconns&quot;</span>:    <span class="hljs-number">100</span>,              <span class="hljs-comment">//连接池中允许的最大连接数</span><br><span class="hljs-string">&quot;connmaxlifetime&quot;</span>: <span class="hljs-number">10</span> * time.Minute, <span class="hljs-comment">//单个连接的最大存活时间</span><br></code></pre></td></tr></table></figure><p>连接池的实现原理主要包括连接的获取、归还和回收三个环节。当应用程序需要数据库连接时，连接池会优先返回一个空闲连接，如果没有可用的连接则创建一个新连接；当连接使用完毕后，应用程序会将连接归还给连接池，而不是销毁连接；连接池还会定时检测连接的健康状态，对不可用的连接进行回收和重建。</p><p>在Gorm中，连接池的管理由底层数据库驱动实现，开发者可以通过Gorm提供的接口进行连接池的配置和使用，而无需关心具体的实现细节。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Demo for gorm</span><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm/logger&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// DbConfig 使用字面量语法初始化配置</span><br><span class="hljs-keyword">var</span> DbConfig = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;ip&quot;</span>:              <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br><span class="hljs-string">&quot;port&quot;</span>:            <span class="hljs-string">&quot;13306&quot;</span>,<br><span class="hljs-string">&quot;user&quot;</span>:            <span class="hljs-string">&quot;root&quot;</span>,<br><span class="hljs-string">&quot;password&quot;</span>:        <span class="hljs-string">&quot;Super000&quot;</span>,<br><span class="hljs-string">&quot;dbname&quot;</span>:          <span class="hljs-string">&quot;test&quot;</span>,<br><span class="hljs-string">&quot;maxidleconns&quot;</span>:    <span class="hljs-number">10</span>,               <span class="hljs-comment">//最大空闲连接数</span><br><span class="hljs-string">&quot;maxopenconns&quot;</span>:    <span class="hljs-number">100</span>,              <span class="hljs-comment">//连接池中允许的最大连接数</span><br><span class="hljs-string">&quot;connmaxlifetime&quot;</span>: <span class="hljs-number">10</span> * time.Minute, <span class="hljs-comment">//单个连接的最大存活时间</span><br>&#125;<br><br><span class="hljs-comment">// 获取mysql</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMysql</span><span class="hljs-params">()</span></span> (*gorm.DB, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 构建 DSN</span><br>dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,<br>DbConfig[<span class="hljs-string">&quot;user&quot;</span>].(<span class="hljs-type">string</span>),<br>DbConfig[<span class="hljs-string">&quot;password&quot;</span>].(<span class="hljs-type">string</span>),<br>DbConfig[<span class="hljs-string">&quot;ip&quot;</span>].(<span class="hljs-type">string</span>),<br>DbConfig[<span class="hljs-string">&quot;port&quot;</span>].(<span class="hljs-type">string</span>),<br>DbConfig[<span class="hljs-string">&quot;dbname&quot;</span>].(<span class="hljs-type">string</span>),<br>)<br><span class="hljs-comment">// 打开数据库连接</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;<br>Logger: logger.Default.LogMode(logger.Info),<br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;连接数据库失败：%w&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 设置连接池参数</span><br>sqlDB, err := db.DB()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;获取底层 SQL DB 失败：%w&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 设置连接池参数</span><br>sqlDB.SetMaxIdleConns(DbConfig[<span class="hljs-string">&quot;maxidleconns&quot;</span>].(<span class="hljs-type">int</span>))<br>sqlDB.SetMaxOpenConns(DbConfig[<span class="hljs-string">&quot;maxopenconns&quot;</span>].(<span class="hljs-type">int</span>))<br>sqlDB.SetConnMaxLifetime(DbConfig[<span class="hljs-string">&quot;connmaxlifetime&quot;</span>].(time.Duration))<br><br><span class="hljs-keyword">return</span> db, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primary_key;column:user_name;type:varchar(100);&quot;`</span><br><span class="hljs-comment">//Age  int    `gorm:&quot;column:age;type:int&quot;`</span><br>Class <span class="hljs-type">int</span> <span class="hljs-string">`gorm:&quot;column:class;type:int&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;users&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db, err := getMysql()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;连接数据库失败: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 自动迁移(表中缺少迁移映射的结构体字段 会增加到table中，table中多于的字段不会删除，数据无影响)</span><br>err = db.AutoMigrate(&amp;User&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;自动迁移失败: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>sqlDB, err := db.DB()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;获取数据库连接失败: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> sqlDB.Close()<br>fmt.Println(<span class="hljs-string">&quot;正式退出&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="会话（Sessions）"><a href="#会话（Sessions）" class="headerlink" title="会话（Sessions）"></a>会话（Sessions）</h3><p>会话在GORM中指的是对数据库连接的一次使用过程，它允许你设置特定于本次会话的行为，例如禁用默认事务、设置只读模式等。使用会话可以让你在不改变全局配置的情况下，针对特定的操作定制行为。</p><p>例如，如果你希望在某次操作中禁用默认事务，可以创建一个带有特定配置的会话：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">session := db.Session(&amp;gorm.Session&#123;SkipDefaultTransaction: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><p>然后使用这个<code>session</code>变量执行数据库操作。</p><h3 id="事务（Transactions）"><a href="#事务（Transactions）" class="headerlink" title="事务（Transactions）"></a>事务（Transactions）</h3><p>GORM支持数据库事务，事务是数据库操作的一个单元，它能确保一系列操作要么全部成功，要么全部失败。这对于需要保持数据一致性的操作至关重要，例如在转账场景中，从一个账户扣款同时需要向另一个账户加款，这两个操作必须一起成功或失败。</p><p>在GORM中，你可以使用<code>Transaction</code>函数来启动一个新的事务上下文，该函数接受一个回调函数，所有在该回调中执行的数据库操作都将纳入同一个事务中。如果回调函数执行成功，则事务会被提交；如果发生错误，则事务会被回滚（默认自动）。示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/jinzhu/gorm&quot;</span><br>_ <span class="hljs-string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span><br>)<br><br><span class="hljs-comment">// Account 用户账户模型</span><br><span class="hljs-keyword">type</span> Account <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>UserID    <span class="hljs-type">uint</span>   <span class="hljs-comment">// 用户ID</span><br>Balance   <span class="hljs-type">float64</span> <span class="hljs-comment">// 账户余额</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 初始化数据库连接（请根据实际情况替换DSN）</span><br>db, err := gorm.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> db.Close()<br><br><span class="hljs-comment">// 自动迁移模型</span><br>db.AutoMigrate(&amp;Account&#123;&#125;)<br><br><span class="hljs-comment">// 准备数据：假设已经存在两个用户账户</span><br>accountFrom := Account&#123;UserID: <span class="hljs-number">1</span>, Balance: <span class="hljs-number">1000</span>&#125;<br>accountTo := Account&#123;UserID: <span class="hljs-number">2</span>, Balance: <span class="hljs-number">500</span>&#125;<br>db.Create(&amp;accountFrom)<br>db.Create(&amp;accountTo)<br><br><span class="hljs-comment">// 定义转账金额</span><br>transferAmount := <span class="hljs-number">300</span><br><br><span class="hljs-comment">// 开始事务处理转账</span><br>err = db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查转出账户余额是否足够</span><br><span class="hljs-keyword">var</span> fromAccount Account<br><span class="hljs-keyword">if</span> err := tx.Where(<span class="hljs-string">&quot;user_id = ?&quot;</span>, accountFrom.UserID).First(&amp;fromAccount).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果查询出错，直接返回错误，GORM将会自动回滚事务</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> fromAccount.Balance &lt; transferAmount &#123;<br><span class="hljs-comment">// 如果余额不足，返回一个错误，这也将导致事务回滚</span><br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;insufficient balance in the sender&#x27;s account&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 更新账户余额</span><br><span class="hljs-keyword">if</span> err := tx.Model(&amp;Account&#123;&#125;).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, fromAccount.ID).Update(<span class="hljs-string">&quot;balance&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;balance - ?&quot;</span>, transferAmount)).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 更新操作失败，错误被返回后，GORM将自动执行事务回滚</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx.Model(&amp;Account&#123;&#125;).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, accountTo.ID).Update(<span class="hljs-string">&quot;balance&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;balance + ?&quot;</span>, transferAmount)).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 同样，这里的错误也会触发事务回滚</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 如果一切顺利，不返回任何错误（即返回nil），GORM将会自动提交事务</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Transaction failed and was rolled back: %v\n&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Transaction completed successfully and was committed.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 事务后的其他操作...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在GORM中，虽然事务处理通常是通过提供一个回调函数给<code>Transaction</code>方法来自动管理提交和回滚的，但如果你需要更细粒度的手动控制事务流程（尽管这在GORM中不常见），可以通过直接操作底层的<code>*sql.Tx</code>对象来实现。下面的示例展示了如何手动开始、提交或回滚事务：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-comment">// Account 用户账户模型</span><br><span class="hljs-keyword">type</span> Account <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>UserID    <span class="hljs-type">uint</span>   <span class="hljs-comment">// 用户ID</span><br>Balance   <span class="hljs-type">float64</span> <span class="hljs-comment">// 账户余额</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dsn := <span class="hljs-string">&quot;user:password@tcp(localhost:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to connect database: %v&quot;</span>, err)<br>&#125;<br>sqlDB, err := db.DB()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to get *sql.DB instance: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> sqlDB.Close()<br><br><span class="hljs-comment">// 自动迁移模型</span><br>db.AutoMigrate(&amp;Account&#123;&#125;)<br><br><span class="hljs-comment">// 准备数据：假设已经存在两个用户账户</span><br>accountFrom := Account&#123;UserID: <span class="hljs-number">1</span>, Balance: <span class="hljs-number">1000</span>&#125;<br>accountTo := Account&#123;UserID: <span class="hljs-number">2</span>, Balance: <span class="hljs-number">500</span>&#125;<br>db.Create(&amp;accountFrom)<br>db.Create(&amp;accountTo)<br><br><span class="hljs-comment">// 定义转账金额</span><br>transferAmount := <span class="hljs-number">300</span><br><br><span class="hljs-comment">// 手动开始事务</span><br>tx, err := sqlDB.Begin()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to begin transaction: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 在事务中执行操作</span><br><span class="hljs-keyword">var</span> fromAccount Account<br><span class="hljs-keyword">if</span> err := db.WithContext(tx.Context()).Where(<span class="hljs-string">&quot;user_id = ?&quot;</span>, accountFrom.UserID).First(&amp;fromAccount).Error; err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Error querying account: %v&quot;</span>, err)<br>tx.Rollback() <span class="hljs-comment">// 查询出错，手动回滚事务</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> fromAccount.Balance &lt; transferAmount &#123;<br>log.Println(<span class="hljs-string">&quot;Insufficient balance&quot;</span>)<br>tx.Rollback() <span class="hljs-comment">// 余额不足，手动回滚事务</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := db.WithContext(tx.Context()).Model(&amp;Account&#123;&#125;).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, fromAccount.ID).Update(<span class="hljs-string">&quot;balance&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;balance - ?&quot;</span>, transferAmount)).Error; err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Error deducting from account: %v&quot;</span>, err)<br>tx.Rollback() <span class="hljs-comment">// 更新失败，手动回滚事务</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := db.WithContext(tx.Context()).Model(&amp;Account&#123;&#125;).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, accountTo.ID).Update(<span class="hljs-string">&quot;balance&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;balance + ?&quot;</span>, transferAmount)).Error; err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Error adding to account: %v&quot;</span>, err)<br>tx.Rollback() <span class="hljs-comment">// 更新失败，手动回滚事务</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 所有操作成功，手动提交事务</span><br><span class="hljs-keyword">if</span> err := tx.Commit(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to commit transaction: %v&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Transaction completed successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1、-数据库连接池的配置"><a href="#1、-数据库连接池的配置" class="headerlink" title="1、 数据库连接池的配置"></a>1、 数据库连接池的配置</h3><p>Go 的 <code>database/sql</code> 包提供了连接池的功能，您可以通过设置最大空闲连接、最大打开连接数和连接的最大生命周期来优化连接池。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">db, err := sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/dbname&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 设置最大空闲连接数</span><br>db.SetMaxIdleConns(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// 设置最大打开连接数</span><br>db.SetMaxOpenConns(<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// 设置连接的最大生命周期</span><br>db.SetConnMaxLifetime(time.Hour)<br></code></pre></td></tr></table></figure><h3 id="2、使用连接池"><a href="#2、使用连接池" class="headerlink" title="2、使用连接池"></a>2、使用连接池</h3><p>合理的连接池配置可以减少每次请求数据库的延迟，并且减少数据库服务器的负载。</p><ul><li><strong>SetMaxIdleConns</strong>: 设置连接池中的最大空闲连接数。保持一些空闲连接可以使应用程序更快地响应新的连接请求。</li><li><strong>SetMaxOpenConns</strong>: 设置数据库的最大连接数。限制最大连接数可以防止数据库服务器因过多的连接而过载。</li><li><strong>SetConnMaxLifetime</strong>: 设置连接可以重用的最长时间。定期刷新连接可以避免使用长期连接带来的问题。</li></ul><h3 id="3、高效的查询和索引"><a href="#3、高效的查询和索引" class="headerlink" title="3、高效的查询和索引"></a>3、高效的查询和索引</h3><p>确保您的 SQL 查询是高效的，并且数据库表上有适当的索引。</p><ul><li><strong>索引</strong>: 为频繁查询的列创建索引可以显著提高查询性能。</li><li><strong>查询优化</strong>: 使用 <code>EXPLAIN</code> 分析查询，确保查询使用了索引，并尽量减少全表扫描。</li></ul><h3 id="4、-避免过多的事务"><a href="#4、-避免过多的事务" class="headerlink" title="4、 避免过多的事务"></a>4、 避免过多的事务</h3><p>尽量减少事务的使用次数，并确保事务尽可能短，以减少数据库锁的时间。</p><h3 id="5、使用准备好的语句"><a href="#5、使用准备好的语句" class="headerlink" title="5、使用准备好的语句"></a>5、<strong>使用准备好的语句</strong></h3><p>准备好的语句（prepared statements）可以提高性能并增加安全性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">stmt, err := db.Prepare(<span class="hljs-string">&quot;SELECT name FROM users WHERE age = ?&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> stmt.Close()<br><br>rows, err := stmt.Query(<span class="hljs-number">25</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> rows.Close()<br><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>    <span class="hljs-comment">// 处理结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、分批处理数据"><a href="#6、分批处理数据" class="headerlink" title="6、分批处理数据"></a>6、分批处理数据</h3><p>对于需要处理大量数据的情况，分批处理可以减少内存使用并提高性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">rows, err := db.Query(<span class="hljs-string">&quot;SELECT * FROM large_table LIMIT ? OFFSET ?&quot;</span>, batchSize, offset)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> rows.Close()<br><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>    <span class="hljs-comment">// 处理每一行</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-监控和调试"><a href="#7-监控和调试" class="headerlink" title="7. 监控和调试"></a>7. 监控和调试</h3><p>使用监控工具和日志记录来监控数据库性能，并及时发现和解决瓶颈。</p><ul><li><strong>Prometheus</strong> 和 <strong>Grafana</strong>: 可以用于监控数据库和应用程序的性能指标。</li><li><strong>日志记录</strong>: 记录慢查询日志和错误日志，以便排查问题。</li></ul><p>通过合理配置 <code>sql.DB</code> 和优化数据库查询，可以显著提高 Go 应用程序的数据库性能。</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go性能分析工具pprof</title>
    <link href="/2024/12/10/go/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof/"/>
    <url>/2024/12/10/go/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7pprof/</url>
    
    <content type="html"><![CDATA[<h1 id="Go性能分析工具pprof"><a href="#Go性能分析工具pprof" class="headerlink" title="Go性能分析工具pprof"></a>Go性能分析工具pprof</h1><h2 id="一、什么是pprof"><a href="#一、什么是pprof" class="headerlink" title="一、什么是pprof"></a>一、什么是pprof</h2><p>pprof是Go官方提供的性能分析工具，可以分析程序的运行情况，并且提供可视化的功能。prof是profile（画像）的缩写，使用pprof可以分析以下几种指标数据：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/f8aa6b1a10b845b1d0cc81ec241ca451.png?raw=true" alt="f8aa6b1a10b845b1d0cc81ec241ca451"></p><ul><li><code>allocs</code>：程序启动之后内存分配的情况</li><li><code>block</code>：导致阻塞操作的一些堆栈跟踪信息</li><li><code>cmdline</code>：当前程序启动的命令行</li><li><code>goroutine</code>：所有当前 <code>goroutine</code> 的堆栈跟踪信息</li><li><code>heap</code>：程序在当前堆上内存分配的情况</li><li><code>mutex</code>：锁资源的竞争的堆栈信息</li><li><code>profile</code>：<code>CPU profile</code>文件。可以在 <code>debug/pprof?seconds=x秒</code> <code>GET</code> 参数中指定持续时间。获取<code>pprof</code>文件后，使用 <code>go tool pprof x.prof</code>命令分析<code>pprof</code>文件。</li><li><code>threadcreate</code>：系统线程的使用情况</li><li><code>trace</code>：当前系统的代码执行的链路情况</li></ul><p>使用<code>pprof</code>工具主要分析以下几种指标：</p><ul><li><code>CPU Profiling</code>：<code>CPU</code> 分析，按照一定的频率采集所监听的应用程序 <code>CPU</code>（含寄存器）的使用情况，可确定应用程序在主动消耗 <code>CPU</code> 周期时花费时间的位置</li><li><code>Memory Profiling</code>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li><li><code>Block Profiling</code>：阻塞分析，记录 <code>goroutine</code> 阻塞等待同步（包括定时器通道）的位置</li><li><code>Mutex Profiling</code>：互斥锁分析，报告互斥锁的竞争情况。</li></ul><p>当程序存在内存或者<code>CPU</code>飙升的情况时，我们可以通过<code>pprof</code>工具来查询问题出现的根源。</p><h2 id="二、怎么使用pprof"><a href="#二、怎么使用pprof" class="headerlink" title="二、怎么使用pprof"></a>二、怎么使用pprof</h2><p>pprof包含两个相关的库：</p><ol><li><code>runtime/pprof</code><br>主要应用于工具型应用。包含脚本、定时任务等。<br>如：对于只跑一次的程序，例如每天只跑一次的离线预处理程序，调用 pprof 包提供的函数，手动开启性能数据采集</li><li><code>net/http/pprof</code><br>主要应用于服务型应用。包含HTTP服务，GRPC服务等。<br>如：对于在线服务，对于一个 HTTP Server，访问 pprof 提供的 HTTP 接口，获得性能数据。当然，实际上这里底层也是调用的 <code>runtime/pprof</code>提供的函数，封装成接口对外提供网络访问。</li></ol><h3 id="1-工具型应用"><a href="#1-工具型应用" class="headerlink" title="1. 工具型应用"></a>1. 工具型应用</h3><p>工具型应用主要使用<code>runtime/pprof</code>包实现性能分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// --- cpu 分析示例 start---</span><br><span class="hljs-comment">// 创建cpu分析文件</span><br>fc, err := os.Create(<span class="hljs-string">&quot;./cpu.prof&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;create cpu.prof err:&quot;</span>, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> fc.Close()<br><br><span class="hljs-comment">// 开始分析cpu</span><br>err = pprof.StartCPUProfile(fc)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()<br>&#125;<br><span class="hljs-comment">// --- cpu 分析示例 end---</span><br><br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>count++<br>&#125;<br><br><span class="hljs-comment">// --- 内存 分析示例 start---</span><br>fm, err := os.Create(<span class="hljs-string">&quot;./memory.prof&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;create memory.prof err:&quot;</span>, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> fm.Close()<br><br><span class="hljs-comment">// 开始分析内存</span><br>err = pprof.WriteHeapProfile(fm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;write heap prof err:&quot;</span>, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// --- 内存 分析示例 end---</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>count++<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;do finish......count:&quot;</span>, count)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行 <code>go run main.go</code> 后，在代码目录下，可以看到生成了 cpu.prof 和menory.prof文件</p><p>通过执行 <code>go tool pprof ./memory.prof</code> 或者 <code>go tool pprof -http=8888 ./memory.prof </code> 进入命令行模式或者web页面进行性能分析</p><p>执行 <code>go tool pprof ./memory.prof</code> 进入命令行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">gond@gond-UM690:~/work/go_work/study/pprof$ <span class="hljs-keyword">go</span> tool pprof ./memory.prof <br>File: ___go_build_pprofDemo1_go<span class="hljs-comment">// File: 表示当前分析的文件是 ___go_build_pprofDemo1_go。</span><br>Type: inuse_space<span class="hljs-comment">// Type: 表示当前展示的是内存使用情况（inuse_space），即当前使用的内存空间。</span><br>Time: Sep <span class="hljs-number">5</span>, <span class="hljs-number">2024</span> at <span class="hljs-number">3</span>:<span class="hljs-number">51</span>pm (CST)<span class="hljs-comment">// Time: 表示该分析文件的生成时间。</span><br>Entering interactive mode (<span class="hljs-keyword">type</span> <span class="hljs-string">&quot;help&quot;</span> <span class="hljs-keyword">for</span> commands, <span class="hljs-string">&quot;o&quot;</span> <span class="hljs-keyword">for</span> options)<span class="hljs-comment">// 进入交互模式，可以输入各种命令来进一步分析数据。例如，输入 help 可以查看可用命令列表，输入 o 可以查看和设置选项。</span><br>(pprof) <br>(pprof) top<span class="hljs-comment">// top 命令展示了内存使用情况的前几条记录。</span><br>Showing nodes accounting <span class="hljs-keyword">for</span> <span class="hljs-number">1.16</span>MB, <span class="hljs-number">100</span>% of <span class="hljs-number">1.16</span>MB total<br>      flat  flat%   sum%        cum   cum%<span class="hljs-comment">// flat: 表示该函数自己使用的内存空间。</span><br>    <span class="hljs-number">1.16</span>MB   <span class="hljs-number">100</span>%   <span class="hljs-number">100</span>%     <span class="hljs-number">1.16</span>MB   <span class="hljs-number">100</span>%  runtime/pprof.StartCPUProfile  <span class="hljs-comment">//flat%: 表示该函数自己使用的内存占总内存的比例。</span><br>         <span class="hljs-number">0</span>     <span class="hljs-number">0</span>%   <span class="hljs-number">100</span>%     <span class="hljs-number">1.16</span>MB   <span class="hljs-number">100</span>%  main.main<span class="hljs-comment">// sum%: 表示累计到该函数为止的内存使用比例。</span><br>         <span class="hljs-number">0</span>     <span class="hljs-number">0</span>%   <span class="hljs-number">100</span>%     <span class="hljs-number">1.16</span>MB   <span class="hljs-number">100</span>%  runtime.main<span class="hljs-comment">// cum: 表示累积到该函数为止的总内存使用量</span><br><span class="hljs-comment">// cum%: 表示累积到该函数为止的内存使用量占总内存的比例。</span><br><span class="hljs-comment">// 函数名：表示调用栈中的函数。</span><br></code></pre></td></tr></table></figure><p>安装组件，系统ubuntu, <code>sudo apt install graphviz</code>，执行<code>go tool pprof -http=:8888 ./memory.prof</code>可进入<code>web</code>页面，更方便查看：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240905163023564.png?raw=true" alt="image-20240905163023564"></p><p>SAMPLE各个标签的含义解释：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>inuse_space</td><td>表示当前正在使用的内存空间总量。这通常是已经分配给应用程序的对象占用的空间，不包括已经被释放的空间</td></tr><tr><td>inuse_objects</td><td>表示当前正在使用的对象数量。这指的是已经被分配且尚未被垃圾回收器回收的对象数</td></tr><tr><td>alloc_space</td><td>表示自程序启动以来，总的分配内存空间。这包括了所有已经分配过的内存，无论这些内存是否已经被释放。</td></tr><tr><td>alloc_objects</td><td>表示自程序启动以来，总共分配的对象数量。这包括了所有已经创建的对象，即使某些对象可能已经被垃圾回收。</td></tr></tbody></table><h3 id="2-服务型应用"><a href="#2-服务型应用" class="headerlink" title="2. 服务型应用"></a>2. 服务型应用</h3><p>对于服务类型的应用，主要在服务内部匿名引入<code>net/http/pprof</code>包，然后通过<code>HTTP</code>访问<code>pprof</code>页面。<br>匿名引入方式为：<code>import _ &quot;net/http/pprof&quot;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, hello)<br>err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ListenAndServe Err:&quot;</span>, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello World, Are You OK?&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行<code>http://localhost:8080/debug/pprof/</code>可以看到画像信息：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240905163831774.png?raw=true" alt="image-20240905163831774"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">allocs: 所有过去内存分配的采样。<br>block: 导致在同步原语上阻塞的栈跟踪。<br>cmdline: 当前程序的命令行调用。<br>goroutine: 所有当前 goroutine 的栈跟踪。使用 debug=<span class="hljs-number">2</span> 作为查询参数导出为未恢复恐慌时相同的格式。<br>heap: 活动对象的内存分配采样。可以通过指定 gc GET 参数来在获取堆样本之前运行垃圾收集。<br>mutex: 争用互斥锁的持有者的栈跟踪。<br>profile: CPU 剖析文件。可以在 GET 参数中指定持续时间（秒）。获取剖析文件后，使用 <span class="hljs-keyword">go</span> tool pprof 命令来分析该剖析文件。<br>threadcreate: 导致创建新的操作系统线程的栈跟踪。<br>trace: 当前程序执行的追踪。可以在 GET 参数中指定持续时间（秒）。获取追踪文件后，使用 <span class="hljs-keyword">go</span> tool trace 命令来分析该追踪文件。<br></code></pre></td></tr></table></figure><p>但是需要注意，如果HTTP服务不是通过<br><code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>启动的，而是指定第二个参数启动的话，需要自己注册<code>pprof</code>路由。</p><p>在<code>net/http/pprof/pprof.go</code>的官方源码注释中也提到此种情况：</p><blockquote><p>If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.<br>如果您不使用DefaultServeMux，则必须向所使用的多路复用器注册pprof处理程序<br>http.ListenAndServe函数可以传递handler，如果handler不为nil，则说明研发自定义了 ServeMux，否则用的是默认DefaultServeMux</p></blockquote><p><code>net/http/pprof</code>包中，有<code>init</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>   http.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/&quot;</span>, Index)<br>   http.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)<br>   http.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/profile&quot;</span>, Profile)<br>   http.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/symbol&quot;</span>, Symbol)<br>   http.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/trace&quot;</span>, Trace)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以如果使用默认<code>ServeMux</code>，则不需要注册，但是如果使用自定义的<code>ServeMux</code>，则需要增加注册后，才能获取到<code>pprof</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 自己注册这几个函数</span><br>r.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/&quot;</span>, pprof.Index)<br>r.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)<br>r.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)<br>r.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)<br>r.HandleFunc(<span class="hljs-string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)<br></code></pre></td></tr></table></figure><p>另外一种启动<code>pprof</code>的方式在生产环境中更加常用：通过协程另起一个<code>HTTP</code>服务，单独用作<code>pprof</code>分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterProf</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:6060&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;pprof server start error: &quot;</span> + err.Error())<br>&#125;<br>&#125;()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="三、pprof数据分析"><a href="#三、pprof数据分析" class="headerlink" title="三、pprof数据分析"></a>三、<code>pprof</code>数据分析</h2><p><code>GO</code>官方提供了<code>go tool pprof</code>工具来帮助我们分析<code>pprof</code>生成的数据文件。<br>使用<code>go tool pprof</code>分析数据，主要有两种模式：</p><ol><li>命令行交互模式<br><code>go tool pprof [file_pprof|url_pprof]</code></li><li>web页面模式<br><code>go tool pprof -http=:6666 [file_pprof|url_pprof]</code><br>其中，<code>file_pprof</code>表示生成的<code>prof</code>分析文件，如<code>cpu.prof</code>；<code>url_pprof</code>表示远端服务开启的<code>pprof</code>访问，如<code>http://localhost:8080/debug/pprof/profile</code></li></ol><p>进入命令行交互模式后，可以使用<code>help</code>查看所有子命令，使用<code>help &lt;cmd|option&gt;</code>查看子命令使用方法。如 <code>help、help top</code>等</p><h3 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h3><p>浏览器访问<code>/debug/pprof/profile</code>会自动进行 <code>CPU profiling</code>，默认持续 30s，并生成一个文件供下载，可以通过带参数<code>?seconds=60</code>进行<code>60</code>秒的数据采集。</p><p>为了模拟请求，使用ab进行压测，<br><code>ab -k -c 1 -t 180 -n 100000000 http://localhost:8080/hello</code></p><p>执行<code>go tool pprof http://localhost:8080/debug/pprof/profile</code>后，默认需要等30s才会显示交互</p><h4 id="list指令分析函数"><a href="#list指令分析函数" class="headerlink" title="list指令分析函数"></a>list指令分析函数</h4><p>确定出哪个函数耗时之后，可以用<code>pprof</code>分析函数中的哪一行导致的耗时，使用子命令：list 函数名。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240905165839736.png?raw=true" alt="image-20240905165839736"></p><h4 id="堆内存分析示例"><a href="#堆内存分析示例" class="headerlink" title="堆内存分析示例"></a>堆内存分析示例</h4><p>内存分配既可以发生在堆上也可以在栈上。堆上分配的内存需要垃圾回收或者手动回收（对于没有垃圾回收的语言，例如 C++），栈上的内存则通常在函数退出后自动释放。</p><p>Go 语言通过逃逸分析会将尽可能多的对象分配到栈上，以使程序可以运行地更快。</p><p>这里说明一下，有两种内存分析策略：一种是当前的（这一次采集）内存或对象的分配，称为 <code>inuse</code>；另一种是从程序运行到现在所有的内存分配，不管是否已经被 <code>gc</code>过了，称为 <code>alloc</code>。</p><p>加上 -sample_index 参数后，可以切换内存分析的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> tool pprof -sample_index=alloc_space http:<span class="hljs-comment">//localhost:8080/debug/pprof/heap</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> tool pprof -alloc_space http:<span class="hljs-comment">//localhost:8080/debug/pprof/heap</span><br></code></pre></td></tr></table></figure><h2 id="四、pprof数据分析类型汇总"><a href="#四、pprof数据分析类型汇总" class="headerlink" title="四、pprof数据分析类型汇总"></a>四、pprof数据分析类型汇总</h2><p>其他数据的分析和<code>CPU</code>的基本一致。下面列举所有的分类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">http:<span class="hljs-comment">//localhost:8080/debug/pprof/ ：获取概况信息，即本文第一张图的信息</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/allocs : 分析内存分配</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/block : 分析堆栈跟踪导致阻塞的同步原语</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/cmdline : 分析命令行调用的程序，web下调用报错</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/goroutine : 分析当前 goroutine 的堆栈信息</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/heap : 分析当前活动对象内存分配</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/mutex : 分析堆栈跟踪竞争状态互斥锁的持有者</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/profile : 分析一定持续时间内CPU的使用情况</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/threadcreate : 分析堆栈跟踪系统新线程的创建</span><br><span class="hljs-keyword">go</span> tool pprof http:<span class="hljs-comment">//localhost:8080/debug/pprof/trace : 分析追踪当前程序的执行状况</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go疑难杂症</title>
    <link href="/2024/12/10/go/go%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%89%87/"/>
    <url>/2024/12/10/go/go%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="go疑难杂症"><a href="#go疑难杂症" class="headerlink" title="go疑难杂症"></a>go疑难杂症</h1><h2 id="1、解决IDE-golang-代码飘红报错"><a href="#1、解决IDE-golang-代码飘红报错" class="headerlink" title="1、解决IDE golang 代码飘红报错"></a>1、解决IDE golang 代码飘红报错</h2><blockquote><p>问题：引用方法或者第三方库，代码可正常运行，但是飘红，无法查看方法内部实现</p></blockquote><p>解决方案：</p><p>1.1 goland 编辑器点击工具栏File，找到Invalidate Caches，点击Invalidate and Restart 按钮，清理缓存并且重启goland编辑器</p><p>1,2 检查goland 编辑器 go module配置，File-Setttings-GO Module,查看配置好GOPROXY环境变量，未配置需要配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GOPROXY=https:<span class="hljs-comment">//goproxy.cn,https://goproxy.io,direct</span><br></code></pre></td></tr></table></figure><p>设置 GOPROXY 代理，这里主要涉及到两个值，第一个是 <code>https://goproxy.cn</code>，它是由七牛云背书的一个强大稳定的 Go 模块代理，可以有效地解决你的外网问题；第二个是 <code>direct</code>，它是一个特殊的 fallback 选项，它的作用是用于指示 Go 在拉取模块时遇到错误会回源到模块版本的源地址去抓取（比如 GitHub 等）。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240812095307223.png?raw=true" alt="配置截图"></p><h2 id="2-Go-Slice扩容之坑"><a href="#2-Go-Slice扩容之坑" class="headerlink" title="2 Go Slice扩容之坑"></a>2 Go Slice扩容之坑</h2><h3 id="知识重温"><a href="#知识重温" class="headerlink" title="知识重温"></a>知识重温</h3><p><strong>切片底层结构定义</strong>：包含<code>指向底层数组的指针</code>、<code>长度</code>和<code>容量</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>  array unsafe.Pointer<br>  <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>  <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>append操作</strong>：可以是1个、多个、甚至整个切片（记得后面加…）；添加元素时当容量不足，则会自动触发切片扩容机制，产生切片副本，同时指向底层数组的指针发生变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums []<span class="hljs-type">int</span><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">1</span>)<br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>nums2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>nums = <span class="hljs-built_in">append</span>(nums, nums2...)<br>fmt.Println(nums) <span class="hljs-comment">//[1 2 3 4 5 6 7]</span><br></code></pre></td></tr></table></figure><h3 id="案例1：传值-未扩容"><a href="#案例1：传值-未扩容" class="headerlink" title="案例1：传值+未扩容"></a>案例1：传值+未扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  appendFunc(s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片表达式: &quot;</span>, s1[:<span class="hljs-number">5</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendFunc</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>  s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  fmt.Println(<span class="hljs-string">&quot;s2切片: &quot;</span>, s2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1切片:  []<br>s2切片:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br>s1切片:  []<br>s1切片表达式:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>看到这个结果，大家就会有疑问了，<strong>明明切片是引用类型，为什么s2 append了新元素后，s2是有值了但s1却还是空的，并且对s1用切片表达式却能获取到值呢？</strong></p><p>原因分析前，我们先来看看s1和s2到底是不是同一个切片，打印地址验证下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;s1切片地址: %p\n&quot;</span>, s1)<br>  appendFunc(s1)<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendFunc</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>  s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;s2切片地址: %p\n&quot;</span>, s2)<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br>输出结果：<br>s1切片地址: <span class="hljs-number">0xc000018150</span><br>s2切片地址: <span class="hljs-number">0xc000018150</span><br></code></pre></td></tr></table></figure><p><strong>两个切片的地址都是同一个，s2修改后s1也应该同步修改，应该都有值才对啊</strong></p><p>继续再深究一下，<code>fmt包%p</code>打印的这个地址，到底是谁的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//fmt/print.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *pp)</span></span> fmtPointer(value reflect.Value, verb <span class="hljs-type">rune</span>) &#123;<br>  <span class="hljs-keyword">var</span> u <span class="hljs-type">uintptr</span><br>  <span class="hljs-keyword">switch</span> value.Kind() &#123;<br>  <span class="hljs-keyword">case</span> reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:<br>    u = value.Pointer()<br>  <span class="hljs-keyword">default</span>:<br>    p.badVerb(verb)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//reflect/value.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> Pointer() <span class="hljs-type">uintptr</span> &#123;<br>  k := v.kind()<br>  <span class="hljs-keyword">switch</span> k &#123;<br>  <span class="hljs-comment">//...</span><br>  <br>  <span class="hljs-keyword">case</span> Slice:<br>    <span class="hljs-keyword">return</span> (*SliceHeader)(v.ptr).Data<br>  &#125;<br>  <span class="hljs-built_in">panic</span>(&amp;ValueError&#123;<span class="hljs-string">&quot;reflect.Value.Pointer&quot;</span>, v.kind()&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过分析fmt包的源码，不难发现，<strong>打印的地址，其实是切片里指向底层数组的指针存储的地址，并不是两个切片本身的地址</strong>。同时也说明这两切片是指向同一个底层数组。</p><p><strong>原因正式分析</strong>：</p><ol><li><strong>传值操作</strong>，s1和s2是两个不同的切片变量，但是指向底层数组的指针是同一个；</li><li><strong>长度和容量的变化</strong>：s1 Len&#x3D;0和Cap&#x3D;5，后来未发生过变化；s2一开始被赋值时 Len&#x3D;0和Cap&#x3D;5，在append操作后，Len&#x3D;3和Cap&#x3D;5，同时底层数组值从<code>[0,0,0,0,0]</code>被修改成了<code>[1,2,3,0,0]</code>;</li><li><strong>输出结果</strong>，s1由于Len&#x3D;0所以输出空[]，而s1用切片表达式，是基于底层数组<code>[1,2,3,0,0]</code>进行切片，所以输出结果为<code>[1,2,3,0,0]</code>；</li></ol><h3 id="案例2：传值-扩容"><a href="#案例2：传值-扩容" class="headerlink" title="案例2：传值+扩容"></a>案例2：传值+扩容</h3><p>将案例1，append的元素个数超过切片容量，触发自动扩容，输出的结果又会是怎样的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  appendFunc(s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片表达式: &quot;</span>, s1[:<span class="hljs-number">5</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendFunc</span><span class="hljs-params">(s2 []<span class="hljs-type">int</span>)</span></span> &#123;<br>  s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>  fmt.Println(<span class="hljs-string">&quot;s2切片: &quot;</span>, s2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>s1切片:  []<br>s2切片:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br>s1切片:  []<br>s1切片表达式:  [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>原因分析</strong>：</p><ol><li><strong>发生扩容后</strong>，s2指向的底层数组会产生副本，导致s1和s2不再指向同一个底层数组；</li><li><strong>长度和容量的变化</strong>：s2 append后Len&#x3D;6、Cap&#x3D;10和底层数组值为<code>[1,2,3,4,5,6,0,0,0,0]</code>；s2的操作完全不影响s1的数据，s1仍然是Len&#x3D;0、Cap&#x3D;5和底层数组值为<code>[0,0,0,0,0]</code>；</li><li><strong>输出结果</strong>，s2由于Len&#x3D;6所以输出<code>[1,2,3,4,5,6]</code>，s1由于Len&#x3D;0所以输出空[]，而s1用切片表达式，是基于底层数组<code>[0,0,0,0,0]</code>进行切片，所以输出结果为<code>[0,0,0,0,0]</code>；</li></ol><h3 id="案例3：传址-不关心扩容"><a href="#案例3：传址-不关心扩容" class="headerlink" title="案例3：传址+不关心扩容"></a>案例3：传址+不关心扩容</h3><p>上面两个传值操作的例子，不管扩容与否，都不会影响原切片s1的长度和容量。如果我们<strong>期望修改s2的同时也修改原切片s1，则需要用到切片指针，基于地址传递进行操作</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  fmt.Printf(<span class="hljs-string">&quot;s1切片地址: %p len:%d cap:%d\n&quot;</span>, &amp;s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br>  appendFunc(&amp;s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片: &quot;</span>, s1)<br>  fmt.Println(<span class="hljs-string">&quot;s1切片表达式: &quot;</span>, s1[:<span class="hljs-number">5</span>])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendFunc</span><span class="hljs-params">(s2 *[]<span class="hljs-type">int</span>)</span></span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;s2切片地址: %p len:%d cap:%d\n&quot;</span>, s2, <span class="hljs-built_in">len</span>(*s2), <span class="hljs-built_in">cap</span>(*s2))<br>  <span class="hljs-comment">//*s2 = append(*s2, 1, 2, 3)</span><br>  *s2 = <span class="hljs-built_in">append</span>(*s2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;append后s2切片地址: %p len:%d cap:%d\n&quot;</span>, s2, <span class="hljs-built_in">len</span>(*s2), <span class="hljs-built_in">cap</span>(*s2))<br>  fmt.Println(<span class="hljs-string">&quot;s2切片: &quot;</span>, *s2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">s1切片:  []<br>s1切片地址: <span class="hljs-number">0xc00000c030</span> <span class="hljs-built_in">len</span>:<span class="hljs-number">0</span> <span class="hljs-built_in">cap</span>:<span class="hljs-number">5</span><br>s2切片地址: <span class="hljs-number">0xc00000c030</span> <span class="hljs-built_in">len</span>:<span class="hljs-number">0</span> <span class="hljs-built_in">cap</span>:<span class="hljs-number">5</span><br><span class="hljs-built_in">append</span>后s2切片地址: <span class="hljs-number">0xc00000c030</span> <span class="hljs-built_in">len</span>:<span class="hljs-number">10</span> <span class="hljs-built_in">cap</span>:<span class="hljs-number">10</span><br>s2切片:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span>]<br>s1切片:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span>]<br>s1切片表达式:  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>万变不离其宗，<strong>传址操作，始终操作的是同一个切片变量</strong>，append操作后，长度和容量都会同时发生变化，以及如果触发扩容，那么指向底层数组的指针，也都会同时发生变化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>切片传值操作</strong>，append未触发扩容，会同时修改底层数组的值，但不会影响原切片的长度和容量；当触发扩容，那么会产生副本，后面的修改则会和原底层数组剥离开，互不影响。</p><p>如果期望在修改切片后，对原切片也发生修改，则可以使用<strong>传址操作</strong>，始终基于同一个切片变量进行操作</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose网络关联配置</title>
    <link href="/2024/12/10/docker/docker-compose%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/12/10/docker/docker-compose%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-compose网络配置"><a href="#docker-compose网络配置" class="headerlink" title="docker-compose网络配置"></a>docker-compose网络配置</h1><hr><blockquote><p>在工作中我们可能需要数据库和api接口分开部署的情况，如果都用docker-compose部署的话， 在有的操作系统中可能无法使用（ip+端口）连接数据库，必须使用服务名称去连接。 这时我们就需要让这两个docker-compose启动的服务共享网络，这样就可以相互调用服务了</p></blockquote><h2 id="1-使用docker-compose-yml-文件引用"><a href="#1-使用docker-compose-yml-文件引用" class="headerlink" title="1 使用docker-compose.yml 文件引用"></a>1 使用docker-compose.yml 文件引用</h2><hr><h3 id="数据库的docker-compose文件"><a href="#数据库的docker-compose文件" class="headerlink" title="数据库的docker-compose文件"></a>数据库的docker-compose文件</h3><ul><li>先启动数据库服务，最后api服务的docker-compose.yml引用数据库的网络即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-container</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_net</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure><ul><li><p>这里需要指定网络 my_net，指定后网络名称为当前文件夹加上_my_net，如果不指定会使用当前文件夹的名称加上_default</p></li><li><p>启动命令 docker-compose -p supercom up -d (加上-p指定网络名称)</p></li><li><p>查看网络 docker network ls</p></li><li><p>这里我查看的是 supercom_my_net</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310251507487.png" alt="202308241527417"></p></li></ul><h3 id="api的docker-compose文件"><a href="#api的docker-compose文件" class="headerlink" title="api的docker-compose文件"></a>api的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">api:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/superhorizon/superhorizon-backend-java</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">api</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8089:8089&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">supercom_my_net</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">super_horizon_123456</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">horizon_dev</span><br>      <span class="hljs-attr">MYSQL_NAME:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">opensearch_ip:</span> <span class="hljs-string">opensearch</span><br>      <span class="hljs-attr">opensearch_dashboard_url:</span> <span class="hljs-string">http://192.168.0.190:8889</span><br>      <span class="hljs-attr">situation_picture_url:</span> <span class="hljs-string">/situation_picture_url/</span><br>      <span class="hljs-attr">situation_ipAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.190</span><br>      <span class="hljs-attr">situation_port:</span> <span class="hljs-number">8889</span><br>      <span class="hljs-attr">keycloak-enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">keycloak-auth-server-url:</span> <span class="hljs-string">http://keycloak:8080/auth</span><br>      <span class="hljs-attr">keycloak-realm:</span> <span class="hljs-string">myrealm</span><br>      <span class="hljs-attr">JDBC_URL:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/horizon_dev?allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=UTF8&amp;zeroDateTimeBehavior=round&amp;allowMultiQueries=true</span><br><span class="hljs-string">ex</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">supercom_my_net:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 来自外部</span><br></code></pre></td></tr></table></figure><p>在使用共享网络后，我们在连接 mysql的使用就可以使用服务名称，db-mysql，可进入容器进行ping测试</p><hr><h2 id="2-提前创建docker-网络"><a href="#2-提前创建docker-网络" class="headerlink" title="2 提前创建docker 网络"></a>2 提前创建docker 网络</h2><p>我们可以使用 <strong>docker network create my_net</strong> 创建一个网络，之后每个docker-compose.yml引用即可</p><h3 id="数据库的docker-compose文件-1"><a href="#数据库的docker-compose文件-1" class="headerlink" title="数据库的docker-compose文件"></a>数据库的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-container</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test_super</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">test_super:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="api的docker-compose文件-1"><a href="#api的docker-compose文件-1" class="headerlink" title="api的docker-compose文件"></a>api的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">api:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/superhorizon/superhorizon-backend-java</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">api</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8089:8089&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test_super</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">super_horizon_123456</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">horizon_dev</span><br>      <span class="hljs-attr">MYSQL_NAME:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">opensearch_ip:</span> <span class="hljs-string">opensearch</span><br>      <span class="hljs-attr">opensearch_dashboard_url:</span> <span class="hljs-string">http://192.168.0.190:8889</span><br>      <span class="hljs-attr">situation_picture_url:</span> <span class="hljs-string">/situation_picture_url/</span><br>      <span class="hljs-attr">situation_ipAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.190</span><br>      <span class="hljs-attr">situation_port:</span> <span class="hljs-number">8889</span><br>      <span class="hljs-attr">keycloak-enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">keycloak-auth-server-url:</span> <span class="hljs-string">http://keycloak:8080/auth</span><br>      <span class="hljs-attr">keycloak-realm:</span> <span class="hljs-string">myrealm</span><br>      <span class="hljs-attr">JDBC_URL:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/horizon_dev?allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=UTF8&amp;zeroDateTimeBehavior=round&amp;allowMultiQueries=true</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">test_super:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 来自外部</span><br></code></pre></td></tr></table></figure><p>进入容器测试即可</p><h2 id="3、-Docker-Compose-环境变量"><a href="#3、-Docker-Compose-环境变量" class="headerlink" title="3、 Docker Compose 环境变量"></a>3、 Docker Compose 环境变量</h2><p> Docker Compose 配置中，直接在 <code>environment</code> 下设置环境变量与使用 <code>env_file</code> 引用文件来设置环境变量，主要有以下几点区别：</p><ol><li><p><strong>声明方式</strong>:</p><ul><li><strong>环境变量块 (<code>environment</code>)</strong>: 直接在 <code>environment</code> 下列出的环境变量是以键值对的形式直接写在 <code>docker-compose.yml</code> 文件中的。这种方式适合于少量的、不敏感或者特定于服务的环境变量设置。</li></ul><p>Yaml</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>services:<br><span class="hljs-symbol">2 </span> nginx-proxy:<br><span class="hljs-symbol">3 </span>   environment:<br><span class="hljs-symbol">4 </span>     VIRTUAL_HOST: <span class="hljs-comment">&#x27;api.malcolm.local&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>环境变量文件 (<code>env_file</code>)</strong>: 使用 <code>env_file</code> 指令引用一个或多个外部文件，每个文件中包含多行 <code>KEY=VALUE</code> 格式的环境变量。这种方式适合于管理大量的环境变量，尤其是那些可能在不同环境（如开发、测试、生产）间变化的配置，或者包含敏感信息（尽管对于敏感信息最好使用 Docker 的秘密管理功能）。</li></ul></li><li><p><strong>可维护性和可扩展性</strong>:</p><ul><li><code>env_file</code> 提供了更好的可维护性和扩展性，因为环境相关的配置可以独立于服务定义存放，易于修改和版本控制。特别是当环境变量较多时，直接在 <code>docker-compose.yml</code> 中管理会变得混乱。</li></ul></li><li><p><strong>优先级</strong>:</p><ul><li>如果同一个环境变量既在 <code>env_file</code> 中定义，也在 <code>environment</code> 块中直接定义，那么直接在 <code>environment</code> 块中定义的值会覆盖 <code>env_file</code> 中的值。这是因为直接在服务定义中设置的环境变量具有更高的优先级。</li></ul></li><li><p><strong>安全性</strong>:</p><ul><li>尽管两者都可以用来设置环境变量，但使用 <code>env_file</code> 方式更适合存储敏感信息，因为它允许你将这些信息放在 <code>.env</code> 文件中，该文件通常会被加入 <code>.gitignore</code> 避免误提交到版本控制系统中。然而，最佳实践仍然是使用Docker的密钥管理系统来处理敏感信息。</li></ul></li></ol><p>综上所述，选择直接在 <code>environment</code> 块内定义还是使用 <code>env_file</code> 引入环境变量，取决于你的具体需求、环境变量的数量、安全考量以及是否需要跨服务或跨环境共享配置。</p><h2 id="4、docker-compose时区问题"><a href="#4、docker-compose时区问题" class="headerlink" title="4、docker-compose时区问题"></a>4、docker-compose时区问题</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">方式一：</span><br><span class="hljs-attr">environment:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">SET_CONTAINER_TIMEZONE=true</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">CONTAINER_TIMEZONE=Asia/Shanghai</span><br>  <br><span class="hljs-string">方式二：</span><br><span class="hljs-attr">environment:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br></code></pre></td></tr></table></figure><ul><li><strong>方式一</strong> 更适用于那些具有特定脚本来处理时区设置的镜像，或者您想要更灵活地控制时区设置的情况。</li><li><strong>方式二</strong> 是一种更简单直接的方法，适用于大多数基于Debian&#x2F;Ubuntu的镜像</li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s基础</title>
    <link href="/2024/12/10/docker/k8s%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/10/docker/k8s%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s基础"><a href="#k8s基础" class="headerlink" title="k8s基础"></a>k8s基础</h1><hr><h2 id="1、关于-k8s-的基本架构"><a href="#1、关于-k8s-的基本架构" class="headerlink" title="1、关于 k8s 的基本架构"></a>1、关于 k8s 的基本架构</h2><p>K8s 全称 kubernets，希腊语意为：舵手，是一种可自动实施 Linux容器操作的开源平台。前期由 Google 的工程师开发和设计，中期由红帽等一系列公司参与合作开发，后期由云原生计算基金会进行更新、迭代。其提供了应用部署、规划、更新、维护的一种机制，可以省去应用容器化过程的许多手动部署和扩展操作，将运行 Linux 容器的多组主机聚集在一起，轻松高效地管理集群。</p><p>要学习使用K8s，首先要了解K8s的架构、组件以及特点，说到集群，我们不免会想到master、slaver 或者 node，k8s集群也是这样，由多台 master 和 node 组成，由 master 控制 node，由node（也可以是master）提供服务，如图一所示：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520111740567.png?raw=true" alt="image-20240520111740567"></p><p><strong>什么是 master(控制节点)：</strong> master 的组件包括 apiserver、controller-manager、scheduler 和 etcd，那么这几个组件是用来做什么的呢？我做了个简单的比喻： 图</p><ul><li><strong>Apiserver（房子入口）:</strong> K8S 对外的唯一接口，提供 HTTP&#x2F;HTTPS RESTful API，即所有的请求都需要经过这个接口进行通信</li><li><strong>Etcd （后勤人员）：</strong> 负责保存 k8s 集群的配置信息和各种资源的状态信息，当数据发生变化时，etcd会快速地通知k8s相关组件</li><li><strong>Controller Manager（管理者）：</strong> 负责管理集群各种资源，保证资源处于预期的状态</li><li><strong>Schedule （负责调度）：</strong> 资源调度，负责决定将 Pod 放到哪个 Node 上运行</li></ul><p><strong>什么是 node:</strong> 那么 Node 又是什么呢？说透了 Node 就是干活的。Node的组件包括 Kubelet、Container Runtime、Kube-proxy。</p><ul><li><strong>Kubelet（来料加工生产）：</strong> kubelet 是 node 的 agent，kubelet 会根据 pod 信息创建和运行容器，并向master报告运行状态</li><li><strong>Container Runtime （下载运行）：</strong> 每个Node都需要提供一个容器运行（Container Runtime）环境，它负责下载镜像并运行容器。</li><li><strong>Kube-proxy（传输纽带）：</strong> 用户通过 service（即将介绍）访问Pod，每个Node都会运行kube-proxy服务，将访问的service的TCP&#x2F;UDP数据流转发到后端的容器</li></ul><p>如此，我们也形象地了解了 node 和 node 组件的作用，与此同时，文中提到了 pod 和 service，那么这两个英文单词在K8S中表示什么呢？ <strong>Pod 资源对象</strong>是一种集合了一个或多个应用容器、存储资源、专用ip、以及支撑运行的其他选项的逻辑组件，用大白话讲，pod好比一场舞台剧，是导演、编剧编排好以后由演员、灯光、道具、场务等协作完成的一场戏。 <strong>Service资源</strong>就是在被访问的Pod对象中添加一个有着固定IP地址的中间层，Service资源将客户访问进行调度并代理到后端的Pod对象，Service 起到了通道的作用。Service就好比是个向导，负责将客户带到pod这场舞台剧来观看。</p><h2 id="2、k8s-和kubesphere介绍"><a href="#2、k8s-和kubesphere介绍" class="headerlink" title="2、k8s 和kubesphere介绍"></a>2、k8s 和kubesphere介绍</h2><p>后续操作基于kubesphere 对k8s进行使用</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/introduction/what-is-kubesphere/">k8s官方文档</a></p><p><a href="https://kubernetes.io/zh-cn/docs/home/">kubesphere官方文档</a></p><p><a href="https://helm.sh/zh/docs/">helm官方文档</a></p><p>简单的更好理解的类比:</p><p>​docker，一个容器对应一个服务</p><p>​docker-compose，多个容器服务的集合，每个服务都是standalone模式，负载性能有上限</p><p>​k8s&#x2F;docker swarm，将这里面的每个服务集群化，集群规模动态可控</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520113012594.png?raw=true" alt="image-20240520113012594"></p><p><strong>kubernetes(k8s):</strong> </p><p>​     开源容器编排平台</p><p>​     自动化部署、扩展和管理容器化应用程序</p><p><strong>kubesphere:</strong> </p><p>​     基于k8s构建的开源多云容器管理平台</p><p>​     可视化管理界面、应用商店、应用程序监控和日志管理等功能</p><p><strong>Helm Chart:</strong>   </p><p>​     k8s的包管理工具， 配置，打包k8s应用程序</p><h2 id="3、安装kubesphere"><a href="#3、安装kubesphere" class="headerlink" title="3、安装kubesphere"></a>3、安装kubesphere</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> KKZONE=cn<br>curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.7 sh -<br></code></pre></td></tr></table></figure><p>备注</p><p>在您下载 KubeKey 后，如果您将其传至新的机器，且访问 Googleapis 同样受限，在您执行以下步骤之前请务必再次执行 <code>export KKZONE=cn</code> 命令。</p><p>执行以上命令会下载最新版 KubeKey，您可以修改命令中的版本号下载指定版本。</p><p>为 <code>kk</code> 添加可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x kk<br></code></pre></td></tr></table></figure><p>在本快速入门教程中，您只需执行一个命令即可进行安装，其模板如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./kk create cluster [--with-kubernetes version] [--with-kubesphere version]<br><br>若要同时安装 Kubernetes 和 KubeSphere，可参考以下示例命令：<br>./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2<br></code></pre></td></tr></table></figure><ul><li>安装 KubeSphere 3.3 的建议 Kubernetes 版本：v1.20.x、v1.21.x、* v1.22.x、* v1.23.x 和 * v1.24.x。带星号的版本可能出现边缘节点部分功能不可用的情况。因此，如需使用边缘节点，推荐安装 v1.21.x。如果不指定 Kubernetes 版本，KubeKey 将默认安装 Kubernetes v1.23.10。有关受支持的 Kubernetes 版本的更多信息，请参见<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/introduction/kubekey/#%E6%94%AF%E6%8C%81%E7%9F%A9%E9%98%B5">支持矩阵</a>。</li><li>一般来说，对于 All-in-One 安装，您无需更改任何配置。</li><li>如果您在这一步的命令中不添加标志 <code>--with-kubesphere</code>，则不会部署 KubeSphere，KubeKey 将只安装 Kubernetes。如果您添加标志 <code>--with-kubesphere</code> 时不指定 KubeSphere 版本，则会安装最新版本的 KubeSphere。</li><li>KubeKey 会默认安装 <a href="https://openebs.io/">OpenEBS</a> 为开发和测试环境提供 LocalPV 以方便新用户。对于其他存储类型，请参见<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/persistent-storage-configurations/understand-persistent-storage/">持久化存储配置</a>。</li></ul><p>执行该命令后，KubeKey 将检查您的安装环境，结果显示在一张表格中。有关详细信息，请参见<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/#%E8%8A%82%E7%82%B9%E8%A6%81%E6%B1%82">节点要求</a>和<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/#%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%A6%81%E6%B1%82">依赖项要求</a>。输入 <code>yes</code> 继续安装流程。</p><blockquote><p>KubeKey 是用 Go 语言开发的一款全新的安装工具，代替了以前基于 ansible 的安装程序。KubeKey 为用户提供了灵活的安装选择，可以分别安装 KubeSphere 和 Kubernetes 或二者同时安装，既方便又高效。</p></blockquote><p>安装完成提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#####################################################</span><br><span class="hljs-comment">###              Welcome to KubeSphere!           ###</span><br><span class="hljs-comment">#####################################################</span><br><br>Console: http://192.168.0.164:30880<br>Account: admin<br>Password: P@88w0rd<br>NOTES：<br>  1. After you <span class="hljs-built_in">log</span> into the console, please check the<br>     monitoring status of service components <span class="hljs-keyword">in</span><br>     <span class="hljs-string">&quot;Cluster Management&quot;</span>. If any service is not<br>     ready, please <span class="hljs-built_in">wait</span> patiently <span class="hljs-keyword">until</span> all components <br>     are up and running.<br>  2. Please change the default password after login.<br><br><span class="hljs-comment">#####################################################</span><br>https://kubesphere.io             2024-05-20 15:53:41<br><span class="hljs-comment">#####################################################</span><br>15:53:44 CST success: [super]<br>15:53:44 CST Pipeline[CreateClusterPipeline] execute successfully<br>Installation is complete.<br><br>Please check the result using the <span class="hljs-built_in">command</span>:<br><br>kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="hljs-string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f<br><br></code></pre></td></tr></table></figure><p><strong>验证安装结果</strong></p><p>输入以下命令以检查安装结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="hljs-string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f<br><br></code></pre></td></tr></table></figure><p>输出信息会显示 Web 控制台的 IP 地址和端口号，默认的 NodePort 是 <code>30880</code>。现在，您可以使用默认的帐户和密码 (<code>admin/P@88w0rd</code>) 通过 <code>&lt;NodeIP&gt;:30880</code> 访问控制台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#####################################################</span><br><br><span class="hljs-comment">###              Welcome to KubeSphere!           ###</span><br><br><span class="hljs-comment">#####################################################</span><br><br><br><br>Console: http://192.168.0.164:30880<br><br>Account: admin<br><br>Password: P@88w0rd<br><br><br><br>NOTES：<br><br>  1. After you <span class="hljs-built_in">log</span> into the console, please check the<br><br>     monitoring status of service components <span class="hljs-keyword">in</span><br><br>     <span class="hljs-string">&quot;Cluster Management&quot;</span>. If any service is not<br><br>     ready, please <span class="hljs-built_in">wait</span> patiently <span class="hljs-keyword">until</span> all components <br><br>     are up and running.<br><br>  2. Please change the default password after login.<br><br><br><br><span class="hljs-comment">#####################################################</span><br><br>https://kubesphere.io             20xx-xx-xx xx:xx:xx<br><br><span class="hljs-comment">#####################################################</span><br><br></code></pre></td></tr></table></figure><p>录至控制台后，您可以在<strong>系统组件</strong>中查看各个组件的状态。如果要使用相关服务，您可能需要等待部分组件启动并运行。您也可以使用 <code>kubectl get pod --all-namespaces</code> 来检查 KubeSphere 相关组件的运行状况。</p><h2 id="4、k8s基础资源介绍"><a href="#4、k8s基础资源介绍" class="headerlink" title="4、k8s基础资源介绍"></a>4、k8s基础资源介绍</h2><h3 id="4-1-容器组（pod）"><a href="#4-1-容器组（pod）" class="headerlink" title="4.1 容器组（pod）"></a>4.1 容器组（pod）</h3><ul><li>K8s中最小的可部署对象</li><li>一个或多个容器的运行环境</li><li>容器间共享网络和存储资源</li></ul><h3 id="4-2-工作负载（deployment、statefulset、daemonset）"><a href="#4-2-工作负载（deployment、statefulset、daemonset）" class="headerlink" title="4.2 工作负载（deployment、statefulset、daemonset）"></a>4.2 工作负载（deployment、statefulset、daemonset）</h3><ul><li>pod 的控制器</li><li>管理pod副本数，配置，滚动更新，回滚pod</li><li>部署（deployment）管理控制无状态的容器组，如后端，前端等</li><li>有状态副本集（statefulset）管理控制有状态的容器组，如mysql，kafka，es等</li><li>守护进程集（daemonset）,管理一个节点只运行一个的容器组副本，如fluentd，logstash, Prometheus Node Exporter</li></ul><h3 id="4-3-服务（service"><a href="#4-3-服务（service" class="headerlink" title="4.3 服务（service)"></a>4.3 服务（service)</h3><ul><li>访问入口（分内部访问和外部访问）</li><li>负载均衡到多个pod副本</li></ul><h3 id="4-4-任务（job"><a href="#4-4-任务（job" class="headerlink" title="4.4 任务（job)"></a>4.4 任务（job)</h3><ul><li>访问入口（分内部访问和外部访问）</li><li>负载均衡到多个pod副本</li></ul><h3 id="4-5-持久卷和持久卷声明（pv-pvc"><a href="#4-5-持久卷和持久卷声明（pv-pvc" class="headerlink" title="4.5  持久卷和持久卷声明（pv &amp; pvc)"></a>4.5  持久卷和持久卷声明（pv &amp; pvc)</h3><ul><li>pv 是一块存储资源 </li><li>pvc 是对PV的声明式请求，描述了Pod需要的存储资源的需求，包括存储容量、读写模式、访问模式等</li><li>pv 和pvc 一一对应</li></ul><h3 id="4-6-配置-secret-configmap-serviceaccount"><a href="#4-6-配置-secret-configmap-serviceaccount" class="headerlink" title="4.6 配置(secret,configmap,serviceaccount)"></a>4.6 配置(secret,configmap,serviceaccount)</h3><ul><li>保密字典（secret）: 用于存储和管理密码、OAuth 令牌和 SSH 保密字典等敏感信息</li><li>配置字典（configmap）: 用于向容器组中注入配置数据</li><li>服务账号（serviceaccount）: 为 Pod 中运行的进程提供了标识。当用户访问集群时，API 服务器将用户认证为特定的用户帐户</li></ul><h2 id="5、资源之间的关系"><a href="#5、资源之间的关系" class="headerlink" title="5、资源之间的关系"></a>5、资源之间的关系</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520152157424.png?raw=true" alt="image-20240520152157424"></p><h2 id="6、新建自定义服务暴露mysql服务"><a href="#6、新建自定义服务暴露mysql服务" class="headerlink" title="6、新建自定义服务暴露mysql服务"></a>6、新建自定义服务暴露mysql服务</h2><blockquote><p>仓库地址:</p><p> bitnami 官网： <a href="https://charts.bitnami.com/bitnami">https://charts.bitnami.com/bitnami</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm repo add bitnami https://charts.bitnami.com/bitnami<br>$ helm search repo bitnami<br>$ helm install my-release bitnami/&lt;chart&gt;<br></code></pre></td></tr></table></figure><blockquote><p>第一步 创建企业空间</p><p>第二步 添加应用仓库</p></blockquote><h3 id="1-新建mysql数据库服务"><a href="#1-新建mysql数据库服务" class="headerlink" title="1 新建mysql数据库服务"></a><strong>1 新建mysql数据库服务</strong></h3><p>应用负载 -&gt; 服务 -&gt; 创建 -&gt; 选择有状态服务</p><h4 id="第一步-基本信息"><a href="#第一步-基本信息" class="headerlink" title="第一步 基本信息"></a><strong>第一步 基本信息</strong></h4><p>填写服务名称 -&gt; 下一步</p><h4 id="第二步-容器组设置"><a href="#第二步-容器组设置" class="headerlink" title="第二步 容器组设置"></a><strong>第二步 容器组设置</strong></h4><p>1 添加容器 -&gt;2 选择镜像仓库 -&gt;3 填写镜像名称和版本 -&gt;4 填写容器名称 -&gt;5 使用默认端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5f58e604-f78d-49d3-924a-c0df0952e5b3.png?raw=true" alt="img"></p><p>滚轮下划，添加环境变量，设置初始root密码</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4e06eee2-d151-4e48-9ba5-9df0d609b15f.png?raw=true" alt="img"></p><h4 id="第三步-存储设置"><a href="#第三步-存储设置" class="headerlink" title="第三步 存储设置"></a><strong>第三步 存储设置</strong></h4><p>存储设置，添加持久卷申明模板</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4dd6494e-97d2-45d1-b674-d06468a94deb.png?raw=true" alt="img"></p><p>1 填写持久卷申明名称前缀 -&gt; 2 选择存储类（默认local） -&gt; 3 选择访问模式（默认）-&gt; 4 设置存储空间大小 -&gt;</p><p>5 选择读写模式 -&gt; 6 填写容器内数据所在目录 -&gt; 确定 -&gt; 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/6694c3e2-2492-4968-9066-284977513e97.png?raw=true" alt="img"></p><h4 id="第四步-高级设置"><a href="#第四步-高级设置" class="headerlink" title="第四步 高级设置"></a><strong>第四步 高级设置</strong></h4><p>会话保持：一般在后端服务中可以设置，同一个用户连续访问，会在一段时间内负载到同一个容器组副本</p><p>选择节点：可以选择将容器部署至k8s集群中的某个节点</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/06a335af-81fa-49df-8203-813a57beda34.png?raw=true" alt="img"></p><p>有状态服务新建完只能内部使用</p><h4 id="第五步-新建自定义服务暴露mysql服务"><a href="#第五步-新建自定义服务暴露mysql服务" class="headerlink" title="第五步 新建自定义服务暴露mysql服务"></a><strong>第五步 新建自定义服务暴露mysql服务</strong></h4><p>1 应用负载 -&gt; 2 服务 -&gt;3 创建 -&gt; 4 自定义服务 -&gt;5 指定工作负载 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/84fc16e6-7888-4a67-ae10-0bcbb6be5e34.png?raw=true" alt="img"></p><p>6 填写服务名称 -&gt; 7 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/0907b73e-5e1b-40e8-85e8-2656fd543acb.png?raw=true" alt="img"></p><p>8 指定工作负载 -&gt; 9 有状态副本集 -&gt; 10 选择之前创建的mysql -&gt;11 确定 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/cf1c4ccc-dd26-4009-85ac-2b26f1430005.png?raw=true" alt="img"></p><p>12 选择服务端口协议 -&gt;13 填写名称 -&gt;14 填写容器端口 -&gt;15 服务端口 -&gt;16 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/74be5fde-79ae-4e1a-a173-e39dec04c508.png?raw=true" alt="img"></p><p>17 勾选外部访问（如果不配置，那该服务只能k8s集群节点内部访问）-&gt; 18 选择访问模式 -&gt; 19 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/93bec419-be27-4915-b98d-23811b5ac078.png?raw=true" alt="img"></p><h4 id="第六步-mysql-服务使用方法"><a href="#第六步-mysql-服务使用方法" class="headerlink" title="第六步 mysql 服务使用方法"></a><strong>第六步 mysql 服务使用方法</strong></h4><p>1 内部ip加端口: 10.233.4.60:3306</p><p>2 内部域名加端口：</p><p>  同一个项目内，mysql-ex:3306</p><p>  不同项目使用，mysql-ex.superlab.svc.cluster.local:3306</p><p>3 外部ip加端口: 192.168.0.104:10419</p><p>用户名：root</p><p>密码：第二步填写的环境变量值</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5be003b4-4830-4c98-954c-995b5a3a5476.png?raw=true" alt="img"></p><h3 id="2-新建后端服务"><a href="#2-新建后端服务" class="headerlink" title="2 新建后端服务"></a><strong>2 新建后端服务</strong></h3><h4 id="第零步-配置镜像仓库信息"><a href="#第零步-配置镜像仓库信息" class="headerlink" title="第零步 配置镜像仓库信息"></a><strong>第零步 配置镜像仓库信息</strong></h4><p>配置 -&gt; 保密字典 -&gt; 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/6c1fd5df-5a05-4b01-8952-adfa55d01302.png?raw=true" alt="img"></p><p>3 填写名称 -&gt; 下一步 -&gt; 选择类型-&gt; 镜像服务信息</p><p>4 填写镜像服务地址-&gt; 用户名 -&gt; 密码 -&gt; 创建 （镜像仓库信息找各自代码仓库管理员要）</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/77d02f21-7d72-4f4b-b081-07ffe2f4a638.png?raw=true" alt="img"></p><h4 id="第一步-基本信息-1"><a href="#第一步-基本信息-1" class="headerlink" title="第一步 基本信息"></a><strong>第一步 基本信息</strong></h4><p>应用负载 -&gt; 服务 -&gt; 创建 -&gt; 选择无状态服务</p><p>1 填写服务名称 -&gt;2 下一步</p><h4 id="第二步-容器组设置-1"><a href="#第二步-容器组设置-1" class="headerlink" title="第二步 容器组设置"></a><strong>第二步</strong> <strong>容器组设置</strong></h4><p>3 添加容器 -&gt;4 选择镜像仓库 -&gt;5 填写镜像名称和版本 -&gt;6 填写容器名称 -&gt;7 使用默认端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/1fe9ab97-15f7-4cbd-99c0-bcdbf753fe02.png?raw=true" alt="img"></p><p>8 滚轮下滑 -&gt;9 勾选环境变量 -&gt;10 填写mysql地址，端口，账号，密码（建议将这些配置配成根据环境变量动态获取）-&gt; 11 确定 -&gt; 12 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c7c860bb-6460-4920-87ef-67fc973d419f.png?raw=true" alt="img"></p><p><strong>第三步 存储设置</strong></p><p>如需挂载数据文件，选择“挂载卷”</p><p>如需挂载配置文件，选择“挂载配置字典或保密字典”</p><p>无需挂载，直接”下一步”</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/bcb65ce3-b69e-49ed-820c-40825623dcb8.png?raw=true" alt="img"></p><h4 id="第四步-高级设置-1"><a href="#第四步-高级设置-1" class="headerlink" title="第四步 高级设置"></a><strong>第四步 高级设置</strong></h4><p>根据需要设置外部访问，会话保持，选择节点</p><p>无需要则“下一步”</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2a2ea879-6a0a-4131-a03d-89147528b8e3.png?raw=true" alt="img"></p><h4 id="第五步-往部署配置中加入镜像仓库信息"><a href="#第五步-往部署配置中加入镜像仓库信息" class="headerlink" title="第五步 往部署配置中加入镜像仓库信息"></a><strong>第五步 往部署配置中加入镜像仓库信息</strong></h4><p>1 进入部署信息页面，应用负载 -&gt; 工作负载 -&gt; 点击部署名称（以<a href="http://192.168.0.104:30880/supertech/clusters/default/projects/superlab/deployments/classification-workers-v1"><strong>classification-workers-v1</strong></a><strong>为例</strong>） </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/ad92fbaf-3064-4520-9c35-f0a8f8ff0f1a.png?raw=true" alt="img"></p><p>2 编辑yaml ,添加第零步配置的镜像服务保密字典的名称</p><p>更多操作 -&gt; 编辑yaml ， 在spec.template.spec下添加镜像服务保密字典名称</p><p>imagePullSecrets:</p><p>​    - name: hangzhou-aliyuncs-com（这里换成自己创建的镜像服务保密字典的名称）</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/907a9a99-dae4-4a59-b12f-6704bc564624.png?raw=true" alt="img"></p><h4 id="第六步-后端服务如何调用"><a href="#第六步-后端服务如何调用" class="headerlink" title="第六步 后端服务如何调用"></a><strong>第六步 后端服务如何调用</strong></h4><p>按目前公司前后端分离的开发模式（nginx+前端静态文件+后端服务端口）</p><p>在nginx中配置内部ip+端口，负载后端服务</p><p>1 前端负载配置</p><p>2 后端负载配置</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/eeee85a1-5c7c-418d-aac7-a7dd6b17db90.png?raw=true" alt="img"></p><p>应用负载 -&gt; 服务 -&gt; 进入后端服务</p><p>查看对应的内部服务ip 和服务端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4bb8696b-a8b3-405f-86b7-589c1c222b38.png?raw=true" alt="img"></p><h3 id="3-新建前端服务"><a href="#3-新建前端服务" class="headerlink" title="3  新建前端服务"></a>3  <strong>新建前端服务</strong></h3><p>步骤与后端服务创建过程一样</p><p>只是将镜像换成了前端镜像</p><p>前端镜像的dockerfile本质是基于nginx，</p><p>然后在nginx的配置文件里配置了</p><p>前端静态文件负载和</p><p>后端接口服务负载</p><p>新建完以后需要暴露前端服务</p><p>应用负载 -&gt; 服务 -&gt; 更多 -&gt; 编辑外部访问</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/a11ddcd9-4f05-4ab3-bf2a-db221bc03f0f.png?raw=true" alt="img"></p><p>选择访问模式 -&gt; 确定</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/38897e5b-fcf1-4dba-8874-79cb5c887140.png?raw=true" alt="img"></p><p>在浏览器中，用ip+端口即可访问前端页面</p><p>192.168.0.104:42064</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/14d3c33b-fa55-45b1-8a49-72a0f2e4bf56.png?raw=true" alt="img"></p><h2 id="7、kubectl常用命令"><a href="#7、kubectl常用命令" class="headerlink" title="7、kubectl常用命令"></a>7、kubectl常用命令</h2><p><code>kubectl</code> 是 Kubernetes 的命令行工具，用于与 Kubernetes 集群进行交互，包括部署应用、检查和管理各种资源。一些基本的 <code>kubectl</code> 命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get ns<span class="hljs-comment"># 查看命名空间</span><br>kubectl get pods  -n &lt;namespace-name&gt;<span class="hljs-comment"># 查看命名空间所有Pod列表</span><br>kubectl describe pods/&lt;pod-name&gt;<span class="hljs-comment"># 显示Pod的详细信息</span><br>kubectl config set-context --current --namespace=production      <span class="hljs-comment"># 切换到不同的命名空间</span><br>kubectl config view --minify | grep namespace: <span class="hljs-comment"># 查看当前所属命名空间</span><br>kubectl get service     <span class="hljs-comment"># 查看service列表</span><br>kubectl get deployments <span class="hljs-comment"># 查看所有命名空间中的Deployments</span><br>kubectl create -f my-service.yaml   <span class="hljs-comment"># 根据yaml配置文件一次性创建service</span><br>kubectl create -f &lt;directory&gt; <span class="hljs-comment"># 根据目录下所有.yaml、.yml、.json文件的定义进行创建操作</span><br>kubectl delete -f pod.yaml <span class="hljs-comment"># 删除基于pod.yaml文件定义的Pod</span><br>kubectl delete pods --all <span class="hljs-comment"># 删除所有Pod</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; <span class="hljs-built_in">date</span> <span class="hljs-comment"># 在Pod的容器里执行date命令，默认使用Pod中的第1个容器执行</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; <span class="hljs-built_in">date</span> <span class="hljs-comment"># 指定Pod中某个容器执行date命令</span><br>kubectl <span class="hljs-built_in">exec</span> -it &lt;pod-name&gt; -c &lt;container-name&gt; /bin/bash        <span class="hljs-comment"># 以bash方式登陆到Pod中的某个容器里</span><br>kubectl logs -f &lt;pod-name&gt; -c &lt;container-name&gt; <span class="hljs-comment"># 跟踪查看容器的日志，相当于tail -f命令的结果</span><br></code></pre></td></tr></table></figure><h2 id="8、kubeadm常用命令"><a href="#8、kubeadm常用命令" class="headerlink" title="8、kubeadm常用命令"></a>8、kubeadm常用命令</h2><p><code>kubeadm</code> 是 Kubernetes 的一个简化集群初始化和管理工具，它旨在提供一种快速、可靠的方式来引导最小化的 Kubernetes 控制平面以及加入工作节点到集群中。一些常用的 <code>kubeadm</code> 命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init <span class="hljs-comment"># 启动引导一个 Kubernetes 主节点</span><br>kubeadm <span class="hljs-built_in">join</span> <span class="hljs-comment"># 启动引导一个 Kubernetes 工作节点并且将其加入到集群</span><br>kubeadm upgrade <span class="hljs-comment"># 更新 Kubernetes 集群到新版本</span><br>kubeadm config <span class="hljs-comment"># 如果你使用 kubeadm v1.7.x 或者更低版本，你需要对你的集群做一些配置以便使用 kubeadmupgrade 命令</span><br>kubeadm token <span class="hljs-comment"># 使用 kubeadm join 来管理令牌</span><br>kubeadm reset  <span class="hljs-comment"># 还原之前使用 kubeadm init 或者 kubeadm join 对节点所作改变</span><br>kubeadm version <span class="hljs-comment"># 打印出 kubeadm 版本</span><br>kubeadm alpha <span class="hljs-comment"># 预览一组可用的新功能以便从社区搜集反馈</span><br></code></pre></td></tr></table></figure><h2 id="9-、kubelet"><a href="#9-、kubelet" class="headerlink" title="9 、kubelet"></a>9 、kubelet</h2><p><code>kubelet</code> 是在每个节点上运行的主要守护进程，负责与Master通信、管理Pods、容器以及其他相关任务。通常，kubelet不是直接通过命令行与之交互，而是通过配置文件（如 <code>/var/lib/kubelet/kubelet-config.yaml</code>）和环境变量来设定。不过，了解其功能很重要，因为它负责：</p><ul><li><strong>Pod 和容器的生命周期管理</strong>：根据从apiserver接收到的指令来创建、更新、删除Pod和容器。</li><li><strong>资源监控和报告</strong>：收集节点资源使用情况，向Master报告。</li><li><strong>日志和监控</strong>：管理容器日志，支持与日志收集系统的集成。</li></ul><h2 id="10、打包helm部署流程"><a href="#10、打包helm部署流程" class="headerlink" title="10、打包helm部署流程"></a>10、打包helm部署流程</h2><h3 id="1、添加公司helm-chart-仓库"><a href="#1、添加公司helm-chart-仓库" class="headerlink" title="1、添加公司helm chart 仓库"></a>1、<strong>添加公司helm chart 仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add helm-repo-115 http://115.231.236.115:8081/nexus/repository/helm-repo-115/<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/8057ec28-197d-4b46-ac2d-be3fadef95a7.png?raw=true" alt="img"></p><h3 id="2、创建一个应用目录"><a href="#2、创建一个应用目录" class="headerlink" title="2、创建一个应用目录"></a>2、创建一个应用目录</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/19b5ab45-a0b2-49d0-a624-5437aaa2a102.png?raw=true" alt="img"></p><h3 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c48b3afe-b905-4f20-8531-f6ce9c6eaeda.png?raw=true" alt="img"></p><h3 id="4、目录结构介绍"><a href="#4、目录结构介绍" class="headerlink" title="4、目录结构介绍"></a>4、目录结构介绍</h3><p>harts: 目录包含了依赖的其他Helm Charts，可以让您在应用程序中引入其他的Helm Charts</p><p>Chart.yaml: 元数据文件，包含了应用程序的名称、版本、描述、维护人员等信息</p><p>templates: 目录包含了应用程序的Kubernetes资源配置文件，例如Deployment、Service、Configmap等</p><p>values.yaml：应用程序的默认配置文件，用于设置应用程序的默认参数值</p><h3 id="5-初步打包介绍"><a href="#5-初步打包介绍" class="headerlink" title="5 初步打包介绍"></a>5 初步打包介绍</h3><p><strong>第一步 删除 templates 下所有文件</strong></p><p><strong>第二步 获取要打包的完整应用在k8s 上的所有资源配置文件，包含服务，工作负载，配置项等</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/bd4c8502-9c3b-4b49-92f5-2263119821e8.png?raw=true" alt="img"></p><p><strong>第三步 将配置文件放入templates 目录</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c9723cc5-7eb1-48cc-b332-03a313e25a90.png?raw=true" alt="img"></p><p><strong>第四步 根据版本号打包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm package mychart --version 1.0.0<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/eff431f6-c344-4425-9a79-217005de1f32.png?raw=true" alt="img"></p><p><strong>第五步 推送到仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm nexus-push helm-repo-115 mychart-1.0.0.tgz -u admin -p  &#123;密码&#125;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/8dfcb80c-6d9f-4bad-9986-3c94e0708309.png?raw=true" alt="img"></p><h2 id="11、使用helm包部署完整应用流程"><a href="#11、使用helm包部署完整应用流程" class="headerlink" title="11、使用helm包部署完整应用流程"></a>11、<strong>使用helm包部署完整应用流程</strong></h2><h3 id="1-添加helm仓库"><a href="#1-添加helm仓库" class="headerlink" title="1 添加helm仓库"></a><strong>1 添加helm仓库</strong></h3><p>平台管理 -&gt; 访问控制 -&gt; 进入企业空间</p><p>应用管理 -&gt; 应用仓库 -&gt; 添加</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5a3a662d-741b-4d77-bd15-8bc2f4c1617c.png?raw=true" alt="img"></p><p>填写仓库信息</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/1dec1227-804c-492f-b74e-84d750147789.png?raw=true" alt="img"></p><h3 id="2-一键部署应用"><a href="#2-一键部署应用" class="headerlink" title="2 一键部署应用"></a><strong>2 一键部署应用</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 基于模板的应用 -&gt; 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/a17c75e3-2223-4008-8c29-55515a8b453f.png?raw=true" alt="img"></p><p>选择应用仓库helm-repo-115 -&gt; 选择应用模板mychart -&gt;安装</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/dfb34fc6-d82c-4dd2-837d-afc3581dfb36.png?raw=true" alt="img"></p><h3 id="3-点击查看应用内资源运行情况"><a href="#3-点击查看应用内资源运行情况" class="headerlink" title="3 点击查看应用内资源运行情况"></a><strong>3 点击查看应用内资源运行情况</strong></h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/71a619b2-8ea5-4366-9801-6cfc9e2ccc89.png?raw=true" alt="img"></p><h2 id="12、日常运维流程"><a href="#12、日常运维流程" class="headerlink" title="12、日常运维流程"></a><strong>12、日常运维流程</strong></h2><h3 id="1-升级镜像，修改容器配置等"><a href="#1-升级镜像，修改容器配置等" class="headerlink" title="1 升级镜像，修改容器配置等"></a><strong>1 升级镜像，修改容器配置等</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 工作负载 -&gt; 点击对应工作负载</p><p>更多操作 -&gt; 编辑设置</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/d27ed6e2-2e81-46dd-90fb-2d871e75581c.png?raw=true" alt="img"></p><h3 id="2-查看容器日志"><a href="#2-查看容器日志" class="headerlink" title="2 查看容器日志"></a><strong>2 查看容器日志</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 工作负载 -&gt; 点击对应工作负载 -&gt; 点击容器组</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/ed7cb4ef-681d-4e4f-b04b-f2be0649591c.png?raw=true" alt="img"></p><p>实时查看&#x2F;停止，刷新日志，下载日志</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/42bb22e8-b48a-4d34-bd8c-a44c5680d352.png?raw=true" alt="img"></p><h3 id="3-进入容器-默认非root用户"><a href="#3-进入容器-默认非root用户" class="headerlink" title="3 进入容器(默认非root用户)"></a><strong>3 进入容器(默认非root用户)</strong></h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c7aecdad-99dc-48e7-a2d3-f4f9af68c624.png?raw=true" alt="img"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/XJ9LnWvP9VvWlvDe/img/fda98b1f-5f56-49d3-85a1-f982a6c0a61e.png?raw=true" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go堆栈分析</title>
    <link href="/2024/12/10/go/Go%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/"/>
    <url>/2024/12/10/go/Go%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Go栈内存、堆内存、逃逸分析"><a href="#Go栈内存、堆内存、逃逸分析" class="headerlink" title="Go栈内存、堆内存、逃逸分析"></a>Go栈内存、堆内存、逃逸分析</h1><h2 id="内存的作用"><a href="#内存的作用" class="headerlink" title="内存的作用"></a>内存的作用</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516143225329.png?raw=true" alt="代码是什么"></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516143333413.png?raw=true" alt="image-20240516143333413"></p><p>为了让程序员更好地专注于业务代码的实现，<code>Go</code>语言增加了<a href="https://blog.51cto.com/u_15730090/5510574">垃圾回收</a>机制，自动地回收不再使用的内存。</p><p><code>Go</code>语言有两部分<code>内存</code>空间：<strong>栈内存</strong> 和 <strong>堆内存</strong>。</p><h2 id="os的堆栈"><a href="#os的堆栈" class="headerlink" title="os的堆栈"></a>os的堆栈</h2><p>栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。</p><p>除此之外，堆也是计算机中的一种内存区域，<strong>堆与栈的区别</strong>如下：</p><ol><li><strong>栈</strong>一般由操作系统来分配和释放，<strong>堆</strong>由程序员通过编程语言来申请创建与释放。</li><li><strong>栈</strong>用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，<strong>堆</strong>用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。</li><li><strong>栈</strong>的访问速度相对比<strong>堆</strong>快。</li><li>一般来说，每个线程分配一个<strong>stack(栈)<strong>，每个进程分配一个</strong>heap(堆)<strong>，也就是说，</strong>stack</strong> 是线程独占的，<strong>heap</strong> 是线程共用的。</li><li><strong>stack</strong> 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而<strong>heap</strong>的大小是不确定的，需要的话可以不断增加。</li><li><strong>栈</strong>是由高地址向低地址增长的，而<strong>堆</strong>是由低地址向高地址增长的。</li></ol><p>在 C&#x2F;C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。</p><h2 id="Go的堆栈"><a href="#Go的堆栈" class="headerlink" title="Go的堆栈"></a>Go的堆栈</h2><p>首先，<strong>Go 是自己管理内存的，而不是交给操作系统</strong>，它每次从操作系统申请一大块内存，然后按照 Google 的 <strong><code>TCMalloc</code></strong> 算法进行内存分配，也划分为堆、栈等很多区域。</p><p>这里我们主要关心变量究竟放在堆还是栈里，官方有这么一段解释：</p><p>只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用<strong>垃圾回收</strong>机制进行管理，从而避免 <strong>指针悬空</strong>。此外，局部变量如果非常大，也会存在堆上。</p><p>在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。</p><p>总之，分配在堆还是栈完全<strong>由编译器确定</strong>。而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了<strong>逃逸</strong>。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫<strong>逃逸分析</strong>。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>栈只允许往线性表的一端放入数据，之后在这一端取出数据,按照<strong>后进先出</strong>(LIFO, Last In First Out )的顺序，如图所示。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516154618013.png?raw=true" alt="image-20240516154618013"></p><p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p><p>从栈中取出元素时，只能从栈顶部取出。取出元素后,栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员(除栈顶外的成员)进行任何查看和修改操作 。</p><p><strong>栈内存由编译器自动分配和释放，开发者无法控制。栈内存一般存储函数中的局部变量、参数等，函数创建的时候，这些内存会被自动创建；函数返回的时候，这些内存会被自动释放。</strong></p><p><strong>栈可用于内存分配，栈的分配和回收速度非常快。</strong>下面代码展示枝在内存分配上的作用，代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br>    c = a * b<br>    <br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>    x = c * <span class="hljs-number">10</span><br>    <br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码在没有任何优化情况下，会进行<code>c</code>和<code>x</code>变量的分配过程 。<code>Go</code>语言默认情况下会将<code>c</code>和<code>x</code>分配在栈上，这两个变量在<code>calc()</code>函数退出时就不再使用，函数结束时，保存<code>c</code>和<code>x</code>的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小。</p><p>分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往空间里摆放家具会存在虽然有足够的空间，但各空间分布在不同的区域，无法有一段连续的空间来摆放家具的问题。此时内存分配器就需要对这些空间进行调整优化，如图所示：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516155637223.png?raw=true" alt="image-20240516155637223"></p><p>堆分配内存和栈分配内存相比，<strong>堆适合不可预知大小的内存分配</strong>。但是为此付出的代价是分配<strong>速度较慢</strong>，而且会形成<strong>内存碎片</strong> 。堆内存的生命周期比栈内存要长，如果函数返回的值还会在其他地方使用，那么这个值就会被编译器自动分配到堆上。堆内存相比栈内存来说，不能自动被编译器释放，只能通过垃圾回收器才能释放，所以栈内存效率会很高。</p><p><strong>逃逸机制</strong></p><p>编译器会根据变量<strong>是否被外部引用</strong>来决定是否逃逸：</p><ol><li>如果函数外部没有引用，则优先放到栈中</li><li>如果函数外部存在引用，则必定放到堆中</li><li>如果栈上放不下，则必定放到堆中</li></ol><p><strong>golang 中哪些变量是在堆和栈中</strong></p><p>栈 (Stack)</p><ul><li>局部变量：在函数内部声明的局部变量通常存储在栈上。</li><li>函数参数：传递给函数的参数也存储在栈上。</li><li>小型结构体：如果结构体足够小，也可能被放在栈上。</li></ul><p>堆 (Heap)</p><ul><li>大型结构体：如果结构体很大，或者包含指针成员，那么通常会被放在堆上。</li><li>动态分配的对象：使用 <code>new()</code> 或 <code>make()</code> 显式创建的对象总是位于堆上。</li><li>全局变量：全局变量或包级变量通常存储在静态区域，但在某些情况下也可以认为它们是在堆上。</li><li>大数组：如果数组很大，可能会被分配在堆上。</li><li>切片：虽然切片本身（即切片头）通常很小且存储在栈上，但它指向的数据（元素）可能位于堆上。</li><li>指针：指针本身通常存储在栈上，但它指向的数据可能位于堆上。</li></ul><p>总结</p><ul><li><strong>栈</strong>：用于存储函数的局部变量和参数，通常是快速访问的小对象。</li><li><strong>堆</strong>：用于存储动态分配的对象和大型结构体，这些对象通常具有较长的生命周期。</li></ul><p><strong>逃逸分析</strong></p><p>既然栈内存的效率更高，肯定是优先使用栈内存。那么<code>Go</code>语言是如何判断一个变量应该分配到堆上还是栈上的呢？这就需要逃逸分析了。<strong>逃逸分析</strong>也就是编译器决定哪些变量放在栈，哪些放在堆中。下面我通过一个示例来讲解逃逸分析，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    newString()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newString</span><span class="hljs-params">()</span></span> *<span class="hljs-type">string</span>&#123;<br>    s:=<span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)<br>    *s= <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>现在通过编译函数 <strong>-gcflags&#x3D;”-m -l”</strong> 逃逸分析来看下是否发生了逃逸，命令如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516160423235.png?raw=true" alt="image-20240516160423235"></p><ul><li><code>-m</code> 表示打印出逃逸分析信息；</li><li><code>-l</code> 表示禁止内联，可以更好地观察逃逸；</li></ul><p>从以上输出结果可以看到，发生了逃逸，也就是说<strong>指针作为函数返回值的时候，一定会发生逃逸</strong>。逃逸到堆内存的变量不能马上被回收，只能通过垃圾回收标记清除，增加了垃圾回收的压力，所以要尽可能地避免逃逸，让变量分配在栈内存上，这样函数返回时就可以回收资源，提升效率。</p><p>下面我对<code>newString</code>函数进行了避免逃逸的优化，优化后的函数代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newString</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span>&#123;<br>    s:=<span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)<br>    *s = <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">return</span> *s<br>&#125;<br></code></pre></td></tr></table></figure><p>再次通过命令查看以上代码的逃逸分析，命令如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516161150292.png?raw=true" alt="image-20240516161150292"></p><p>通过分析结果可以看到，虽然还是声明了指针变量 <code>s</code>，但是函数返回的并不是指针，所以没有发生逃逸。逃逸分析是判断变量是分配在堆上还是栈上的一种方法，在实际的项目中要尽可能避免逃逸，这样就不会被 <code>GC</code> 拖慢速度，从而提升效率。</p><blockquote><p>Tips：从逃逸分析来看，<strong>指针虽然可以减少内存的拷贝，但它同样会引起逃逸</strong>，所以要根据实际情况选择是否使用指针。</p></blockquote><p>取地址发生逃逸：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span></span> *Data &#123;<br><span class="hljs-keyword">var</span> d Data<br><span class="hljs-keyword">return</span> &amp;d<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(demo())<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516161542225.png?raw=true" alt="image-20240516161542225"></p><p>moved to heap: d。这句话表示， Go 编译器已经确认如果将 d 变量分配在栈上是无法保证程序最终结果的。如果坚持这样做，demo() 的返回值将是 Data 结构的一个不可预知的内存地址。这种情况一般是 C&#x2F;C++ 语言中容易犯错的地方 ：引用了一个函数局部变量的地址。</p><p>Go 语言最终选择将 d 的 Data 结构分配在堆上。然后由垃圾回收器去回收 d 的内存 。</p><p><strong>变量发生逃逸的情况可以总结如下：</strong></p><ul><li><strong>指针逃逸</strong>：函数返回值为局部变量的指针，虽然函数退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</li><li><strong>栈空间不足</strong>：一个栈的默认大小是 2K，它会自动扩容，最大值取决于系统的配置。当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。例如：s :&#x3D; make([]int, 10000, 10000)，此时 s 就会因为太大被分配到堆上。</li><li><strong>变量大小不确定</strong>：例如：number &#x3D; 10; s :&#x3D; make([]int, number)，此时由于编译期间无法确定slice大长度，所以会被分配到堆上，如果直接写成: s :&#x3D; make([]int, 10)，则不会发生逃逸。</li><li><strong>动态类型</strong>：就是在编译期间不能确定参数的类型，参数的长度，此时就是发生逃逸。比如空接口interface{}可以表示任意类型，如果函数入参为interface{}，编译期间无法确定其参数的具体类型，就会发生逃逸。例如： fmt.Println() 的参数类型为 interface{}，因此会导致打印的对象逃逸到堆上。</li><li><strong>闭包引用对象</strong>：当闭包函数访问了外部变量 n，变量 n 占用的内存不能随着闭包函数的退出而回收，变量 n 将会一直存在，直到被GC回收。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li></ul><p><strong>优化技巧</strong></p><p>​</p><ul><li>尽可能避免逃逸，因为栈内存效率更高，还不用 GC。比如小对象的传参尽量不使用指针，能用数组就不要用切片。</li><li>如果避免不了逃逸，还是在堆上分配了内存，那么对于频繁的内存申请操作，我们要学会重用内存，比如使用 sync.Pool。</li><li>选用合适的算法，达到高性能的目的，比如空间换时间。</li></ul><blockquote><p><strong>Tips：性能优化的时候，要结合基准测试，来验证自己的优化是否有提升。</strong></p></blockquote><p>以上是基于 Go 语言的内存管理机制总结出的 3 个方向的技巧，基于这 3 个大方向基本上可以优化出你想要的效果。除此之外，还有一些小技巧，比如<strong>要尽可能避免使用锁、并发加锁的范围要尽可能小、使用 StringBuilder 做 string 和 []byte 之间的转换、defer 嵌套不要太多</strong>等等。</p><h2 id="GC——垃圾回收"><a href="#GC——垃圾回收" class="headerlink" title="GC——垃圾回收"></a>GC——垃圾回收</h2><p>Go语言的垃圾回收（Garbage Collection, GC）机制是其运行时系统的重要组成部分，它自动管理内存，释放不再使用的对象占用的空间，从而极大地简化了程序员的工作，避免了常见的内存泄漏和悬挂指针等问题。Go的GC设计旨在提供高性能和低延迟，特别强调了对延迟敏感的应用场景的支持</p><p>具体操作：</p><ol><li>GC开始将栈上的可达对象全部扫描并标记为黑色</li><li>GC期间，任何在栈上创建的新对象，均为黑色</li><li>堆上被删除对象标记为灰色</li><li>堆上被添加的对象标记为灰色</li></ol><p>颜色基本概念：</p><ol><li><strong>白色</strong>：表示对象尚未被访问或标记，可能是垃圾或者仍然活动的对象。</li><li><strong>灰色</strong>：表示对象已被访问，但其引用的对象（子对象）尚未被检查。换句话说，灰色对象是指那些已知有至少一个指向它的引用存在，但其自身的引用列表还未被遍历的对象。</li><li><strong>黑色</strong>：表示对象及其所有引用的对象都已经完全检查并标记，确认为活动对象。</li></ol><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240712161448341.png?raw=true" alt="三色标记法"></p><p>在GC周期中，对象从白色变为灰色的过程发生在“标记”阶段，当GC遍历对象图时。具体而言，当GC遇到一个对象并确认它是活动的（即有根集或其他已知活动对象指向它），它会将该对象标记为灰色，并将其加入到待处理队列中。然后，GC会遍历这个对象的引用列表，访问并标记每个被引用的对象。一旦对象的所有引用都被检查完毕，该对象就会被标记为黑色，表示它和其引用的对象都是活动的。</p><p>简而言之，对象被标记为灰色是在GC过程中，当它首次被访问并且GC正在检查其引用的对象时。一旦它的所有引用都被检查完毕，它就会变成黑色，表明它是一个活动对象。白色对象可能最终被回收，如果在整个GC周期结束后它们仍然没有被标记为黑色或灰色。</p><p><strong><code>GC垃圾收集的多个阶段：</code></strong></p><ol><li><p>标记准备阶段</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">启动后台标记任务<br>暂停程序（STW），所有的处理器在这时会进入安全点（Safe point）；<br>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；<br>将根对象入队<br>开启写屏障<br></code></pre></td></tr></table></figure></li><li><p>标记阶段</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">恢复用户协程<br>使用三色标记法开始标记，此时用户协程和标记协程并发执行<br></code></pre></td></tr></table></figure></li><li><p>标记终止阶段</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">暂停用户协程<br>计算下一次触发GC时需要达到的堆目标<br>唤醒后台清扫协程<br></code></pre></td></tr></table></figure></li><li><p>清理阶段</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">关闭写屏障<br>恢复用户协程<br>异步清理回收<br></code></pre></td></tr></table></figure></li></ol><p><code>写屏障</code></p><p>写屏障（Write Barrier）是GC中用于保护标记过程完整性的一种机制，尤其是在并发执行期间。当一个对象引用被修改时（无论是创建新引用还是更新现有引用），写屏障会介入并确保GC的相关数据结构得到更新，以反映最新的对象引用状态。</p><p>在Go中，写屏障主要在以下两种场景下发挥作用：</p><ol><li><strong>对象分配</strong>：当一个新的对象被分配时，写屏障会确保该对象被正确地标记为灰色，即使在GC周期中。</li><li><strong>对象引用更新</strong>：当一个对象引用被更新时，写屏障会检查并更新相关对象的状态，确保标记过程的准确性不受并发修改的影响。</li></ol><p> 实际上，<strong>垃圾回收机制只用于回收堆上的内存</strong>，栈中的内存如局部变量、函数调用等会在调用结束后自动释放。也就是说，屏障机制只能作用于堆对象。</p><p><code>什么是根对象？</code></p><p>根对象（root object）是指那些能够从全局可达的地方访问到的对象。垃圾回收器会从根对象开始，通过遍历根对象的引用关系，逐步追踪并标记所有可达的对象。任何未被标记的对象都会被认为是垃圾，最终被回收释放。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">全局变量：全局变量可以被程序中的任何位置引用到，因此是根对象。<br>当前正在执行的函数的局部变量：当一个函数正在执行时，其局部变量可以被当前函数中的代码访问到，因此也是根对象。<br>当前正在执行的 goroutine 的栈中的变量：goroutine 是 Go语言并发编程中的轻量级线程，每个 goroutine 都有一块独立的栈空间，其中的变量可以被当前 goroutine 访问到，也是根对象。<br>其他和运行时系统相关的数据结构和变量。<br></code></pre></td></tr></table></figure><p><code>三色标记法的缺点：</code></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">暂停时间：在进行垃圾回收时，必须停止程序执行，这会导致应用程序暂停。引入写屏障保护可以减少暂停时间，但仍然可能导致性能下降。<br>内存开销：三色标记法需要为每个对象维护额外的状态信息，以记录其标记状态。这会增加内存开销，并可能对内存资源造成负担。<br>频繁的垃圾回收：三色标记法需要频繁地迭代标记和清除对象，如果要回收的垃圾对象很多，可能会导致回收过程变得非常耗时。<br>碎片化：垃圾回收过程中，如果频繁进行对象的移动和重新分配内存，可能会导致内存碎片化，降低内存的利用率。<br></code></pre></td></tr></table></figure><p><code>GC的触发条件</code></p><ol><li>主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。</li><li>被动触发，分为两种方式：</li></ol><p>​2.1 使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。</p><p>​2.2 使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</p><p><code>GC调优</code></p><ol><li>控制内存分配的速度，限制Goroutine 的数量，提高赋值器mutator的CPU利用率（降低GC的CPU利用率）</li><li>少量使用+连接string</li><li>slice提前分配足够的内存来降低扩容带来的拷贝</li><li>避免map key对象过多，导致扫描时间增加</li><li>变量复用，减少对象分配</li><li>增大GOGC的值，降低GC的运行频率</li></ol><h2 id="GMP调度"><a href="#GMP调度" class="headerlink" title="GMP调度"></a>GMP调度</h2><p>Goroutine是Go语言中实现并发的关键组件，它是一种轻量级的线程，由Go运行时系统管理调度。Goroutine的调度策略是Go并发模型的核心，它决定了Goroutine如何在多个处理器核心上运行，以及如何在系统资源有限的情况下高效地管理并发任务。以下是Goroutine调度策略的一些关键点：</p><p><strong>调度器设计</strong></p><p>Go的调度器设计为一个两级调度模型，它包括：</p><ol><li><strong>G</strong>：代表Goroutine，是用户级的轻量级线程，它们在P上运行。</li><li><strong>M</strong>：代表Machine，即Go运行时系统中的逻辑处理器。每个M可以绑定到一个物理处理器核心上，负责执行P上的任务。</li><li><strong>P</strong>：代表Processor，是调度单位，每个P维护了一个Goroutine的就绪队列。P的数量通常由<code>GOMAXPROCS</code>环境变量决定，它控制着并发处理器的数量。</li></ol><p><img src="https://github.com/gondmhd/blogImage/blob/main/img//GMP.jpg?raw=true" alt="GMP调度"></p><p><strong>调度策略</strong></p><ol><li>**队列轮转: **P会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将G放到队列尾部，然后从队列中再取出一个G进行调度，P还会周期性的查看全局队列是否有G等待调度到M中执行</li></ol><p>​2.<strong>系统调用:</strong> 当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是M的缓存池，也可能是新建的。</p><p>​3.<strong>G0系统调用结束后的调度</strong>：.当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240715100953101.png?raw=true" alt="Goroutine调度原理图"></p><p><strong>Groutine的切换时机</strong></p><p>​1.select操作阻塞时<br>​2.io阻塞<br>​3.阻塞在channel<br>​4.程序员显示编码操作<br>​5.等待锁<br>​6.程序调用</p><p><strong>Goroutine调度原理</strong></p><p>​调度循环：每个p都有一个协程g0，调度时首先切换到协程g0，切换到接下来将要运行的协程g，再从协程g切换到协程g0，开始新一轮调度。</p><p>​goroutine调度的本质就是将**Goroutine(G)**按照一定算法放到CPU上去执行。</p><p>​CPU感知不到Goroutine，只知道内核线程，所以需要Go调度器将协程调度到内核线程上面去，然后操作系统调度器将内核线程放到CPU上去执行</p><p>​M是对内核级线程的封装，所以Go调度器的工作就是将G分配到M</p><p>​</p><p>被调度的对象：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex">G的来源<br>P的runnext(只有1个G，局部性原理，永远会被最先调度执行)<br>P的本地队列（数组，最多256个G)<br>全局G队列(链表，无限制)<br>网络轮询器network poller (存放网络调用被阻塞的G)<br><br>P的来源<br>全局P队列(数组，GOMAXPROCS个P)<br><br>M的来源<br>休眠线程队列(未绑定P，长时间休眠会等待GC回收销毁)<br>运行线程（绑定P，指向P中的G)<br>自旋线程（(绑定P，指向M的GO)<br><br></code></pre></td></tr></table></figure><p>运行线程数+自旋线程数&lt;&#x3D;P的数量（GOMAXPROCS），M个数&gt;&#x3D;P的个数</p><p>G的生命周期：G从创建、保存、被获取、调度和执行、阻塞、销毁，步骤如下:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tex">步骤1:创建G，关键字go func( )创建G<br><br>步骤2∶保存G，创建的G优先保存到本地队列P，如果P满了，则会平衡部分P到全局队列中<br>保存G的详细流程如下:<br>执行go func的时候，主线程M0会调用newproc()生成一个G结构体，这里会先选定当前M0上的P结构<br>每个协程G都会被尝试先放到P中的runnext，若runnext 为空则放到runnext中，生产结束<br>若runnext满，则将原来runnext中的G踢到本地队列中，将当前G放到runnext中，生产结束<br>若本地队列也满了，则将本地队列中的G拿出一半，放到全局队列中，生产结束。<br><br>步骤3∶唤醒或者新建M执行任务，进入调度循环（步骤4,5,6)<br><br>步骤4∶M获取G，M首先从P的本地队列获取G，如果P为空，则从全局队列获取G，如果全局队列也为<br>空，则从另一个本地队列偷取一半数量的G(负载均衡)，这种从其它P偷的方式称之为work stealing<br><br>步骤5: M调度和执行G，M调用G.func()函数执行G<br>如果M在执行G的过程发生系统调用阻塞（同步)，会阻塞G和M(操作系统限制)，此时P会和当前M解绑，<br>并寻找新的M，如果没有空闲的M就会新建一个M，接管正在阻塞G所属的P，接着继续执行P中其余的<br>G，这种阻塞后释放P的方式称之为hand off。当系统调用结束后，这个G会尝试获取一个空闲的P执行，<br>优先获取之前绑定的P，并放入到这个P的本地队列，如果获取不到P，那么这个线程M变成休眠状态，加<br>入到空闲线程中，然后这个G会被放入到全局队列中。<br>如果M在执行G的过程发生网络IO等操作阻塞时(异步)，阻塞G，不会阻塞M。M会寻找P中其它可执行的<br>G继续执行，G会被网络轮询器network poller接手，当阻塞的G恢复后，G1从network poller被移回到P的<br>LRQ中，重新进入可执行状态。异步情况下，通过调度，Go scheduler成功地将I/O的任务转变成了<br>CPU任务，或者说将内核级别的线程切换转变成了用户级别的goroutine切换，大大提高了效率。<br><br>步骤6∶M执行完G后清理现场，重新进入调度循环（将M上运行的goroutine切换为G0，G0负责调度时<br>协程的切换)<br></code></pre></td></tr></table></figure><p>使用什么策略来挑选下一个goroutine执行?</p><p>由于P中的G分布在runnext、本地队列、全局队列、网络轮询器中，则需要挨个判断是否有可执行的G，大体逻辑如下:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">每执行61次调度循环，从全局队列获取G，若有则直接返回<br>从P上的runnext看一下是否有G，若有则直接返回<br>从P上的本地队列看一下是否有G，若有则直接返回<br>上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取,t一直阻塞直到获取到一个可用的G为止<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础</title>
    <link href="/2024/12/10/docker/Docker%E5%85%A5%E9%97%A8/"/>
    <url>/2024/12/10/docker/Docker%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官方文档地址：<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p><p>中文参考手册：<a href="https://docker_practice.gitee.io/zh-cn">https://docker_practice.gitee.io/zh-cn</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-什么是-docker"><a href="#1-1-什么是-docker" class="headerlink" title="1.1 什么是 docker"></a>1.1 什么是 docker</h2><p>Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，以便快速交付软件。使用 Docker 您可以使用与管理应用程序相同的方式管理您的基础设施。通过利用 Docker 用于快速交付、测试和部署代码的方法，您可以显著减少编写代码和在生产中运行代码之间的延迟。<strong>Docker 提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程</strong></p><blockquote><p>Docker 是一个容器技术</p></blockquote><h2 id="1-2-docker-起源"><a href="#1-2-docker-起源" class="headerlink" title="1.2 docker 起源"></a>1.2 docker 起源</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</strong>。</p><h2 id="1-3-为什么是-docker"><a href="#1-3-为什么是-docker" class="headerlink" title="1.3 为什么是 docker"></a>1.3 为什么是 docker</h2><blockquote><p>开发的时候，本机测试环境可以跑，生产环境跑步起来</p></blockquote><p>假如上线一个 java web 项目，这个应用程序涉及很多东西如：jdk、tomcat、redis、mysql等，当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker 则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势一：一致的运行环境，更轻松的迁移</strong></p><blockquote><p>别人程序出了问题把服务器资源吃光，导致自己的应用挂掉了</p></blockquote><p>如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker 就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势二：进程级的隔离，容器与容器之间互不影响，更高效利用资源</strong></p><blockquote><p>促销活动需要临时拓展几十台服务器</p></blockquote><p>在没有 Docker 的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用 Docker 的话，只需要将程序打包成镜像，你要多少台服务，我就启动多少容器，极大地提高了部署效率。</p><p><strong>优势三: 通过镜像复制N多个环境一致容器</strong></p><h2 id="1-4-docker-与虚拟机"><a href="#1-4-docker-与虚拟机" class="headerlink" title="1.4 docker 与虚拟机"></a>1.4 docker 与虚拟机</h2><ol><li>虚拟机是携带操作系统的，docker 不携带操作系统</li><li>虚拟机调度资源步骤为：利用 Hypervisor 虚拟化内存，虚拟内存 -&gt; 虚拟物理内存 -&gt; 物理内存</li><li>docker 调度资源步骤为：利用 Docker Engine 调用宿主机资源，虚拟内存 -&gt; 物理内存</li></ol><table><thead><tr><th></th><th>传统虚拟机</th><th>Docker容器</th></tr></thead><tbody><tr><td>磁盘占用</td><td>几个GB到几十个GB左右</td><td>几十MB到几百MB左右</td></tr><tr><td>CPU内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker引擎占用极低</td></tr><tr><td>启动速度</td><td>（从开机到运行项目）几分钟</td><td>（从开启容器到运行项目）几秒</td></tr><tr><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简捷</td></tr><tr><td>耦合性</td><td>多个应用服务安装到一起，容易互相影响</td><td>每个应用服务一个容器，达成隔离</td></tr><tr><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><h2 id="1-5-docker-安装"><a href="#1-5-docker-安装" class="headerlink" title="1.5 docker 安装"></a>1.5 docker 安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 –mirror 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br></code></pre></td></tr></table></figure><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br></code></pre></td></tr></table></figure><p>个人使用的是 docker for mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install -cask docker</span><br></code></pre></td></tr></table></figure><p>或者直接去官网下载 docker for desktop</p><h2 id="1-6-docker-架构"><a href="#1-6-docker-架构" class="headerlink" title="1.6 docker 架构"></a>1.6 docker 架构</h2><ul><li>镜像：镜像代表一个应用环境，它是一个只读文件，如：mysql镜像、tomcat镜像等</li><li>容器：镜像每次运行之后会产生一个容器，即正在运行的镜像，可读可写</li><li>仓库：存档镜像的位置，用于镜像的上传和下载</li><li>Dockerfile：docker生成镜像的配置文件，用于自定义镜像的一些配置</li><li>tar：对镜像的打包文件，可以基于这个文件还原成镜像</li></ul><h2 id="1-7-docker-运行流程"><a href="#1-7-docker-运行流程" class="headerlink" title="1.7 docker 运行流程"></a>1.7 docker 运行流程</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240517140420277.png?raw=true" alt="image-20240517140420277"></p><h2 id="1-8-配置镜像加速"><a href="#1-8-配置镜像加速" class="headerlink" title="1.8 配置镜像加速"></a>1.8 配置镜像加速</h2><p>Linux 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#123;<br>    &quot;registry-mirrors&quot;:[<br>        &quot;https://hub.uuuadc.top&quot;,<br>        &quot;https://docker.anyhub.us.kg&quot;,<br>        &quot;https://dockerhub.jobcher.com&quot;,<br>        &quot;https://dockerhub.icu&quot;,<br>        &quot;https://docker.ckyl.me&quot;,<br>        &quot;https://docker.awsl9527.cn&quot;<br>    ],<br>    &quot;data-root&quot;:&quot;/home/dockerdate&quot;,<br>    &quot;log-driver&quot;:&quot;json-file&quot;,<br>    &quot;log-opts&quot;:&#123;<br>        &quot;max-size&quot;:&quot;512m&quot;,&quot;max-file&quot;:&quot;3&quot;<br>    &#125;<br>&#125;&#x27; | sudo tee /etc/docker/daemon.json<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>验证镜像加速是否生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br> Registry Mirrors:<br>  https://docker.m.daocloud.io/<br> https://dockerproxy.com/<br> https://docker.mirrors.ustc.edu.cn/<br> https://docker.nju.edu.cn/<br><br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><h1 id="二、Docker-入门"><a href="#二、Docker-入门" class="headerlink" title="二、Docker 入门"></a>二、Docker 入门</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run hello-world                                       <br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>93288797bd35: Pull complete <br>Digest: sha256:393b81f0ea5a98a7335d7ad44be96fe76ca8eb2eaa76950eb8c989ebf2b78ec0<br>Status: Downloaded newer image for hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.<br>    (arm64v8)<br> 3. The Docker daemon created a new container from that image which runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, which sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br><span class="hljs-meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span><br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h2 id="2-1-辅助命令"><a href="#2-1-辅助命令" class="headerlink" title="2.1 辅助命令"></a>2.1 辅助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看docker信息</span><br>docker version<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看消息信息</span><br>docker info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>docker --help<br></code></pre></td></tr></table></figure><h2 id="2-2-镜像命令"><a href="#2-2-镜像命令" class="headerlink" title="2.2 镜像命令"></a>2.2 镜像命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机所有镜像</span><br>docker images<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有镜像(包含中间镜像层)</span><br>  docker images -a<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">只显示镜像<span class="hljs-built_in">id</span>(用于批量删除)</span><br>  docker -q<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索镜像</span><br>docker search [options] 镜像名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示完整信息</span><br>docker search --no-trunc tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅镜像名默认下载 latest</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除镜像</span><br>docker image rm 镜像名|镜像ID<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">简写</span><br>  docker rmi 镜像名|镜像ID<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">强制删除</span><br>  docker rmi -f 镜像名|镜像ID<br></code></pre></td></tr></table></figure><p>补充：</p><p>docker images 展示的镜像信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">REPOSITORY       TAG       IMAGE ID       CREATED       SIZE<br></code></pre></td></tr></table></figure><ul><li>REPOSITORY：仓库，即镜像名称</li><li>TAG：分支，可以理解为版本号</li><li>IMAGE ID：镜像ID，全网唯一</li><li>CREATED：镜像构建时间</li><li>SIZE：镜像大小</li></ul><p>docker 命令提供类似 Linux 的管道功能，如删除所有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker rmi -f $(docker images -q)<br></code></pre></td></tr></table></figure><h2 id="2-3-容器命令"><a href="#2-3-容器命令" class="headerlink" title="2.3 容器命令"></a>2.3 容器命令</h2><p>通常我们准备下载一个镜像不会通过 docker search，因为展示出来的信息不包含分支信息，即版本号，一般会在<a href="https://hub.docker.com/">dockerhub</a>网站搜索我们需要的镜像的具体分支，比如：下载tomcat</p><p>选择适合的版本复制命令下载镜像 <code>docker pull tomcat:latest</code></p><p><strong>运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>后台运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d tomcat:latest <br></code></pre></td></tr></table></figure><p>此时容器已经启动，尝试访问本机 8080 端口，发现拒绝连接，这是因为 docker 的特点：线程级隔离，相当于此时 tomcat 独自运行在本机的一个虚拟机中，若要实现容器和宿主机的通信，需要映射容器端口。</p><p><strong>映射容器端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8080:8080 tomcat:latest<br></code></pre></td></tr></table></figure><p>格式：-p 宿主机端口:容器端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker ps                <br>CONTAINER IDIMAGECOMMANDCREATEDSTATUSPORTSNAMES<br></code></pre></td></tr></table></figure><ul><li>CONTAINER ID：容器ID，唯一</li><li>IMAGE：容器基于的镜像</li><li>COMMAND：容器启动执行的命令</li><li>CREATED：容器创建的时间</li><li>STATUS：容器此时的状态</li><li>PORTS：容器端口信息</li><li>NAMES：容器名称，唯一</li></ul><p>基于容器的操作不仅可以使用 CONTAINER ID 也可以使用 NAMES</p><p>拓展参数：</p><ul><li>-a:查看所有容器(正在运行和历史运行过的容器)</li><li>-q:静默模式，只显示容器ID</li></ul><p><strong>运行容器指定名称</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8081:8080 --name tomcat01 tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>停止|关闭|重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br>docker start 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭容器</span><br>docker stop 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">立刻停止容器</span><br>docker kill 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>上述这些命令搭配 <code>docker ps -q</code> 可实现批量操作</p><blockquote><p>docker run 和 docker start 区别：run 运行镜像，创建一个新的容器；start 仅启动一个历史容器</p></blockquote><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>正在运行的容器不可以被删除，使用 -f 可以强制删除，额外：<code>docker rm -f $(docker ps -aq)</code> 删除所有容器！！！</p><p><strong>查看容器内的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>和 top 命令效果一样</p><p><strong>查看容器的运行日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [options] 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>options:</p><ul><li>-t:加入时间戳</li><li>-f:阻塞实时打印日志</li><li>–tail int:打印日志最后n条</li></ul><p><strong>进入容器内部</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [options] 容器名字或者容器ID 容器内命令<br></code></pre></td></tr></table></figure><p>options:</p><ul><li>-i:以交互式运行容器</li><li>-t:分配一个 tty</li></ul><p>通常这个命令是固定写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it tomcat01 bash<br></code></pre></td></tr></table></figure><p>这个镜像搭载着一个轻量级的 linux 系统，支持一些常用的命令(exit退出)</p><p><strong>容器与宿主机传输文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">宿主机文件(夹) -&gt; 容器</span><br>docker cp 宿主机文件(夹) 容器id|名称:容器路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器 -&gt; 宿主机文件(夹)</span><br>docker cp 容器id|名称:容器路径 宿主机文件(夹)<br></code></pre></td></tr></table></figure><p>注：宿主机文件(夹)一定要是绝对路径</p><p>回到上面访问宿主机 8080 端口 404 问题，这是因为容器中 tomcat&#x2F;webapps 下没有文件。我们可以借助这个命令将本机的一些 war 包，或者官网 tomcat 目录下的东西放进去即可</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">➜  ~ docker cp ~/<span class="hljs-keyword">env</span>/tomcat/webapps tomcat01:/usr/local/tomcat<br></code></pre></td></tr></table></figure><p>再次访问即可出现经典的劈叉猫</p><p><strong>容器与宿主机共享目录</strong></p><p>尝试删除运行的tomcat容器，以相同的方式再次运行一个容器，发现 webapps 下依然是空的，这说明容器被删除后容器内所有文件都会被删除，当一些重要的数据我们就不能放在容器里面，因此 docker 提供<strong>数据卷</strong>的功能将容器的目录挂载到宿主机的目录，实现数据的持久化(更多数据卷的内容见后面的高级部分)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v 宿主机的绝对路径|任意别名:/容器内的路径 镜像名<br></code></pre></td></tr></table></figure><ol><li>如果是宿主机路径：必须是绝对路径，宿主机目录会覆盖容器内目录内容</li><li>如果是别名：运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中；若别名存在宿主机目录会覆盖容器内目录内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载宿主机目录</span><br>➜  ~ docker run -d -p 8081:8080 --name tomcat04 -v ~/env/tomcat/webapps:/usr/local/tomcat/webapps tomcat:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动创建数据卷(如果不存在的话)</span><br>➜  ~ docker run -d -p 8083:8080 --name tomcat07 -v v_t:/usr/local/tomcat/webapps tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>打包镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save 镜像名 -o 路径/名称.tar<br></code></pre></td></tr></table></figure><p><strong>载入镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i 名称.tar<br></code></pre></td></tr></table></figure><p><strong>将容器打包成镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交dockerhub(一般不提交，需要登录dockerhub)</span><br>docker push 镜像名称:标签<br></code></pre></td></tr></table></figure><h1 id="三、docker-高级"><a href="#三、docker-高级" class="headerlink" title="三、docker 高级"></a>三、docker 高级</h1><h2 id="3-1-镜像原理"><a href="#3-1-镜像原理" class="headerlink" title="3.1 镜像原理"></a>3.1 镜像原理</h2><h3 id="3-1-1-什么是镜像"><a href="#3-1-1-什么是镜像" class="headerlink" title="3.1.1 什么是镜像"></a>3.1.1 什么是镜像</h3><p>Docker 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p><h3 id="3-1-2-为什么镜像这么大"><a href="#3-1-2-为什么镜像这么大" class="headerlink" title="3.1.2 为什么镜像这么大"></a>3.1.2 为什么镜像这么大</h3><p>可以看到 docker 中一个 tomcat 镜像居然高达 670M，这是为什么？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker images                             <br>REPOSITORY       TAG       IMAGE ID       CREATED        SIZE<br>tomcat           latest    eadaf4390f32   29 hours ago   670MB<br>kpretty/tomcat   v1.0      3c447801519f   2 days ago     674MB<br>debian           latest    a331823f8665   2 days ago     118MB<br>hello-world      latest    18e5af790473   6 days ago     9.14kB<br>centos           centos7   dfc30428e163   2 weeks ago    301MB<br></code></pre></td></tr></table></figure><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像，就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。因此对于 tomcat 镜像来说，不仅包含 tomcat 程序包，还包含 tomcat 运行所依赖的所有环境。</p><h3 id="3-1-3-镜像原理"><a href="#3-1-3-镜像原理" class="headerlink" title="3.1.3 镜像原理"></a>3.1.3 镜像原理</h3><p><strong>UnionFs(联合文件系统)</strong></p><p>UnionFs 是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFs 是Docker 镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p><blockquote><p>Docker 的镜像实际是由一层一层的文件系统组成</p></blockquote><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</p><p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p><img src="https://s3.jpg.cm/2021/09/30/ImfzH5.png?raw=true" style="zoom:100%;" /><p>但docker的镜像不包含操作系统，因为docker与宿主机共享内核。</p><h3 id="3-1-4-分层结构"><a href="#3-1-4-分层结构" class="headerlink" title="3.1.4 分层结构"></a>3.1.4 分层结构</h3><p>这种分层结构在 pull 镜像是会体现出来，一份镜像会分好几几个分支下载，同时有的分支还提示已存在。</p><p>这种分层结构最大的好处就是资源共享，多个镜像都是从相同的 base 镜像构建而来，那么宿主机只需要保存一份 base 镜像；同时内存也只需要加载一份 base 镜像即可。</p><h2 id="3-2-网络原理"><a href="#3-2-网络原理" class="headerlink" title="3.2 网络原理"></a>3.2 网络原理</h2><p>当 docker 启动时，会自动在主机上创建一个 bridge 的虚拟网桥，可以理解为一个软件交换机，它会在挂载到它的网口之间进行转发。同时，docker 随机分配一个本地未占用的私有网段中的一个地址给 bridge 接口，此后启动的容器内的网口也会自动分配一个同网段的地址。</p><p>当创建一个 docker 容器的时候，同时会创建一对 veth pair 接口，这一对接口一段在容器内为 eth0；另一端在本地被挂载到 bridge 网桥以 veth 开头，通过这种方式，主机可以跟容器通信，挂载在同一网桥的容器也可以互相通信，docker就创建了在主机和所有容器之间的一个虚拟网络共享，这种方式为<strong>桥接模式</strong>，是docker默认的网络模式也是推荐的网络模式。</p><h3 id="3-2-1-查看网络信息"><a href="#3-2-1-查看网络信息" class="headerlink" title="3.2.1 查看网络信息"></a>3.2.1 查看网络信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network ls            <br>NETWORK ID     NAME      DRIVER    SCOPE<br>63893e5e4e77   bridge    bridge    local<br>2c90c0c62179   host      host      local<br>8347580e4ecb   none      null      local<br></code></pre></td></tr></table></figure><p>这里的 bridge 就是上面所说的默认网桥，运行容器默认挂载在这个网桥上</p><h3 id="3-2-2-创建一个网桥"><a href="#3-2-2-创建一个网桥" class="headerlink" title="3.2.2 创建一个网桥"></a>3.2.2 创建一个网桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network create 网桥名称<br></code></pre></td></tr></table></figure><h3 id="3-2-3-删除一个网桥"><a href="#3-2-3-删除一个网桥" class="headerlink" title="3.2.3 删除一个网桥"></a>3.2.3 删除一个网桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network rm 网桥名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-2-4-查看网桥细节"><a href="#3-2-4-查看网桥细节" class="headerlink" title="3.2.4 查看网桥细节"></a>3.2.4 查看网桥细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect 网桥名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-2-5-容器之间通信"><a href="#3-2-5-容器之间通信" class="headerlink" title="3.2.5 容器之间通信"></a>3.2.5 容器之间通信</h3><p>根据 docker 的网络原因，实现容器间的通信，只需要保证容器挂载在相同网桥上即可，其实默认直接启动容器之间就可以直接通信，但通常我们会一个业务创建一个网桥，将相同业务的容器挂载到一个网桥，业务与业务之间网络是隔离的防止干扰</p><p>创建一个网桥 docker0 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network create docker0<br></code></pre></td></tr></table></figure><p>查看网桥信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect docker0<br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;docker0&quot;,<br>        &quot;Id&quot;: &quot;e283a82de3852629506a0b1e2957560109ca22d49b1c1708d90af17385da7839&quot;,<br>        &quot;Created&quot;: &quot;2021-10-01T09:37:57.434314302Z&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: &#123;&#125;,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;172.22.0.0/16&quot;,<br>                    &quot;Gateway&quot;: &quot;172.22.0.1&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: false,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        &quot;Containers&quot;: &#123;&#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;&#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>发现这个网桥分配了一个 172.22 的子网端，之后挂载在这个网桥上的容器都会是这个网段内</p><p>运行容器指定挂载的网桥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8080:8080 --name tomcat01 --network docker0 tomcat:latest<br>c17deed4f99312568f8189217b78254f58f27fc992e019bce90f2e908d4a3f07<br>➜  ~ docker run -d -p 8081:8080 --name tomcat02 --network docker0 tomcat:latest<br>ab4b13fd2b78f7610a1d71d3b1ea4a26bac82fde15fbd025bdcd07e69c6bc5c2<br></code></pre></td></tr></table></figure><p>再次查看网桥信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect docker0                                            <br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;docker0&quot;,<br>        &quot;Id&quot;: &quot;e283a82de3852629506a0b1e2957560109ca22d49b1c1708d90af17385da7839&quot;,<br>        &quot;Created&quot;: &quot;2021-10-01T09:37:57.434314302Z&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: &#123;&#125;,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;172.22.0.0/16&quot;,<br>                    &quot;Gateway&quot;: &quot;172.22.0.1&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: false,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        &quot;Containers&quot;: &#123;<br>            &quot;ab4b13fd2b78f7610a1d71d3b1ea4a26bac82fde15fbd025bdcd07e69c6bc5c2&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat02&quot;,<br>                &quot;EndpointID&quot;: &quot;61e0436bc9b437eb65989b2a1de22d44cae6dcea8cff862b97308167d9f7988a&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:16:00:03&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.22.0.3/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;,<br>            &quot;c17deed4f99312568f8189217b78254f58f27fc992e019bce90f2e908d4a3f07&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat01&quot;,<br>                &quot;EndpointID&quot;: &quot;beb19cd9621e9cd98a8654555a59b8753b3d014c788f229d76f320569dab264d&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:16:00:02&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.22.0.2/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;<br>        &#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;&#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>两个容器分别被分配了 172.22.0.3、172.22.0.2，下面进入其中一个容器 curl 另一个容器的8080端口(因为tomcat构建的容器只支持基本的一些命令，没有ping)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@c17deed4f993:/usr/local/tomcat# curl http://172.22.0.3:8080<br></code></pre></td></tr></table></figure><p>同时 docker 会自动的对容器的名称和ip做映射，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@c17deed4f993:/usr/local/tomcat# curl http://tomcat02:8080<br></code></pre></td></tr></table></figure><h2 id="3-3-数据卷"><a href="#3-3-数据卷" class="headerlink" title="3.3 数据卷"></a>3.3 数据卷</h2><p>数据卷是一个可供一个或者多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认还一直存在，集市容器被删除</li></ol><blockquote><p>数据卷的使用，类似 Liunx 下对目录或者文件进行 mount，镜像中的被指定为挂载点的目录中的文件恢复至到数据卷中(仅数据卷为空)</p></blockquote><h3 id="3-3-1-创建数据卷"><a href="#3-3-1-创建数据卷" class="headerlink" title="3.3.1 创建数据卷"></a>3.3.1 创建数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create 数据卷名称<br></code></pre></td></tr></table></figure><h3 id="3-3-2-查看数据卷"><a href="#3-3-2-查看数据卷" class="headerlink" title="3.3.2 查看数据卷"></a>3.3.2 查看数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume inspect 数据卷名称|ID<br>如：<br>➜  ~ docker volume inspect volume1 <br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2021-10-01T11:43:33Z&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: &#123;&#125;,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/volume1/_data&quot;,<br>        &quot;Name&quot;: &quot;volume1&quot;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>其中，Mountpoint 为挂载在宿主机的目录</p><h3 id="3-3-3-挂载数据卷"><a href="#3-3-3-挂载数据卷" class="headerlink" title="3.3.3 挂载数据卷"></a>3.3.3 挂载数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~ docker run -d -p 8081:8080 --name tomcat03 -v volume01:/usr/local/tomcat/webapps/ tomcat:latest<br></code></pre></td></tr></table></figure><h3 id="3-3-4-删除数据卷"><a href="#3-3-4-删除数据卷" class="headerlink" title="3.3.4 删除数据卷"></a>3.3.4 删除数据卷</h3><p>正在被使用的数据卷无法被删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume rm 数据卷名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-3-5-Mac下的数据卷"><a href="#3-3-5-Mac下的数据卷" class="headerlink" title="3.3.5 Mac下的数据卷"></a>3.3.5 Mac下的数据卷</h3><p>Linux下数据卷的Mountpoint路径真实存在，直接 cd 即可看到容器内的文件，但对于 mac 来说</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cd /var/lib/docker/volumes/volume1/_data  <br>cd: no such file or directory: /var/lib/docker/volumes/volume1/_data<br></code></pre></td></tr></table></figure><p>网上很多人给的方法是通过 screen，如数据卷会被放在下面的 tty 中，但实际是没有的，很多人也反馈没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cd Library/Containers/com.docker.docker/Data/vms/0/<br>➜  0 pwd                  <br>/Users/wjun/Library/Containers/com.docker.docker/Data/vms/0<br>➜  0 ll<br>total 0<br>srwxr-xr-x  1 wjun  staff   0  9 28 14:45 00000002.00001003<br>srwxr-xr-x  1 wjun  staff   0  9 28 14:45 console.sock<br>drwxr-xr-x@ 3 wjun  staff  96  9 30 11:12 data<br>drwxr-xr-x  2 wjun  staff  64  9 27 18:30 log<br></code></pre></td></tr></table></figure><p>经过不懈努力终于在墙外找到了解决方案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh<br></code></pre></td></tr></table></figure><p>运行这个镜像，进入容器中 cd 到指定路径就能看到 mac 的挂载点</p><h1 id="四、Dockerfile"><a href="#四、Dockerfile" class="headerlink" title="四、Dockerfile"></a>四、Dockerfile</h1><p>Dockerfile 是 Docker 镜像的描述文件，是由一系列命令和参数构成的脚本，主要作用是用来构建 docker 镜像的构建文件。</p><h2 id="4-1-Dockerfile解析过程"><a href="#4-1-Dockerfile解析过程" class="headerlink" title="4.1 Dockerfile解析过程"></a>4.1 Dockerfile解析过程</h2><p>通常这个描述文件就叫 Dockerfile，该文件所在的目录称之为 docker 的上下文目录，当基于 Dockerfile 开始构建镜像时，首先将上下文目录里的所有文件发送给 docker server，在服务端完成构建；在构建镜像过程中，Dockerfile 中每一个命令都会生成一个镜像层，下一个的命令基于上一个命令生成的镜像继续构建，形成一个个的镜像层，同时每个镜像层都会被缓存，当遇到相同的命令会直接使用，最终构建完成后体现给用户的只有最终的镜像。</p><p>根据上面的解释，一般在构建镜像时会新建一个空白目录，该目录仅放置 Dockerfile 和与构建镜像所必须的文件；无关紧要的文件会影响构建速度，但 docker 也提供类似 gitignore 的作用，在上下文目录中新建 .dockerignore 文件，docker 会忽略该文件里面指定的内容。</p><img src="https://s3.jpg.cm/2021/10/01/ImyooX.png?raw=true" style="zoom:100%;" /><h2 id="4-2-Dockerfile保留命令"><a href="#4-2-Dockerfile保留命令" class="headerlink" title="4.2 Dockerfile保留命令"></a>4.2 Dockerfile保留命令</h2><p>常用命令如下(官方说明：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>)</p><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td><strong>WORKDIR</strong></td><td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td><strong>ENV</strong></td><td><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td><strong>COPY</strong></td><td><strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td><strong>VOLUME</strong></td><td><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><blockquote><p>上述命令必须大写</p></blockquote><h3 id="4-2-1-FROM"><a href="#4-2-1-FROM" class="headerlink" title="4.2.1 FROM"></a>4.2.1 FROM</h3><p>基于哪个镜像进行构建新的镜像，在构建中基于的镜像会自动从dockerhub进行拉取，且必须保证该命令作为 Dockerfile 第一个指令出现</p><p>语法如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]<br></code></pre></td></tr></table></figure><p>TAG 不写默认 latest</p><h3 id="4-2-2-MAINTAINER"><a href="#4-2-2-MAINTAINER" class="headerlink" title="4.2.2 MAINTAINER"></a>4.2.2 MAINTAINER</h3><p>镜像维护者的姓名和邮箱地址[废弃]</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-RUN"><a href="#4-2-3-RUN" class="headerlink" title="4.2.3 RUN"></a>4.2.3 RUN</h3><p>RUN 指定将在当前镜像层中执行指定的命令并提交结果，其格式有两种 shell 和 exec</p><p>shell：RUN &lt;命令&gt;如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello docker&quot;</span> &gt;&gt; /README</span><br></code></pre></td></tr></table></figure><p>exec: RUN [“可执行文件”,”参数1”,”参数2”,…]如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;&#x27;hello docker&#x27;&quot;</span>,<span class="hljs-string">&quot;&gt;&gt;&quot;</span>,<span class="hljs-string">&quot;/README&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注：上面说过每一个指令都会构建一层因此不建议写多个 RUN，多个 RUN 的结果会显得臃肿、形成非常多的镜像层，不仅增加了镜像构建的时间，也容易出错，同时 UnionFs 有最大层的显示，现版本是 127 层；要时刻提醒自己 Dockerfile 不是在写 shell 脚本，而是定义每一层的构建规则；对于多条 shell 参考写法如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -x; buildDeps=<span class="hljs-string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="language-bash">    &amp;&amp; apt-get update \</span><br><span class="language-bash">    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> redis.tar.gz \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -r /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></span><br></code></pre></td></tr></table></figure><blockquote><p>stretch 是一个空白镜像，基于此镜像构建意味着你不以任何镜像为基础，意味着你的镜像并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧</p></blockquote><h3 id="4-2-4-EXPOSE"><a href="#4-2-4-EXPOSE" class="headerlink" title="4.2.4 EXPOSE"></a>4.2.4 EXPOSE</h3><p>用于声明构建的镜像在运行为容器时对外暴露的端口，这只是一个声明，在容器运行时不会因为这而产生任何影响，该命令的好处是：帮助镜像使用者理解这个镜像服务守护端口，一方面配置映射，同时在运行是随机端口映射(-P)，会自动随机映射 EXPOSE 的端口</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 默认 TCP</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><h3 id="4-2-5-ENV"><a href="#4-2-5-ENV" class="headerlink" title="4.2.5 ENV"></a>4.2.5 ENV</h3><p>用来为构建镜像设置环境变量，该值可以在出现在后续指令环境中。</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> key value<br><span class="hljs-keyword">ENV</span> key=value<br><span class="hljs-keyword">ENV</span> k1=· k2=v2 k3=v3<br></code></pre></td></tr></table></figure><p>如官方 node 镜像就出现类似代码</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="language-bash">  &amp;&amp; grep <span class="hljs-string">&quot; node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="hljs-built_in">sha256sum</span> -c - \</span><br><span class="language-bash">  &amp;&amp; tar -xJf <span class="hljs-string">&quot;node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span><br><span class="language-bash">  &amp;&amp; <span class="hljs-built_in">rm</span> <span class="hljs-string">&quot;node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="language-bash">  &amp;&amp; <span class="hljs-built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></code></pre></td></tr></table></figure><h3 id="4-2-6-WORKDIR"><a href="#4-2-6-WORKDIR" class="headerlink" title="4.2.6 WORKDIR"></a>4.2.6 WORKDIR</h3><p>用于为 Dockerfile 中后续指令设置工作目录，如果 WORKDIR 指定的目录不存在会被自动创建</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> PATH</span><br></code></pre></td></tr></table></figure><p>该命令的好处如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>基于上述构建完的镜像发现并没有 &#x2F;app&#x2F;world.txt 文件，因为每个命令都会产生一个镜像层，第一个 RUN 仅仅是一个内存上的变化，不会对文件产生任何影响，到第二层又是一个新的镜像层自然不会继承上一层的内存变化，而 WORKDIR 会改变以后各层的工作目录位置，多个 WORKDIR 使用相对路径，则该路径与之前 WORKDIR 的路径相对即：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><p>RUN pwd 的工作路径是 &#x2F;a&#x2F;b&#x2F;c</p><h3 id="4-2-7-COPY"><a href="#4-2-7-COPY" class="headerlink" title="4.2.7 COPY"></a>4.2.7 COPY</h3><p>用于将上下文指定的文件(夹)复制到镜像的指定目录中</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;src&quot;</span>,...,<span class="hljs-string">&quot;dest&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>其 src 支持统配符，其通配规则满足 Go 的 filepath.Math，此外 COPY 会保留源文件的各种元数据信息如：读写权限，用户用户组，修改时间等；若要修改该添加 –chown 如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=bin files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=1 files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=10:11 files* /mydir/</span><br></code></pre></td></tr></table></figure><blockquote><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p></blockquote><h3 id="4-2-8-ADD"><a href="#4-2-8-ADD" class="headerlink" title="4.2.8 ADD"></a>4.2.8 ADD</h3><p>更高级的 COPY，用于从上下文中复制文件，支持链接下载，自动解压压缩包</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure><p>但是该语法语义不明，不建议使用；该语法仅限需要自动解压的场合使用，该语法可以被 COPY 配合 RUN 替代</p><h3 id="4-2-9-VOLUME"><a href="#4-2-9-VOLUME" class="headerlink" title="4.2.9 VOLUME"></a>4.2.9 VOLUME</h3><p>在数据卷章节说过，容器中重要的数据需要挂载到宿主机实现持久化，该命令可以在运行容器且没有指定数据卷时自动将 VOLUME 指定的文件目录挂载到一个自动创建的匿名数据卷中，当然在运行时指定 -v 会覆盖这个命令</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> path</span><br></code></pre></td></tr></table></figure><h3 id="4-2-10-CMD"><a href="#4-2-10-CMD" class="headerlink" title="4.2.10 CMD"></a>4.2.10 CMD</h3><p>用于启动容器指定执行的命令，在 Dockerfile 中只能有一条 CMD，多条命令只有最后一条生效</p><p>语法格式与 RUN 一致，在指令格式上推荐使用 exec 格式，如果使用 shell 格式实际命令会被包装成 sh -c 的参数进行执行如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-comment"># 实际上</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo <span class="hljs-variable">$PATH</span>&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 CMD 写为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> service nginx start</span><br></code></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 service nginx start 命令，则是希望以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”] ，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="4-2-11-ENTRYPOINT"><a href="#4-2-11-ENTRYPOINT" class="headerlink" title="4.2.11 ENTRYPOINT"></a>4.2.11 ENTRYPOINT</h3><p>用来指定容器启动时执行命令和CMD类似</p><p>格式与 CMD 一致，ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p><p>如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;ls&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这种情况最终的执行效果是 ENTRYPOINT “$CMD”，但 CMD 在启动容器时会被覆盖，假如构建的镜像名为 itest</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run itest<br></code></pre></td></tr></table></figure><p>运行结果其实是 ls &#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run itest /bin<br></code></pre></td></tr></table></figure><p>此时 CMD 命令被覆盖最终运行 ls &#x2F;bin</p><h1 id="五、Docker-Compose"><a href="#五、Docker-Compose" class="headerlink" title="五、Docker Compose"></a>五、Docker Compose</h1><p>Compose 项目是 Docker 官方的开源项目，实现对 Docker 容器集群的快速编排，其定位是：定义和运行多个 Docker 容器应用。</p><p>上一节，Dockerfile 末班文件，可以让用户很方便的定义一个单独的应用容器，然后在日常工作中经常需要多个容器相互配合。例如实现一个 web 项目，除了 web 服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p>Compose 恰好满足这样的需求，它允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个<strong>项目</strong>。</p><p>Compose 中两个重要的概念：</p><ul><li>服务：一个应用容器就是一个服务</li><li>项目：由一组关联的应用容器组合的完整业务单元，在 docker-compose.yml 中定义</li></ul><h2 id="5-1-安装与卸载"><a href="#5-1-安装与卸载" class="headerlink" title="5.1 安装与卸载"></a>5.1 安装与卸载</h2><h6 id="1-linux"><a href="#1-linux" class="headerlink" title="1.linux"></a>1.linux</h6><ul><li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose<br>$ sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h6 id="2-macos、window"><a href="#2-macos、window" class="headerlink" title="2.macos、window"></a>2.macos、window</h6><ul><li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li></ul><h6 id="3-bash命令补全"><a href="#3-bash命令补全" class="headerlink" title="3.bash命令补全"></a>3.bash命令补全</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></code></pre></td></tr></table></figure><h6 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4.卸载"></a>4.卸载</h6><ul><li>如果是二进制包方式安装的，删除二进制文件即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> /usr/local/bin/docker-compose</span><br></code></pre></td></tr></table></figure><h6 id="5-测试安装成功"><a href="#5-测试安装成功" class="headerlink" title="5.测试安装成功"></a>5.测试安装成功</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose --version</span><br> docker-compose version 1.25.5, build 4667896b<br></code></pre></td></tr></table></figure><h2 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h2><p>docker-compose 模板：<a href="https://docker_practice.gitee.io/zh-cn/compose/compose_file.html">https://docker_practice.gitee.io/zh-cn/compose/compose_file.html</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysqldb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.19</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/conf:/etc/mysql/conf.d</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/logs:/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/data:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:4.0.14</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/redis/data:/data</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span><br>    <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">ems:</span><br></code></pre></td></tr></table></figure><p>通过 docker-compose.yml 运行一组容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker-compose up    //前台启动一组服务<br>[root@centos ~]# docker-compose up -d //后台启动一组服务<br></code></pre></td></tr></table></figure><h2 id="5-3-模板文件"><a href="#5-3-模板文件" class="headerlink" title="5.3 模板文件"></a>5.3 模板文件</h2><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">examples/web</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/data&quot;</span><br></code></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p><p>下面分别介绍各个指令的用法。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./dir</span><br></code></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./dir</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile-alternate</span><br>      <span class="hljs-attr">args:</span><br>        <span class="hljs-attr">buildno:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">command:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">container_name:</span> <span class="hljs-string">docker-web-container</span><br></code></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">env_file: .<span class="hljs-built_in">env</span><br><br>env_file:<br>  - ./common.env<br>  - ./apps/web.env<br>  - /opt/secrets.env<br></code></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># common.env: Set development environment</span><br>PROG_ENV=development<br></code></pre></td></tr></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">RACK_ENV:</span> <span class="hljs-string">development</span><br>  <span class="hljs-attr">SESSION_SECRET:</span><br><br><span class="hljs-attr">environment:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">RACK_ENV=development</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">SESSION_SECRET</span><br></code></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">y|Y|<span class="hljs-built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="hljs-literal">true</span>|True|TRUE|<span class="hljs-literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF<br></code></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。(使用curl需要构建镜像的时候安装了curl)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">1m30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">orchardup/postgresql</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">a4bc65fd</span><br></code></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h4><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">some-service:</span><br>    <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">some-network</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">other-network</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">some-network:</span><br>  <span class="hljs-attr">other-network:</span><br></code></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ports:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:8000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;49100:22&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span><br></code></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h4><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-attr">net.core.somaxconn:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">net.ipv4.tcp_syncookies:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.core.somaxconn=1024</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.ipv4.tcp_syncookies=0</span><br></code></pre></td></tr></table></figure><h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ulimits:</span><br>  <span class="hljs-attr">nproc:</span> <span class="hljs-number">65535</span><br>  <span class="hljs-attr">nofile:</span><br>    <span class="hljs-attr">soft:</span> <span class="hljs-number">20000</span><br>    <span class="hljs-attr">hard:</span> <span class="hljs-number">40000</span><br></code></pre></td></tr></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/mysql</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">cache/:/tmp/cache</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">~/configs:/etc/configs/:ro</span><br></code></pre></td></tr></table></figure><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my_src:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data:/var/lib/mysql</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data:</span><br></code></pre></td></tr></table></figure><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h4><p>在<code>docker-compose.yml</code>文件中，<code>restart</code>参数用于定义服务容器在退出后的重启策略。这个参数直接对应Docker守护进程重启容器的策略，可选的类别包括：</p><ol><li>**<code>no</code>**：容器不会自动重启，即使它意外退出（这是默认值）。</li><li>**<code>on-failure</code>**：仅当容器以非零退出状态退出时，Docker才会自动重启容器。你可以选择性地指定一个重启次数限制，例如<code>on-failure:3</code>表示如果容器因为失败连续重启3次后，Docker将不再尝试重启。如果不指定次数，默认是无限重启。</li><li>**<code>always</code>**：无论容器以何种状态退出（包括正常退出、被杀死或因错误退出），Docker都会自动重启容器。</li><li>**<code>unless-stopped</code>**：容器会始终自动重启，除非它被明确地停止（通过<code>docker stop</code>或类似的命令）。即使Docker守护进程重启，此策略也会确保容器自动启动，前提是它之前是运行状态。</li></ol><p>​</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">example/web</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">worker:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">example/worker</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">on-failure:5</span><br></code></pre></td></tr></table></figure><h2 id="5-4-常用命令"><a href="#5-4-常用命令" class="headerlink" title="5.4 常用命令"></a>5.4 常用命令</h2><h5 id="1-命令对象与格式"><a href="#1-命令对象与格式" class="headerlink" title="1. 命令对象与格式"></a>1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]<br></code></pre></td></tr></table></figure><h5 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h5><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h5 id="3-命令使用说明"><a href="#3-命令使用说明" class="headerlink" title="3.命令使用说明"></a>3.命令使用说明</h5><h5 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><ul><li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p></li><li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p></li><li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p></li><li><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p></li><li><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p></li><li><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p></li><li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容，新增挂载卷则需要删除<code>rm</code>容器，重新启动，环境变量镜像等配置会更新</p></li></ul><hr><h5 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h5><ul><li>此命令将会停止 <code>up</code> 命令所启动的容器并删除它们（但不会删除数据卷，除非你使用了 <code>--volumes</code> 选项）。</li></ul><hr><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h5><ul><li>进入指定的容器。</li></ul><hr><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><hr><h5 id="restart-1"><a href="#restart-1" class="headerlink" title="restart"></a><code>restart</code></h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒），修改 的宿主机文件内容可以通过restart进行更新，修改的docker-compose.yaml配置文件不会进行更新运行，使用up。</li></ul><hr><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><hr><h5 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><hr><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><hr><h5 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h5><p>查看各个服务容器内运行的进程。</p><hr><h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列化之坑</title>
    <link href="/2024/06/07/go/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%9D%91/"/>
    <url>/2024/06/07/go/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="encoding-json"><a href="#encoding-json" class="headerlink" title="encoding&#x2F;json"></a>encoding&#x2F;json</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>JSON 作为一种数据格式，它的核心动作就是两个：<strong>序列化，反序列化</strong>。</p><p><strong>序列化就是把一个 Go 对象转化为 JSON 格式的字符串（或字节序列，这点区别不重要），反序列化则相反，把 JSON 格式的数据转化成 Go 对象</strong>。</p><p>这里说的对象是一个广义的概念，不单指结构体对象，包括 slice、map 类型数据也支持 JSON 的序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">uint</span><br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 序列化 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        Age:  <span class="hljs-number">18</span>,<br>    &#125;<br>    output, err := json.Marshal(p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;Age&quot;:18&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2 坑"></a>2 坑</h3><h4 id="2-1-公开（public）成员字段"><a href="#2-1-公开（public）成员字段" class="headerlink" title="2.1 公开（public）成员字段"></a>2.1 公开（public）成员字段</h4><p><strong>如果我们用结构体来操作 JSON，那么结构体的成员字段必须为公开成员，也就是首字母大写，私有成员无法被解析</strong>。</p><p>列子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">uint</span><br>    Name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        age:  <span class="hljs-number">18</span>,<br>    &#125;<br>    output, err := json.Marshal(p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;age&quot;:18&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output Marshal:</span><br>&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;<br><br><span class="hljs-comment">// Output Unmarshal:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce age:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>age</code> 被设为了私有变量，于是序列化后的 JSON 串中没有 <code>age</code> 这个字段了。同理，从一个 JSON 字符串反序列化为 <code>Person</code> 后，也无法正确读取到 <code>age</code> 的值。</p><h4 id="2-2-少用-map"><a href="#2-2-少用-map" class="headerlink" title="2.2 少用 map"></a>2.2 少用 map</h4><p>JSON 不仅能操作结构体，还能操作 slice、map 等类型的数据。slice 比较特殊，但 map 和结构体表现在 JSON 格式下其实是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bruce&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这种情况下，除非有特情况或需求，否则，少用 map。因为 map 会带来额外的开销，额外的代码量，以及额外的维护成本。</p><p>首先，像上面的 Person 例子，由于 ID 和 Name 是不同类型，因此我们如果要用 map 反序列化这个 JSON 数据，就只能申明一个 <code>map[string]any</code> 类型的 map。<code>any</code>，也就是 <code>interface&#123;&#125;</code> ，就意味着我们如果要单独使用 Name 或 ID 时，需要用类型断言来转换类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any<br><span class="hljs-comment">// ...反序列化 JSON 数据，代码忽略...</span><br><span class="hljs-comment">// 获取成员</span><br>name, ok := m[<span class="hljs-string">&quot;Name&quot;</span>].(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>类型断言本身就是一个额外的步骤，为防止 panic，我们还需要判断第二个参数 ok，这无疑增加了开发工作量以及代码负担。</p><p>另外，map 本身对数据就是无约束的。结构体中我们能够预先定义各成员字段以及类型，但 map 不行。这就意味着，我们只能通过文档或注释或代码本身来理解这个 map 里到底装了些什么东西。并且，结构体可以限制 JSON 数据的 key 和 value 类型不被乱改，而 map 同样无法约束 JSON 的变更，只能通过业务逻辑代码来检测。这其中的工作量和后期维护成本，想想就知道会有多少。</p><h4 id="2-3-小心结构体组合"><a href="#2-3-小心结构体组合" class="headerlink" title="2.3 小心结构体组合"></a>2.3 小心结构体组合</h4><p>Go 虽然面向对象，但没有 <code>class</code> ，只有结构体，并且结构体没有继承。因此 Go 采用了一种组合的方式来复用不同的结构体。很多时候，这种组合给我们带来了极大的便利，我们可以像操作结构体自己的成员一样去操作组合的其他结构体成员，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs css">type Person struct &#123;<br>    ID   uint<br>    Name string<br>    <span class="hljs-selector-tag">address</span><br>&#125;<br><br>type <span class="hljs-selector-tag">address</span> struct &#123;<br>    <span class="hljs-selector-tag">Code</span>   int<br>    Street string<br>&#125;<br><br>func (<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">address</span>) PrintAddr() &#123;<br>    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Code</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Street</span>)<br>&#125;<br><br>func Group() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        address: address&#123;<br>            <span class="hljs-selector-tag">Code</span>:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    // 用 <span class="hljs-selector-tag">p</span> 直接访问 <span class="hljs-selector-tag">Address</span> 的成员和方法<br>    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Code</span>, <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Street</span>)<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.PrintAddr</span>()<br>&#125;<br><br>// Output<br><span class="hljs-number">100</span> <span class="hljs-selector-tag">Main</span> St<br><span class="hljs-number">100</span> <span class="hljs-selector-tag">Main</span> St<br></code></pre></td></tr></table></figure><p>但当我们将组合融入到 JSON 的使用当中时，这里会有一个小坑需要注意。来看下面这段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 这里用的还是前面的结构体，就不重复写了。error 也不捕获了，节省篇幅。</span><br><br>func <span class="hljs-built_in">MarshalPerson</span>() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        <span class="hljs-selector-tag">address</span>: address&#123;<br>            Code:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    <span class="hljs-comment">// 用 MarshalIndent 打印更好看点</span><br>    output, _ := json<span class="hljs-selector-class">.MarshalIndent</span>(<span class="hljs-selector-tag">p</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-built_in">string</span>(output))<br>&#125;<br><br>func <span class="hljs-built_in">UnmarshalPerson</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:&#123;<span class="hljs-string">&quot;Code&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;Street&quot;</span>:<span class="hljs-string">&quot;Main St&quot;</span>&#125;&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output MarshalPerson:</span><br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Ouptput UnmarshalPerson:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce <span class="hljs-selector-tag">address</span>:&#123;Code:<span class="hljs-number">0</span> Street:&#125;&#125;<br></code></pre></td></tr></table></figure><p>但当我们将组合融入到 JSON 的使用当中时，这里会有一个小坑需要注意。来看下面这段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 这里用的还是前面的结构体，就不重复写了。error 也不捕获了，节省篇幅。</span><br><br>func <span class="hljs-built_in">MarshalPerson</span>() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        <span class="hljs-selector-tag">address</span>: address&#123;<br>            Code:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    <span class="hljs-comment">// 用 MarshalIndent 打印更好看点</span><br>    output, _ := json<span class="hljs-selector-class">.MarshalIndent</span>(<span class="hljs-selector-tag">p</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-built_in">string</span>(output))<br>&#125;<br><br>func <span class="hljs-built_in">UnmarshalPerson</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:&#123;<span class="hljs-string">&quot;Code&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;Street&quot;</span>:<span class="hljs-string">&quot;Main St&quot;</span>&#125;&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output MarshalPerson:</span><br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Ouptput UnmarshalPerson:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce <span class="hljs-selector-tag">address</span>:&#123;Code:<span class="hljs-number">0</span> Street:&#125;&#125;<br></code></pre></td></tr></table></figure><p>先看 <code>MarshalPerson</code> 函数。这里先申明了一个 Person 对象，然后用 <code>MarshalIndent</code> 美化一下序列化结果，并打印。从打印的结果中我们看到，整个 Person 对象被<strong>铺平</strong>了。对于 Person 结构体来说，尽管用了组合，但它看上去还是有一个 <code>address</code> 成员字段。所以有时候我们会想当然地以为 Person 序列化后的 JSON 长这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 想象中的 JSON 序列化结果<br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上并没有，它被铺平了。这一点倒是比较符合前面我们直接通过 Person 访问 address 成员时的感觉，即，address 的成员似乎直接变成了 Person 的成员。这是一个需要注意的地方，组合会让序列化后的 JSON 结果铺平。</p><p>另一个稍微有些反直觉的点是，address 结构体是一个私有结构体，而私有成员似乎不应该被序列化？没错，这就是组合这种形式有一点不太好的地方了：<strong>它会暴露私有组合对象的公共成员</strong>。所以这里就要注意了，<strong>这种暴露有时候是无意的，但它可能会造成不必要的数据泄漏</strong>。</p><p>然后是 <code>UnmarshalPerson</code> 函数。有了上一个函数的解读，这个就好理解了，其实还是组合后 JSON 结果被铺平的问题。因此我们如果需要反序列化回 Person 时，也需要一个铺平后的 JSON 数据。</p><p>对 Go 的使用过程中，遇到这类需要转化成 JSON 的结构体时，通常不太会用组合，除非有一些特殊的情况。毕竟它太容易带来上面提及的问题了。并且，由于 JSON 是平铺的而结构体定义上没有平铺，一旦这个结构体组被定义的越来越复杂，那么它和原始铺平的 JSON 数据就越难去直观对比了，这样会使这个代码的可读性将直线下降。</p><p>如果没有特殊需求的话（譬如原始 JSON 数据就是平铺的，并且存在多个结构体有重复字段需要复用），从我个人的角度建议，尽量这么写：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Person</span> struct &#123;<br>    <span class="hljs-type">ID</span>      int<br>    <span class="hljs-type">Name</span>    string<br>    <span class="hljs-type">Address</span> address<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-部分成员反序列化时需要小心"><a href="#2-4-部分成员反序列化时需要小心" class="headerlink" title="2.4 部分成员反序列化时需要小心"></a>2.4 部分成员反序列化时需要小心</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>    ID   uint<br>    Name string<br>&#125;<br><br><span class="hljs-comment">// PartUpdateIssue 模拟了用同一个结构体解析两个不同的 JSON 字符串的场景</span><br>func <span class="hljs-built_in">PartUpdateIssue</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    <span class="hljs-comment">// 第一个数据有 ID 字段，且不为 0</span><br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;`<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>    <span class="hljs-comment">// 第二个数据没有 ID 字段，再次用 p 反序列化，会保留上次的值</span><br>    str = `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Jim&quot;</span>&#125;`<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    <span class="hljs-comment">// 注意输出的 ID 仍然是 1</span><br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce&#125;<br>&#123;ID:<span class="hljs-number">1</span> Name:Jim&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们用同一个结构体去反复反序列化不同的 JSON 数据时，一旦某个 JSON 数据的值只包含部分成员字段的，那么未被覆盖到的成员就会残留上一次反序列化的值</strong>。其实就是个脏数据污染的问题。</p><p>解决方案也很简单：<strong>每次反序列化 JSON 时，都使用全新的结构体对象来加载数据</strong>。</p><h4 id="2-5-处理指针成员"><a href="#2-5-处理指针成员" class="headerlink" title="2.5 处理指针成员"></a>2.5 处理指针成员</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID      <span class="hljs-type">uint</span><br>    Name    <span class="hljs-type">string</span><br>    Address *Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPtr</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    _ = json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>    <span class="hljs-comment">// 下面这行会 panic</span><br>    <span class="hljs-comment">// fmt.Printf(&quot;%+v\n&quot;, p.Address.Street)</span><br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce Address:&lt;<span class="hljs-literal">nil</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>我们将 <code>Address</code> 成员定义为一个指针，此时我们去反序列化一段不包含 <code>Address</code> 的 JSON 数据时，这个指针成员由于没有对应的数据，会被置为 nil。<code>encoding/json</code> 不会为该成员创建一个空的 <code>&amp;Address</code> 。这个时候如果我们直接调用 <code>p.Address.xxx</code> ，程序就会因为 <code>p.Address</code> 为空而 panic。</p><p><strong>如果我们的结构体成员存在指针时，使用前请记得判断指针是否为空</strong>。</p><p>在创建一个有指针字段的结构体时，指针字段的赋值也会相对麻烦一些：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">int</span>    <br>    Name <span class="hljs-type">string</span> <br>    Age  *<span class="hljs-type">int</span>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        Age:  <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>),<br>    &#125;<br>    *p.Age = <span class="hljs-number">20</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-零值造成的混淆"><a href="#2-6-零值造成的混淆" class="headerlink" title="2.6 零值造成的混淆"></a>2.6 零值造成的混淆</h4><p>所谓零值，是 Golang 中变量的一个特性，我们可以简单理解为默认值。即如果我们没有显式地为某个变量赋值，则 Golang 为为其赋一个默认值。譬如前文的例子中我们已经看到的，int 默认值 0，string 空字符串，指针零值为 nil 等等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>    Name        string<br>    ChildrenCnt int<br>&#125;<br><br>func <span class="hljs-built_in">ZeroValueConfusion</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br><br>    str2 := `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Jim&quot;</span>,<span class="hljs-string">&quot;ChildrenCnt&quot;</span>:<span class="hljs-number">0</span>&#125;`<br>    <span class="hljs-selector-tag">var</span> p2 Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str2), &amp;p2)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p2)<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;Name:Bruce ChildrenCnt:<span class="hljs-number">0</span>&#125;<br>&#123;Name:Jim ChildrenCnt:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>Person</code> 结构体中添加了一个 <code>ChildrenCnt</code> 字段，用于统计该人物的子女数量。由于零值的存在，当 <code>p</code> 加载的 JSON 数据里没有 <code>ChildrenCnt</code> 数据时，该字段被赋予 0。此时就产生了误解：<strong>我们无法将这种数据缺失的对象，与子女数确实为 0 的对象区分开</strong>。如例子里的 Bruce 和 Jim，一个是数据缺失导致的子女数为 0，另一个是本来就为 0。而实际上 Bruce 的子女数量应该是“未知“，我们如果真当作 0 处理，在业务上可能就会产生问题。</p><p><strong>解决办法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name        <span class="hljs-type">string</span><br>    ChildrenCnt *<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;Name:Bruce ChildrenCnt:&lt;<span class="hljs-literal">nil</span>&gt;&#125;<br>&#123;Name:Jim ChildrenCnt:<span class="hljs-number">0xc0000124c8</span>&#125;<br></code></pre></td></tr></table></figure><p>区别产生了。Bruce 没有数据，所以 <code>ChildrenCnt</code> 是个 nil，而 Jim 则是一个非空指针。此时就能明确地知晓，Bruce 的子女数量是未知了。</p><p>本质上这种方式还是利用了零值，指针的零值</p><h4 id="2-7-标签的坑"><a href="#2-7-标签的坑" class="headerlink" title="2.7 标签的坑"></a>2.7 标签的坑</h4><p>标签也是 Golang 中一个非常重要的特性，并且常与 JSON 相伴。而且其实用过 Go 标签的读者们应该知道，标签其实是一个非常灵活、好用的东西。那这样的好特性，在使用上会有什么坑要注意呢？</p><p>一个是名称问题。Tag 可以指定 JSON 数据中字段的名称显示，这点很灵活且实用，但它同时也容易出错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PersonWrong <span class="hljs-keyword">struct</span> &#123;<br>    FirstName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;last_name&quot;`</span><br>    LastName  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;first_name&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>omitempty</code> + <strong>零值的组合有关</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;person_name&quot;`</span><br>    ChildrenCnt <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;cnt,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TagMarshal</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        Name:        <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        ChildrenCnt: <span class="hljs-number">0</span>,<br>    &#125;<br>    output, _ := json.MarshalIndent(p, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;<br>  <span class="hljs-string">&quot;person_name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在新建结构体对象 <code>p</code> 时，为 <code>ChildrenCnt</code> 赋值为 0。而因为 <code>omitempty</code> 标签的存在，<strong>它使得 JSON 被序列化或反序列化时，忽略空（empty）值。在序列化时的表现就是，输出的 JSON 数据里不包含 <code>ChildrenCnt</code>，看上去就像是没有这个数据。什么是空值？就是零值</strong>。</p><p>这种 <code>omitempty</code> 的问题又该怎么解决呢？由于本质上还是零值惹得祸，所以，用指针。</p><h3 id="3-map序列化"><a href="#3-map序列化" class="headerlink" title="3 map序列化"></a>3 map序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化 创建一个map</span><br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;name&quot;</span>:  <span class="hljs-string">&quot;Alice&quot;</span>,<br><span class="hljs-string">&quot;age&quot;</span>:   <span class="hljs-number">30</span>,<br><span class="hljs-string">&quot;hobby&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;reading&quot;</span>, <span class="hljs-string">&quot;cycling&quot;</span>&#125;,<br>&#125;<br><span class="hljs-comment">// 将map转换为JSON字符串</span><br>jsonBytes, err := json.Marshal(myMap)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error marshaling map to JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 将JSON字节切片转换为字符串并打印</span><br>jsonString := <span class="hljs-type">string</span>(jsonBytes)<br>fmt.Println(jsonString)<br>    <span class="hljs-comment">//输出  &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;hobby&quot;:[&quot;reading&quot;,&quot;cycling&quot;]&#125;</span><br><br>    <br>    <span class="hljs-comment">// 反序列化  定义一个JSON字符串，它表示一个键值对的集合</span><br>jsonString := <span class="hljs-string">`&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;is_student&quot;: false&#125;`</span><br><span class="hljs-comment">// 定义一个空的map，用于存放解码后的数据，键为字符串类型，值为interface&#123;&#125;</span><br><span class="hljs-keyword">var</span> person <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-comment">// 使用json.Unmarshal将JSON字符串解码到map中</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(jsonString), &amp;person)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error unmarshaling JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 打印解码后的map内容</span><br>fmt.Println(person)<br>    <span class="hljs-comment">//输出  map[age:30 is_student:false name:Alice]</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-切片序列化"><a href="#4-切片序列化" class="headerlink" title="4 切片序列化"></a>4 切片序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化 创建一个字符串切片</span><br>fruits := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;<br><span class="hljs-comment">// 将切片转换为JSON字符串</span><br>jsonBytes, err := json.Marshal(fruits)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error marshaling slice to JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 将JSON字节切片转换为字符串并打印</span><br>jsonString := <span class="hljs-type">string</span>(jsonBytes)<br>fmt.Println(jsonString)<br>    <span class="hljs-comment">// 输出 [&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;]</span><br>    <br>    <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-comment">// 定义一个JSON字符串，它表示一个字符串数组</span><br>jsonString := <span class="hljs-string">`[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]`</span><br><span class="hljs-comment">// 创建一个空的字符串切片，用于存放解码后的数据</span><br><span class="hljs-keyword">var</span> fruits []<span class="hljs-type">string</span><br><span class="hljs-comment">// 使用json.Unmarshal将JSON字符串解码到切片中</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(jsonString), &amp;fruits)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error unmarshaling JSON: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 打印解码后的切片</span><br>fmt.Println(fruits)<br>    <span class="hljs-comment">// 输出    [apple banana cherry]</span><br>     <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gvm版本管理</title>
    <link href="/2024/05/27/go/GO%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
    <url>/2024/05/27/go/GO%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="GO解释器多版本安装"><a href="#GO解释器多版本安装" class="headerlink" title="GO解释器多版本安装"></a>GO解释器多版本安装</h1><h2 id="1、安装g版本管理工具"><a href="#1、安装g版本管理工具" class="headerlink" title="1、安装g版本管理工具"></a>1、安装<a href="https://github.com/voidint/g/blob/master/README_CN.md">g版本管理工具</a></h2><h3 id="Linux-macOS（适用于-bash、zsh）"><a href="#Linux-macOS（适用于-bash、zsh）" class="headerlink" title="Linux&#x2F;macOS（适用于 bash、zsh）"></a>Linux&#x2F;macOS（适用于 bash、zsh）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">建议安装前清空`GOROOT`、`GOBIN`等环境变量</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sSL https://raw.githubusercontent.com/voidint/g/master/install.sh | bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;unalias g&quot;</span> &gt;&gt; ~/.bashrc <span class="hljs-comment"># 可选。若其他程序（如&#x27;git&#x27;）使用了&#x27;g&#x27;作为别名。</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.g/env&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="2、使用命令"><a href="#2、使用命令" class="headerlink" title="2、使用命令"></a>2、使用命令</h2><h3 id="查询当前可供安装的stable状态的-go-版本"><a href="#查询当前可供安装的stable状态的-go-版本" class="headerlink" title="查询当前可供安装的stable状态的 go 版本"></a>查询当前可供安装的<code>stable</code>状态的 go 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g ls-remote stable<br></code></pre></td></tr></table></figure><h3 id="安装目标-go-版本1-20-5"><a href="#安装目标-go-版本1-20-5" class="headerlink" title="安装目标 go 版本1.20.5"></a>安装目标 go 版本<code>1.20.5</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g install 1.14.7</span><br>Downloading 100% [===============] (92/92 MB, 12 MB/s)               <br>Computing checksum with SHA256<br>Checksums matched<br>Now using go1.20.5<br></code></pre></td></tr></table></figure><h3 id="查询已安装的-go-版本"><a href="#查询已安装的-go-版本" class="headerlink" title="查询已安装的 go 版本"></a>查询已安装的 <code>go</code> 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g <span class="hljs-built_in">ls</span></span><br>  1.19.10<br>* 1.20.5<br></code></pre></td></tr></table></figure><h3 id="切换到另一个已安装的-go-版本"><a href="#切换到另一个已安装的-go-版本" class="headerlink" title="切换到另一个已安装的 go 版本"></a>切换到另一个已安装的 <code>go</code> 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g use 1.19.10</span><br>go version go1.19.10 darwin/arm64<br></code></pre></td></tr></table></figure><h3 id="卸载一个已安装的-go-版本"><a href="#卸载一个已安装的-go-版本" class="headerlink" title="卸载一个已安装的 go 版本"></a>卸载一个已安装的 go 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g uninstall 1.19.10</span><br>Uninstalled go1.19.10<br></code></pre></td></tr></table></figure><h3 id="清空-go-安装包文件缓存"><a href="#清空-go-安装包文件缓存" class="headerlink" title="清空 go 安装包文件缓存"></a>清空 go 安装包文件缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g clean</span> <br>Remove go1.18.10.darwin-arm64.tar.gz<br>Remove go1.19.10.darwin-arm64.tar.gz<br>Remove go1.20.5.darwin-arm64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="查看-g-版本信息"><a href="#查看-g-版本信息" class="headerlink" title="查看 g 版本信息"></a>查看 g 版本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">g version 1.5.0<br>build: 2023-01-01T21:01:52+08:00<br>branch: master<br>commit: cec84a3f4f927adb05018731a6f60063fd2fa216<br></code></pre></td></tr></table></figure><h3 id="更新-g-软件本身"><a href="#更新-g-软件本身" class="headerlink" title="更新 g 软件本身"></a>更新 g 软件本身</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g self update</span><br>You are up to date! g v1.5.0 is the latest version.<br></code></pre></td></tr></table></figure><h3 id="卸载-g-软件本身"><a href="#卸载-g-软件本身" class="headerlink" title="卸载 g 软件本身"></a>卸载 g 软件本身</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g self uninstall</span><br>Are you sure you want to uninstall g? (Y/n)<br>y<br>Remove /Users/voidint/.g/bin/g<br>Remove /Users/voidint/.g<br></code></pre></td></tr></table></figure><h2 id="3、GoLand配置-go解释器"><a href="#3、GoLand配置-go解释器" class="headerlink" title="3、GoLand配置 go解释器"></a>3、GoLand配置 go解释器</h2><h3 id="使用命令查看解释器路径"><a href="#使用命令查看解释器路径" class="headerlink" title="使用命令查看解释器路径"></a>使用命令查看解释器路径</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mhd@mhd-VirtualBox:~/.g$ which go<br><br><span class="hljs-regexp">/home/m</span>hd<span class="hljs-regexp">/.g/g</span>o<span class="hljs-regexp">/bin/g</span>o<span class="hljs-comment">#路径地址</span><br><br></code></pre></td></tr></table></figure><h3 id="GOland-中配置解释器地址"><a href="#GOland-中配置解释器地址" class="headerlink" title="GOland 中配置解释器地址"></a>GOland 中配置解释器地址</h3><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310241722115.png" alt="image-20231024172234898"></p><h3 id="设置代理及开启modle模式"><a href="#设置代理及开启modle模式" class="headerlink" title="设置代理及开启modle模式"></a>设置代理及开启modle模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs she">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.io,direct<br><br>goproxy<br>https://goproxy.io/zh/<br>阿里云<br>https://mirrors.aliyun.com/goproxy/<br>七牛云<br>https://goproxy.cn<br></code></pre></td></tr></table></figure><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>以 go 的 web 框架 gin 为例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> go get <span class="hljs-literal">-u</span> github.com/<span class="hljs-built_in">gin</span><span class="hljs-literal">-gonic</span>/<span class="hljs-built_in">gin</span><br></code></pre></td></tr></table></figure><h3 id="激活码"><a href="#激活码" class="headerlink" title="激活码"></a><strong>激活码</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">X96MBT55FM-eyJsaWNlbnNlSWQiOiJYOTZNQlQ1NUZNIiwibGljZW5zZWVOYW1lIjoiQWRtaW4iLCJhc3NpZ25lZU5hbWUiOiJndXJnbGVzIHR1bWJsZXMiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6ZmFsc2UsInByb3BlcnRpZXMiOnt9fSx7ImNvZGUiOiJBQyIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6ZmFsc2UsInByb3BlcnRpZXMiOnt9fSx7ImNvZGUiOiJEUE4iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiUFMiLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiR08iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiQ0wiLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiRE0iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiUlMwIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJEIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJNIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkFJTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkFJUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBDV01QIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjp0cnVlLCJwcm9wZXJ0aWVzIjp7fX1dLCJtZXRhZGF0YSI6IjAxMjAyMzA1MTFQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOjIwMTYuMSIsImdyYWNlUGVyaW9kRGF5cyI6MywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-H9cXz3HGk4xN+0HYnyyYfhzVvXIIxr5xy1B5v/dxKU9rGr/nxnKBSlw6fVNvlNVS4tHDEYA3WEFap2xRO01Geoa9Sg1QPMQKDtfjCEKIDAKvbZLqp/coHX0pAS13tW1ILvyjGDaPhSo2UiXLHWMymW1m0iGJFHphbW2wWFlF5qqVnL15/iV5FNt9xFOwU6R1s2BTBpnHj/UUxrrv4x4m7jv9y3FvN4/Gn9U6SmUmvrla7K2Rn/yvn7DoAnV7z1A65x3BkMfaQVzsmJcjz7APnb/bnuKQckCGBovsy7FeqQqARg/WQRovQdkw2xeV/2txX6NxdEX8K0smrbqSIV2v7A==-MIIETzCCAjegAwIBAgIEU7kY4TANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCojNikMNM0jfXiA2dNmAi0vGQovFKiSkpw1vlr8LmIdkgGoUhlLQi45oHJgvLQOqqXEW7SmbZIRf7eKW0txBkhryKIWDh3VbcpvySP8fJ27gRfx4+1f3zBxWLvMnlyTMlsmXkm8uSKg0aHRBlqzAtLdpWGAFf11V3CfAA/UNPKDvVGfLC2nAwzVYz3DBpHHp4fq3eRglSJ77nKj8pAuLi/Kj6eq3EAXcxFR/2LXY6FydezbCMTaAQWRAuYLcrOpXiQYXGaohmmjXluxmDo3vB/H13mPohCpC9eFWXD4LWRnyr3AaxLDUTmYkVEYzN7r7bneh6pJXrdxL8T+fQ/uYzPAgMBAAGjgZkwgZYwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TAJBgNVHRMEAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAsGA1UdDwQEAwIFoDAdBgNVHQ4EFgQUrr79B9v2lrPP+wiumX6HlmSazsYwDQYJKoZIhvcNAQELBQADggIBACThwgi/0iU8tdgJ4BvSK236PuI0VmyK+uuluf0w3Ywr7VGs8oVj++EqRYQlMQMbtleRmrWQjg/86E1gO0MSVqua9rMti7AJEkq8nnslgvxqqr3mu9afre+hNDWJZTaOd5UaUtyCR61hPnonMyeZG7jmbgKsf2LML/9Bcbfjvpf7NqkWwssafzmyiq9PSJ/VFdWilahOFcaS2r88hL83b8/9W89sCCHxAq7O+FIygm0qhxw+WdGlvJDlF/YW73fb+aC2wNxzGt6X1aQoU/D/RfxoqpMVUrk+KoR0CSzhGp2NuLC2BeBa4XfsBpkyiQykLr2iWrgz7YjKCCf3kRoR1UPWOTC9sW4peivHBzOjDzRxEuxqU/Ue4DcQXkXWsgMbhRJPwSxEIsLhU7AfV78mGPaVmrTP/T9gDjvK0kIjJnvklElVL0yj7IW6dRJY3S+sjRwE9s1EBNXqoJvyA8FL6uUmNoBP3U6usxuGPLwpWh/jVQSM4KTccYBJmS+VBYmOoPSgBPGAMgPhkv9IBpGNVdhKx+QsituMvoXnR9OMOH8wKQWxWcqFlg88jZPkoxBu3X4mDx189BOr64Vc+CfKSVIhckAItafNR70Two8lEn61aNNTk2zZ/bvsYsEivOSEeHAxOj8g4YbLt3ptkI/BbiOChGFZlTN3h/l41M6zt04M<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译</title>
    <link href="/2024/05/27/go/Golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <url>/2024/05/27/go/Golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang交叉编译"><a href="#Golang交叉编译" class="headerlink" title="Golang交叉编译"></a>Golang交叉编译</h1><p><strong>知识点</strong></p><ul><li>跨平台编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example .</span><br></code></pre></td></tr></table></figure><h2 id="一、CGO-ENABLED"><a href="#一、CGO-ENABLED" class="headerlink" title="一、CGO_ENABLED"></a>一、CGO_ENABLED</h2><p><strong>作用</strong></p><p>用于标识（声明） cgo工具是否可用</p><p><strong>意义</strong></p><p>存在交叉编译的情况下，cgo工具是不可用的。在标准go命令的上下文环境中，交叉编译意味着程序构建环境中的目标计算架构的标识与程序运行环境的目标设计架构的标识不同，或者程序构建环境的目标操作系统的标识与程序运行环境的目标操作系统的标识不同</p><p><strong>小结</strong></p><p>我们在宿主机编译的可执行文件，而在 <code>Scratch</code> 镜像运行的可执行文件；显然两者的计算机架构、运行环境标识你无法确定它是否一致（毕竟构建的 <code>docker</code> 镜像还可以给他人使用），那么我们就要进行交叉编译，而交叉编译不支持 <code>cgo</code>，因此这里要禁用掉它</p><p>关闭 <code>cgo</code> 后，在构建过程中会忽略 <code>cgo</code> 并静态链接所有的依赖库，而开启 <code>cgo</code> 后，方式将转为动态链接</p><p><strong>补充</strong></p><p><code>golang</code> 是默认开启 <code>cgo</code> 工具的，可执行 <code>go env</code> 命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">super@super:~/GO_Work/gin_study/go-gin-example$ go env | grep CGO<br>GCCGO=&quot;gccgo&quot;<br>CGO_ENABLED=&quot;1&quot;<br>CGO_CFLAGS=&quot;-O2 -g&quot;<br>CGO_CPPFLAGS=&quot;&quot;<br>CGO_CXXFLAGS=&quot;-O2 -g&quot;<br>CGO_FFLAGS=&quot;-O2 -g&quot;<br>CGO_LDFLAGS=&quot;-O2 -g&quot;<br></code></pre></td></tr></table></figure><h2 id="二、GOOS"><a href="#二、GOOS" class="headerlink" title="二、GOOS"></a>二、GOOS</h2><p>用于标识（声明）程序构建环境中的目标操作系统</p><p>如：</p><ul><li>linux</li><li>window</li></ul><h2 id="三、GOARCH"><a href="#三、GOARCH" class="headerlink" title="三、GOARCH"></a>三、GOARCH</h2><p>用于标识(声明)程序构建环境的目标计算架构</p><p>若不设置，默认值与程序运行环境的目标计算架构一致</p><p>如：</p><ul><li>amd64</li><li>386</li></ul><table><thead><tr><th>系统</th><th>GOOS</th><th>GOARCH</th></tr></thead><tbody><tr><td>Windows 32 位</td><td>windows</td><td>386</td></tr><tr><td>Windows 64 位</td><td>windows</td><td>amd64</td></tr><tr><td>OS X 32 位</td><td>darwin</td><td>386</td></tr><tr><td>OS X 64 位</td><td>darwin</td><td>amd64</td></tr><tr><td>Linux 32 位</td><td>linux</td><td>386</td></tr><tr><td>Linux 64 位</td><td>linux</td><td>amd64</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GOOS=linux GOARCH=amd64 go build -o yourprogram<span class="hljs-comment"># 为linux系统编译二进制文件</span><br>GOOS=windows GOARCH=amd64 go build -o yourprogram.exe<span class="hljs-comment"># 为window编译可执行文件</span><br></code></pre></td></tr></table></figure><h2 id="四、GOHOSTOS"><a href="#四、GOHOSTOS" class="headerlink" title="四、GOHOSTOS"></a>四、GOHOSTOS</h2><p>用于标识（声明）程序运行环境的目标操作系统</p><h2 id="五、GOHOSTARCH"><a href="#五、GOHOSTARCH" class="headerlink" title="五、GOHOSTARCH"></a>五、GOHOSTARCH</h2><p>用于标识（声明）程序运行环境的目标计算架构</p><h2 id="六、go-build"><a href="#六、go-build" class="headerlink" title="六、go build"></a>六、go build</h2><p><strong>-a</strong></p><p>强制重新编译，简单来说，就是不利用缓存或已编译好的部分文件，直接所有包都是最新的代码重新编译和关联</p><h4 id="installsuffix"><a href="#installsuffix" class="headerlink" title="-installsuffix"></a><strong>-installsuffix</strong></h4><p>作用：</p><p>在软件包安装的目录中增加后缀标识，以保持输出与默认版本分开</p><p><strong>补充：</strong></p><p>如果使用 -race 标识，则后缀就会默认设置为  -race标识，用于区分race和普通的版本</p><p><strong>-o</strong></p><p>指定编译后的可执行文件名称</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证机制</title>
    <link href="/2024/05/27/go/Session%E3%80%81Cookie%E3%80%81Token%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/05/27/go/Session%E3%80%81Cookie%E3%80%81Token%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Session、Cookie、Token"><a href="#Session、Cookie、Token" class="headerlink" title="Session、Cookie、Token"></a>Session、Cookie、Token</h1><p><strong>Cookie 和 Session</strong></p><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300936290.png" alt="image-20240130093625230"></p><p><strong>Session 是什么</strong></p><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为 <code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p><p><strong>Session 如何判断是否是同一会话</strong></p><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID&#x3D;XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID&#x3D;XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300938228.png" alt="image-20240130093802188"></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p><p><strong>Session 的缺点</strong></p><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><p><strong>Cookies 是什么</strong></p><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p><ul><li>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</li></ul><p>Cookie 主要用于下面三个目的</p><ul><li><code>会话管理</code></li></ul><p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p><ul><li><code>个性化</code></li></ul><p>用户偏好、主题或者其他设置</p><ul><li><code>追踪</code></li></ul><p>记录和分析用户行为</p><p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。</p><p><strong>创建 Cookie</strong></p><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p><p><strong>Set-Cookie 和 Cookie 标头</strong></p><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300939222.png" alt="image-20240130093928179"></p><p>此标头告诉客户端存储 Cookie</p><p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300939966.png" alt="image-20240130093948900"></p><p>有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p><p>还有一种是 <code>Cookie的 Secure 和 HttpOnly 标记</code></p><p><strong>会话 Cookies</strong></p><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定<code>Expires</code>或 <code>Max-Age</code> 指令。</p><p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p><p><strong>永久性 Cookies</strong></p><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: id=a3fWa; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">21</span> <span class="hljs-title class_">Oct</span> <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span>;<br></code></pre></td></tr></table></figure><p><strong>Cookie 的 Secure 和 HttpOnly 标记</strong></p><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p><p><strong>HttpOnly 的作用</strong></p><ul><li>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。 </li><li>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。 </li><li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms <a href="https://cloud.tencent.com/product/mfas?from_column=20065&from=20065">身份验证</a>票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li></ul><h4 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a>Cookie 的作用域</h4><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p><p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(不包含子域名）。如果指定了<code>Domain</code>，则一般包含子域名。</p><p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p><p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p><ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul><p><strong>JWT 和 Session Cookies 的相同之处</strong></p><p>在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。</p><p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p><p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300942289.png" alt="image-20240130094231244"></p><p>因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。</p><p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制。</strong></p><p>也就是说，这两种技术都是用来保存你的登录状态，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p><p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p><h4 id="什么是-Session-Cookies"><a href="#什么是-Session-Cookies" class="headerlink" title="什么是 Session Cookies"></a>什么是 Session Cookies</h4><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p><p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300944091.png" alt="image-20240130094404035"></p><p><strong>token</strong> 令牌，是用户身份的验证方式。 最简单的token组成:uid(用户唯一的<a href="https://cloud.tencent.com/solution/tb-digitalid?from_column=20065&from=20065">身份标识</a>)、time（当前时间的时间戳）、sign（签名）。 <strong>对Token认证的五点认识</strong></p><ul><li>一个Token就是一些信息的集合；</li><li>在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</li><li>服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；</li><li>基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；</li><li>因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；</li></ul><p><strong>session</strong></p><ul><li>会话，代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续。</li><li>cookie中存放着一个sessionID，请求时会发送这个ID；</li><li>session因为请求（request对象）而产生；</li><li>session是一个容器，可以存放会话过程中的任何对象；</li><li>session的创建与使用总是在服务端，浏览器从来都没有得到过session对象；</li><li>session是一种http存储机制，目的是为武装的http提供持久机制。</li></ul><p><strong>cookie</strong></p><p>储存在用户本地终端上的数据，服务器生成，发送给浏览器，下次请求统一网站给服务器。</p><p><strong>cookie与session区别</strong> cookie数据存放在客户端上，session数据放在服务器上； cookie不是很安全，且保存数据有限； session一定时间内保存在服务器上,当访问增多，占用服务器性能。</p><p><strong>session与token</strong> 作为身份认证，token安全行比session好； Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。</p><p><strong>token与cookie</strong> Cookie是不允许垮域访问的，但是token是支持的， 前提是传输的用户认证信息通过HTTP头传输；</p><p>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><p>HTTP协议与状态保持：Http是一个无状态协议 </p><ul><li><ol><li>实现状态保持的方案：</li></ol><ul><li>1)修改Http协议，使得它支持状态保持(难做到)</li><li>2)Cookies：通过客户端来保持状态信息</li><li>Cookie是服务器发给客户端的特殊信息</li><li>cookie是以文本的方式保存在客户端，每次请求时都带上它</li><li>3)Session：通过服务器端来保持状态信息</li><li>Session是服务器和客户端之间的一系列的交互动作</li><li>服务器为每个客户端开辟内存空间，从而保持状态信息</li><li>由于需要客户端也要持有一个标识(id)，因此，也要求服务器端和客户端传输该标识，</li><li>标识(id)可以借助Cookie机制或者其他的途径来保存</li></ul><p>2、COOKIE机制 </p><ul><li>Cookie的基本特点</li><li>Cookie保存在客户端</li><li>只能保存字符串对象，不能保存对象类型</li><li>需要客户端浏览器的支持：客户端可以不支持，浏览器用户可能会禁用Cookie</li></ul><h4 id="JWT-和-Session-Cookies-的不同"><a href="#JWT-和-Session-Cookies-的不同" class="headerlink" title="JWT 和 Session Cookies 的不同"></a>JWT 和 Session Cookies 的不同</h4><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p><p><strong>密码签名</strong></p><p>JWT 具有加密签名，而 Session Cookies 则没有。</p><p><strong>JSON 是无状态的</strong></p><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p><p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p><p><strong>可扩展性</strong></p><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p><p><strong>JWT 支持跨域认证</strong></p><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p><p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p><h4 id="JWT-和-Session-Cookies-的选型"><a href="#JWT-和-Session-Cookies-的选型" class="headerlink" title="JWT 和 Session Cookies 的选型"></a>JWT 和 Session Cookies 的选型</h4><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说 </p><p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p><p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2024/05/27/go/%E4%BE%9D%E8%B5%96%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/27/go/%E4%BE%9D%E8%B5%96%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h1><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h2 id="安装-swag"><a href="#安装-swag" class="headerlink" title="安装 swag"></a>安装 swag</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get -u github.com<span class="hljs-regexp">/swaggo/</span>swag<span class="hljs-regexp">/cmd/</span>swag@v1.<span class="hljs-number">6.5</span><br></code></pre></td></tr></table></figure><p><code>swag -v</code> 时提示找不到该命令</p><p>可能是因为 <code>$PATH</code> 环境变量没有包含 Go 安装二进制文件的目录。</p><p>在大多数系统中，Go 会将编译好的可执行文件放在 <code>$GOPATH/bin</code> 或使用 Go modules 后的 <code>$(go env GOPATH)/bin</code> 或 <code>$(go env GOBIN)</code> 目录下。你可以通过运行以下命令找到 <code>swag</code> 的安装位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $(go <span class="hljs-built_in">env</span> GOPATH)/bin<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">echo <span class="hljs-constructor">$(<span class="hljs-params">go</span> <span class="hljs-params">env</span> GOBIN)</span><br></code></pre></td></tr></table></figure><p>找到目录后，确保该路径已经添加到了你的系统 <code>$PATH</code> 环境变量中。如果还没有添加，可以将以下行添加到你的 shell 配置文件中（如 <code>.bashrc</code>、<code>.bash_profile</code> 或 <code>.zshrc</code>），然后重新加载配置文件（通过运行 <code>. ~/.bashrc</code>、<code>source ~/.bash_profile</code> 或 <code>source ~/.zshrc</code>）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$(go env GOPATH)/bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo blog</title>
    <link href="/2024/05/27/tools/Hexo%E7%BB%93%E5%90%88Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/tools/Hexo%E7%BB%93%E5%90%88Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo结合Github搭建博客"><a href="#Hexo结合Github搭建博客" class="headerlink" title="Hexo结合Github搭建博客"></a>Hexo结合Github搭建博客</h1><h2 id="1、配置hexo、github环境"><a href="#1、配置hexo、github环境" class="headerlink" title="1、配置hexo、github环境"></a>1、配置hexo、github环境</h2><p><a href="https://zhuanlan.zhihu.com/p/60578464">参考地址</a></p><h2 id="2、hexo常用命令"><a href="#2、hexo常用命令" class="headerlink" title="2、hexo常用命令"></a>2、hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;name&quot;</span>     <span class="hljs-comment"># 新建文章</span><br>hexo new page <span class="hljs-string">&quot;name&quot;</span>  <span class="hljs-comment"># 新建页面</span><br>hexo g                <span class="hljs-comment"># 生成页面</span><br>hexo d                <span class="hljs-comment"># 部署</span><br>hexo g &amp;&amp; hexo d            <span class="hljs-comment"># 生成页面并部署</span><br>hexo s                <span class="hljs-comment"># 本地预览</span><br>hexo clean            <span class="hljs-comment"># 清除缓存和已生成的静态文件</span><br>hexo <span class="hljs-built_in">help</span>             <span class="hljs-comment"># 帮助</span><br></code></pre></td></tr></table></figure><h2 id="3、文章配置"><a href="#3、文章配置" class="headerlink" title="3、文章配置"></a>3、文章配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">参数配置</span><br><span class="hljs-string">文章最开始Front-Matter</span> <span class="hljs-string">使用---</span> <span class="hljs-string">回车配置</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">java三大特性</span> <span class="hljs-comment"># 配置显示文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Java</span>]    <span class="hljs-comment"># 配置标签</span><br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java笔记</span>]  <span class="hljs-comment"># 配置分类</span><br><span class="hljs-attr">published:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 配置是否所有可读</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">hello</span><span class="hljs-comment"># 文章摘要。如果提供，这个字段的文本将作为文章列表页面上的简介</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KafKa 介绍</title>
    <link href="/2024/05/27/tools/Kafka%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2024/05/27/tools/Kafka%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p><strong>你是一个程序员，假设你维护了两个服务 A 和 B。B 服务每秒只能处理 100 个消息，但 A 服务却每秒发出 200 个消息，B 服务哪里顶得住，分分钟被压垮。那么问题就来了，有没有办法让 B 在不被压垮的同时，还能处理掉 A 的消息？当然有，没有什么是加一层中间层不能解决的，如果有，那就再加一层。这次我们要加的中间层是 消息队列 Kafka。</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514092819890.png?raw=true" alt="image-20240514092819890"></p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>为了保护 B 服务，我们很容易想到可以在 B 服务的内存中加入一个<strong>队列</strong>。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514092948006.png?raw=true" alt="image-20240514092948006"></p><p>说白了，它其实是个链表，链表的每个节点就是一个消息。每个节点有一个序号，我们叫它 <code>Offset(相当一个书签)</code>，记录消息的位置。B 服务依据自己的处理能力，消费链表里的消息。能处理多少是多少，不断更新已处理 Offset 的值。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514093303221.png?raw=true" alt="image-20240514093303221"></p><p>但这有个问题，来不及处理的消息会堆积在内存里，如果 B 服务更新<strong>重启</strong>，这些消息就都丢了。这个好解决，将队列挪出来，变成一个<strong>单独的进程</strong>。就算 B 服务重启，也不会影响到了队列里的消息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514093434298.png?raw=true" alt="image-20240514093434298"></p><p>这样一个简陋的队列进程，其实就是所谓的<strong>消息队列</strong>。而像 A 服务这样负责发数据到消息队列的角色，就是<strong>生产者</strong>，像 B 服务这样处理消息的角色，就是<strong>消费者</strong>。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514094020978.png?raw=true" alt="image-20240514094020978"></p><p>但这个消息队列属实过于简陋，像什么高性能，高扩展性，高可用，它是一个都不沾。我们来看下怎么优化它。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>B 服务由于性能较差，消息队列里会不断堆积数据，为了提升性能，我们可以扩展更多的消费者, 这样消费速度就上去了，相对的我们就可以增加更多生产者，提升消息队列的吞吐量。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514094125035.png?raw=true" alt="image-20240514094125035"></p><p>随着生产者和消费者都变多，我们会发现它们会同时争抢同一个消息队列，抢不到的一方就得等待，这不纯纯浪费时间吗！有解决方案吗？有！首先是对消息进行分类，每一类是一个 <strong>topic</strong>，然后根据 topic 新增队列的数量，生产者将数据按 topic 投递到不同的队列中，消费者则根据需要订阅不同的 topic。这就大大降低了 topic 队列的压力。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514100259038.png?raw=true" alt="image-20240514100259038"></p><p>但单个 topic 的消息还是可能过多，我们可以将单个队列，拆成好几段，每段就是一个 <strong>partition分区</strong>，每个消费者负责一个 partition。这就大大降低了争抢，提升了消息队列的性能。</p><ul><li>Partition是Topic内部的物理分片，每个Topic可以被分为一个或多个Partition。这样做不仅允许数据并行处理，还为数据的规模扩展提供了基础。</li><li>每个Partition都是一个有序的、不可变的消息队列，消息在Partition内部是严格有序的，但不同Partition间的消息顺序不保证。</li><li>Partition的数量可以在创建Topic时指定，也可以后续调整（尽管这通常需要重新分配数据，可能影响到实时消息处理）。</li><li>Partition的数据分布在不同的Broker上，以实现负载均衡和故障隔离。每个Partition都有一个Leader和零个或多个Follower，Leader负责读写操作，Follower负责数据复制以确保数据安全。</li></ul><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104614344.png?raw=true" alt="image-20240514104614344"></p><blockquote><p>Broker 是Kafka集群中的一个节点，负责消息的接收、存储、分发以及相关的管理工作。</p></blockquote><h2 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h2><p>随着 partition 变多，如果 partition 都在同一台机器上的话，就会导致单机 cpu 和内存过高，影响整体系统性能。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104741761.png?raw=true" alt="image-20240514104741761"></p><p>于是我们可以申请更多的机器，将 partition 分散部署在多台机器上，这每一台机器，就代表一个 <strong>broker</strong>。我们可以通过增加 broker 缓解机器 cpu 过高带来的性能问题。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104846414.png?raw=true" alt="image-20240514104846414"></p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>到这里，其实还有个问题，如果其中一个 partition 所在的 broker 挂了，那 broker 里所有 partition 的消息就都没了。这高可用还从何谈起？有解决方案吗？有，连你喜欢的女生都知道手机里多聊几个沸羊羊，你却不知道要给 partition 加备胎吗？我们可以给 partition 多加几个副本，也就是 replicas，将它们分为 Leader 和 Follower。Leader 负责应付生产者和消费者的读写请求，而 Follower 只管同步 Leader 的消息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105013986.png?raw=true" alt="image-20240514105013986"></p><p>将 Leader 和 Follower 分散到不同的 broker 上，这样 Leader 所在的 broker 挂了，也不会影响到 Follower 所在的 broker, 并且还能从 Follower 中选举出一个新的 Leader partition 顶上。这样就保证了消息队列的高可用。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105052593.png?raw=true" alt="image-20240514105052593"></p><h2 id="持久化和过期策略"><a href="#持久化和过期策略" class="headerlink" title="持久化和过期策略"></a>持久化和过期策略</h2><p>刚刚提到的是几个 broker 挂掉的情况，那搞大点，假设所有 broker 都挂了，那岂不是数据全丢了？为了解决这个问题，我们不能光把数据放内存里，还要持久化到磁盘中，这样哪怕全部 broker 都挂了，数据也不会全丢，重启服务后，也能从磁盘里读出数据，继续工作。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105125764.png?raw=true" alt="image-20240514105125764"></p><p>但问题又来了，磁盘总是有限的，这一直往里写数据迟早有一天得炸。所以我们还可以给数据加上保留策略，也就是所谓的 <code>retention policy</code>，比如磁盘数据超过一定大小或消息放置超过一定时间就会被清理掉。</p><h2 id="consumer-group"><a href="#consumer-group" class="headerlink" title="consumer group"></a>consumer group</h2><p>到这里，这个消息队列好像就挺完美了。但其实还有个问题，按现在的消费方式，每次新增的消费者只能跟着<strong>最新的</strong>消费 Offset 接着消费。如果我想让新增的消费者从某个 Offset 开始消费呢？听起来这个需求很刁钻？我举个例子你就明白了。</p><p>哪怕 B 服务有多个实例，但本质上，它只有一个消费业务方，新增实例一般也是接着之前的 offset 继续消费。假设现在来了个新的业务方，C 服务，它想从头开始消费消息队列里的数据，这时候就不能跟在 B 服务的 offset 后边继续消费了。</p><p>所以我们还可以给消息队列加入消费者组（consumer group）的概念，B 和 C 服务各自是一个独立的消费者组，不同消费者组维护自己的消费进度，互不打搅。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110710406.png?raw=true" alt="image-20240514110710406"></p><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>相信你也发现了，组件太多了，而且每个组件都有自己的数据和状态，所以还需要有个组件去统一维护这些组件的状态信息，于是我们引入 <strong>ZooKeeper</strong> 组件。它会定期和 broker 通信，获取 整个 kafka 集群的状态，以此判断 某些 broker 是不是跪了，某些消费组消费到哪了。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110818882.png?raw=true" alt="image-20240514110818882"></p><h2 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h2><p>好了，到这里，当初那个简陋的消息队列，就成了一个高性能，高扩展性，高可用，支持持久化的超强消息队列，没错，它就是我们常说的消息队列 <strong>Kafka</strong>，上面涉及到各种概念，比如 partition 和 broker 什么的，都出自它。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110952706.png?raw=true" alt="image-20240514110952706"></p><h2 id="kafka-的应用场景"><a href="#kafka-的应用场景" class="headerlink" title="kafka 的应用场景"></a>kafka 的应用场景</h2><p>消息队列是架构中最常见的中间件之一，使用场景之多，堪称万金油！比如上游流量忽高忽低，想要<strong>削峰填谷</strong>，提升 cpu&#x2F;gpu 利用率，用它。又比如系统过大，消息流向盘根错节，想要拆解组件，<strong>降低系统耦合</strong>，还是用它。再比如秒杀活动，请求激增，想要<strong>保护服务</strong>的同时又尽量不影响用户，还得用它。当然，凡事无绝对，方案还得根据实际情况来定，做架构做到最后，都是在做<strong>折中</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>• kafka 是消息队列，像消息队列投递消息的是生产者，消费消息的是消费者。增加生产者和消费者的实例个数可以提升系统吞吐。多个消费者可以组成一个消费者组，不同消费者组维护自己的消费进度，互不打搅。</li><li>• kafka 将消息分为多个 topic，每个 topic 内部拆分为多个 partition，每个 partition 又有自己的副本，不同的 partition 会分布在不同的 broker 上，提升性能的同时，还增加了系统可用性和可扩展性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KafKa 实战1</title>
    <link href="/2024/05/27/tools/Kafka%E5%AE%9E%E6%88%981/"/>
    <url>/2024/05/27/tools/Kafka%E5%AE%9E%E6%88%981/</url>
    
    <content type="html"><![CDATA[<h2 id="1-部署kafka"><a href="#1-部署kafka" class="headerlink" title="1 部署kafka"></a>1 部署kafka</h2><ul><li>docker</li><li>docker-compose</li></ul><h3 id="docker-部署"><a href="#docker-部署" class="headerlink" title="docker  部署"></a>docker  部署</h3><p>docker部署kafka非常简单，只需要两条命令即可完成kafka服务器的部署。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name zookeeper \<br>  -v zookeeper-data:/bitnami \<br>  -e ALLOW_ANONYMOUS_LOGIN=yes \<br>  bitnami/zookeeper<br>  <br>docker run -d --name broker \<br>  -p 9092:9092 \<br>  -v kafka-data:/bitnami \<br>  -e KAFKA_ENABLE_KRAFT=no \<br>  -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 \<br>  -e KAFKA_LISTENERS=PLAINTEXT://:9092 \<br>  -e KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181 \<br>  -e ALLOW_PLAINTEXT_LISTENER=yes \<br>  --link zookeeper:zookeeper \<br>  bitnami/kafka<br></code></pre></td></tr></table></figure><h3 id="docker-compose部署"><a href="#docker-compose部署" class="headerlink" title="docker-compose部署"></a>docker-compose部署</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zookeeper:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/zookeeper</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;zookeeper:/bitnami&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ALLOW_ANONYMOUS_LOGIN:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/kafka</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">broker</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">broker</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;kafka:/bitnami&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ENABLE_KRAFT:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://kafka:9092</span><br>      <span class="hljs-attr">KAFKA_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://:9092</span><br>      <span class="hljs-attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">zookeeper:2181</span><br>      <span class="hljs-attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="hljs-literal">yes</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">kafka:</span><br>  <span class="hljs-attr">zookeeper:</span><br></code></pre></td></tr></table></figure><p><strong><code>kafka-map</code>可视化工具</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">kafka-map:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">dushixiang/kafka-map:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka-map</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;38080:8080&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/kafka-map/data:/usr/local/kafka-map/data</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DEFAULT_USERNAME=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DEFAULT_PASSWORD=admin</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>部署起来很简单,在docker-compose.yml文件的目录下执行docker-compose up -d就可以了。<br>这个docker-compose做的东西比上面docker方式部署的东西要多一些</p><ol><li><p>数据持久化，在当前目录下挂在了两个目录分别存储zookeeper和kafka的数据,当然在docker run 命令中添加 -v 选项也是可以做到这样的效果的</p><p>2.kafka在启动后会初始化一个有分区的topic,同样的,docker run的时候添加 -e KAFKA<em>CREATE</em>TOPICS&#x3D;kafeidou:2:0 也是可以做到的。</p></li></ol><blockquote><p>总结:优先推荐docker-compose方式部署,便于自定义调整</p></blockquote><h3 id="通过kafka自带工具生产消费消息测试"><a href="#通过kafka自带工具生产消费消息测试" class="headerlink" title="通过kafka自带工具生产消费消息测试"></a>通过kafka自带工具生产消费消息测试</h3><p>首先,进入到kafka的docker容器中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose <span class="hljs-built_in">exec</span> -it kafka bash<br></code></pre></td></tr></table></figure><p>运行消费者,进行消息的监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kafka-console-consumer.sh --bootstrap-server 192.168.0.185:9092 --topic test1 --from-beginning   <span class="hljs-comment"># ip为机器i片拼接暴露端口</span><br></code></pre></td></tr></table></figure><p>打开一个新的ssh窗口,同样进入kafka的容器中,执行下面这条命令生产消息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kafka-console-producer.sh --broker-list 192.168.0.185:9092 --topic test1<span class="hljs-comment"># ip为机器i片拼接暴露端口</span><br></code></pre></td></tr></table></figure><p>输入完这条命令后会进入到控制台，可以输入任何想发送的消息,这里发送一个hello</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span><br>&gt;hello<br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到,在生产者的控制台中输入消息后,消费者的控制台立刻看到了消息</p><p>到目前为止,一个kafka完整的hello world就完成了.kafka的部署加上生产者消费者测试.</p><p>工具命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、使用以下命令查看当前 Kafka 主题：<br>kafka-topics.sh --list --bootstrap-server localhost:9092<br>2、刪除主題<br>kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic your_topic_name<br>3、创建主题<br>kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic my-topic<br><br>    --create：创建一个新主题。<br>    --bootstrap-server：指定要用于连接到 Kafka 集群的引导服务器地址。这应该是 Kafka 消息代理的主机名和端口号，例如 localhost:9092。<br>    --replication-factor：指定要为每个分区保留多少个副本。在生产环境中，通常将副本因子设置为 2 或更高，以确保数据冗余性和高可用性。单一副本的主题只有在测试或开发环境中才有意义。<br>    --partitions：指定要为主题创建的分区数。如果没有特殊需求，请在生产中创建多个分区以支持更好的伸缩性和吞吐量。<br>    --topic：指定要创建的主题名称。<br>4、查看主题数据<br>kafka-console-consumer.sh \<br>  --bootstrap-server localhost:9092 \<br>  --topic sarama \<br>  [--from-beginning] \#参数是可选的，如果加上这个参数，消费者会从主题的起始处开始读取消息；默认从最新的消息开始消费。<br>  [--property print.key=true] \#参数用于指定消息的反序列化方式，通常字符串是最常用的，但也可以根据实际情况调整为其他序列化类<br>  [--property print.value=true] \<br>  [--property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer] \<br>  [--property value.deserializer=org.apache.kafka.common.serialization.StringDeserializer]<br><br></code></pre></td></tr></table></figure><h2 id="2-kafka-client"><a href="#2-kafka-client" class="headerlink" title="2 kafka client"></a>2 kafka client</h2><blockquote><p>关于 go 的 kafka client 有很多开源项目，例如</p><ol><li><a href="https://github.com/Shopify/sarama">sarama</a>: 具有完整协议支持的纯 Go 实现。包括消费者和生产者实施，支持 GZIP 和 Snappy 压缩。</li><li><a href="https://github.com/confluentinc/confluent-kafka-go">confluent-kafka-go</a>: Confluent 的 Golang Kafka 客户端包装了 librdkafka C 库，提供完整的 Kafka 协议支持，具有出色的性能和可靠性。提供了高级生产者和消费者，支持 Apache Kafka 0.9 及更高版本的平衡消费者组。</li><li><a href="https://github.com/twmb/franz-go">franz-go</a>: 纯 Go 实现提供完整的协议支持、出色的性能以及对所有面向客户端的 KI P 的支持。</li></ol></blockquote><p>本文使用 sarama 作为 kafka client</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/Shopify/sarama<br></code></pre></td></tr></table></figure><p>本地运行需要将hosts kafka主机名重定向到宿主机上,否则写入的时候出现无法写入,可能是Sarama在内部可能因为某些原因（比如自动发现机制或错误的配置传播）尝试连接到 <code>kafka:9092</code>，这个主机名未能正确解析，引发了错误。</p><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>sarama 提供两种 producer 的实现：<code>AsyncProducer</code>和<code>SyncProducer</code>，即同步和异步的生产者，本文只介绍<code>AsyncProducer</code>的使用，通过<code>sarama.NewAsyncProducer</code>获取生产者实例，其中要求传入两个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAsyncProducer</span><span class="hljs-params">(addrs []<span class="hljs-type">string</span>, conf *Config)</span></span> (AsyncProducer, <span class="hljs-type">error</span>) &#123;<br>client, err := NewClient(addrs, conf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> newAsyncProducer(client)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>addrs: 即为 kafka broker 地址，对于 kafka 集群可以全部都填，也可以只填一个，保证有一个地址可用即可</li><li>conf: 为 sarama 封装的生产者、消费者、客户端、网络与一体的配置，通过<code>sarama.NewConfig</code>快速获取默认值的配置文件</li></ul><p>对于生产者我们通常修改的配置就是 ack 了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br></code></pre></td></tr></table></figure><p><code>config.Producer.RequiredAcks</code>的类型本质上是 int16，所以习惯<code>0,1,-1</code>这种配置也可以直接赋值，但为了消除魔数的影响，建议使用 sarama 封装的常数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>NoResponse RequiredAcks = <span class="hljs-number">0</span><br>  <br>WaitForLocal RequiredAcks = <span class="hljs-number">1</span><br>  <br>WaitForAll RequiredAcks = <span class="hljs-number">-1</span><br>)<br>acks=<span class="hljs-number">0</span>:<br>生产者在将消息发送给Kafka broker后，不等待任何确认就继续处理下一条消息。这意味着生产者无法知道消息是否到达broker，提供了最低的延迟但不保证消息的可靠性。<br>acks=<span class="hljs-number">1</span>:<br>生产者在至少一个副本（通常是leader副本）确认接收到消息后，认为消息发送成功。这种方式提供了基本的可靠性保障，因为至少消息被一个副本接收了，但如果这个副本在确认后立即失败且没有同步到其他副本，消息可能会丢失。<br>acks=all 或 acks=<span class="hljs-number">-1</span>:<br>生产者在所有同步副本（in-sync replicas，ISR列表中的副本）都确认接收到消息后，才认为消息发送成功。这是最安全但也最慢的模式，因为它确保即使leader副本失败，消息也不会丢失，因为至少还有一个同步副本拥有这条消息。<br></code></pre></td></tr></table></figure><p>如果需要开启开启异步回调，则需要开启<code>config.Producer.Return.Successes</code>和<code>config.Producer.Return.Errors</code>，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>生产者内部对 Successes 和 Errors 分别维护两个 channel，下面是<code>AsyncProducer</code>需要实现的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AsyncProducer <span class="hljs-keyword">interface</span> &#123;<br><br>AsyncClose()<br><br>Close() <span class="hljs-type">error</span><br><br>Input() <span class="hljs-keyword">chan</span>&lt;- *ProducerMessage<br><br>Successes() &lt;-<span class="hljs-keyword">chan</span> *ProducerMessage<br><br>Errors() &lt;-<span class="hljs-keyword">chan</span> *ProducerError<br><br>IsTransactional() <span class="hljs-type">bool</span><br><br>TxnStatus() ProducerTxnStatusFlag<br><br>BeginTxn() <span class="hljs-type">error</span><br><br>CommitTxn() <span class="hljs-type">error</span><br><br>AbortTxn() <span class="hljs-type">error</span><br><br>AddOffsetsToTxn(offsets <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*PartitionOffsetMetadata, groupId <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br><br>AddMessageToTxn(msg *ConsumerMessage, groupId <span class="hljs-type">string</span>, metadata *<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当生产者发送消息的正常回调信息会投递到<code>Successes</code>的 channel 中，错误回调信息会投递到<code>Errors</code>的 channel 中。需要注意的是如果开启了异步回调则一定要去消费这两个 channel 的数据否则会阻塞 producer，同时下面是<code>AsyncProducer</code>实现者的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">p := &amp;asyncProducer&#123;<br>  client:          client,<br>  conf:            client.Config(),<br>  errors:          <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerError),<br>  input:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  successes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  retries:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  brokers:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Broker]*brokerProducer),<br>  brokerRefs:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*brokerProducer]<span class="hljs-type">int</span>),<br>  txnmgr:          txnmgr,<br>  metricsRegistry: newCleanupRegistry(client.Config().MetricRegistry),<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>Successes</code>和<code>Errors</code>是一个同步队列，因此对这两个 channel 的回调一定不要有过重的逻辑，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搞一个上下文用于退出异步回调</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancelFunc()<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>EXITED:<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> message := &lt;-producer.Successes():<br>      logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br>    <span class="hljs-keyword">case</span> err := &lt;-producer.Errors():<br>      logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>      logger.Println(<span class="hljs-string">&quot;exited:&quot;</span>, ctx.Err())<br>      <span class="hljs-keyword">break</span> EXITED<br>    &#125;<br>  &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><blockquote><p>Tips: 如何想要查看 sarama 内部日志，可以通过下面方式将其输入到控制台，默认是<code>io.Discard</code>相当于&#x2F;dev&#x2F;null</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sarama.Logger = log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br></code></pre></td></tr></table></figure></blockquote><p>而发送消息则是向<code>Input</code>的 channel 发送数据即可，我们只需要构建特定的消息结构体即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ProducerMessage <span class="hljs-keyword">struct</span> &#123;<br>Topic <span class="hljs-type">string</span><br><br>Key Encoder<br><br>Value Encoder<br><br>Headers []RecordHeader<br><br>Metadata <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-comment">// Below this point are filled in by the producer as the message is processed</span><br>Offset <span class="hljs-type">int64</span><br><br>Partition <span class="hljs-type">int32</span><br>  <br>Timestamp time.Time<br><br>retries        <span class="hljs-type">int</span><br>flags          flagSet<br>expectation    <span class="hljs-keyword">chan</span> *ProducerError<br>sequenceNumber <span class="hljs-type">int32</span><br>producerEpoch  <span class="hljs-type">int16</span><br>hasSequence    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用户只需要构建该结构体导出字段中的<code>Topic</code>、<code>Key</code>、<code>Value</code>、<code>Headers</code>以及<code>Metadata</code>，对于<code>Metadata</code>是 sarama 内部维护的一个字段，在发送数据时会被忽略用作在回调时进行填充，也就是说它不是 kafka 所需要的字段只在客户端内部扭转。而<code>Offset</code>、<code>Partition</code>和<code>Timestamp</code>则是在处理消息时 sarama 自动进行填充。</p><p>因此发送消息伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>  producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>    Topic: topic,<br>    Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> maxRecordNum = <span class="hljs-number">1000</span><br><span class="hljs-keyword">var</span> topic = <span class="hljs-string">&quot;sarama&quot;</span><br><br><span class="hljs-comment">// SimpleProducer 简单生产生</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleProducer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br>config.ClientID = <span class="hljs-string">&quot;demo-producer&quot;</span><br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>producer, err := sarama.NewAsyncProducer(brokers, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = producer.Close() &#125;()<br><span class="hljs-comment">// 搞一个上下文用于退出异步回调</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancelFunc()<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>EXITED:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-producer.Successes():<br>logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br><span class="hljs-keyword">case</span> err := &lt;-producer.Errors():<br>logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>logger.Println(<span class="hljs-string">&quot;exited:&quot;</span>, ctx.Err())<br><span class="hljs-keyword">break</span> EXITED<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>Topic: topic,<br>Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>&#125;<br>&#125;<br><span class="hljs-comment">// 等 5 s</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的等待是为了将回调信息全部打印完毕，经过研究发现当调用<code>producer.Close()</code>时会将内部维护的 channel 都关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *asyncProducer)</span></span> shutdown() &#123;<br>Logger.Println(<span class="hljs-string">&quot;Producer shutting down.&quot;</span>)<br>p.inFlight.Add(<span class="hljs-number">1</span>)<br>p.input &lt;- &amp;ProducerMessage&#123;flags: shutdown&#125;<br><br>p.inFlight.Wait()<br><br>err := p.client.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Logger.Println(<span class="hljs-string">&quot;producer/shutdown failed to close the embedded client:&quot;</span>, err)<br>&#125;<br><br><span class="hljs-built_in">close</span>(p.input)<br><span class="hljs-built_in">close</span>(p.retries)<br><span class="hljs-built_in">close</span>(p.errors)<br><span class="hljs-built_in">close</span>(p.successes)<br><br>p.metricsRegistry.UnregisterAll()<br>&#125;<br></code></pre></td></tr></table></figure><p>因此可以使用<code>sync.WaitGroup</code>进行改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> maxRecordNum = <span class="hljs-number">1000</span><br><span class="hljs-keyword">var</span> topic = <span class="hljs-string">&quot;sarama&quot;</span><br><br><span class="hljs-comment">// SimpleProducer 简单生产生</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleProducer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br>config.ClientID = <span class="hljs-string">&quot;demo-producer&quot;</span><br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>producer, err := sarama.NewAsyncProducer(brokers, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> message := <span class="hljs-keyword">range</span> producer.Successes() &#123;<br>logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> err := <span class="hljs-keyword">range</span> producer.Errors() &#123;<br>logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>Topic: topic,<br>Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>&#125;<br>&#125;<br><span class="hljs-comment">// 关闭生产者</span><br>_ = producer.Close()<br><span class="hljs-comment">// 等待处理完所有的回调信息</span><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>sarama 的 consumer 将会变得复杂一点，需要我们去实现它的消费 handler 接口，同时提供<code>Consumer</code>和<code>ConsumerGroup</code>两种，不在赘述消费者和消费者组的概念，这里使用<code>ConsumerGroup</code>来演示。创建方式和 producer 基本一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> groupID = <span class="hljs-string">&quot;sarama-consumer&quot;</span><br><span class="hljs-keyword">var</span> brokers = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-keyword">var</span> config = sarama.NewConfig()<br>sarama.NewConsumerGroup(brokers, groupID, config)<br></code></pre></td></tr></table></figure><p>对于 consumer 来说通常的配置就是关闭自动提交和偏移量初始化策略(oldest或latest)，配置如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关闭自动提交</span><br>config.Consumer.Offsets.AutoCommit.Enable = <span class="hljs-literal">false</span><br>config.Consumer.Offsets.Initial = sarama.OffsetOldest<br><br></code></pre></td></tr></table></figure><p><code>config.Consumer.Offsets.Initial</code>和 ack 一致，本质上是 int64，这里同样是为了消除魔数</p><p>下面开始消费数据，其方法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Consume(ctx context.Context, topics []<span class="hljs-type">string</span>, handler ConsumerGroupHandler) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><ul><li>ctx: 上下文对象，因为消费逻辑在 goroutine 中进行，需要使用 context 来控制</li><li>topics: 需要消费的 topic</li><li>handler: 封装消费逻辑</li></ul><p>对于 ctx 为了让 consumer 优雅退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搞一个上下文用于终止消费者</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-comment">// 监听终止信号</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>  signal.Notify(quit, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)<br>  &lt;-quit<br>  cancelFunc()<br>&#125;()<br></code></pre></td></tr></table></figure><p>当监听到系统终止等信号时执行<code>cancelFunc</code>停止<code>handler</code>的消费逻辑，我们需要实现<code>ConsumerGroupHandler</code>的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ConsumerGroupHandler <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Setup is run at the beginning of a new session, before ConsumeClaim.</span><br>Setup(ConsumerGroupSession) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// Cleanup is run at the end of a session, once all ConsumeClaim goroutines have exited</span><br><span class="hljs-comment">// but before the offsets are committed for the very last time.</span><br>Cleanup(ConsumerGroupSession) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// ConsumeClaim must start a consumer loop of ConsumerGroupClaim&#x27;s Messages().</span><br><span class="hljs-comment">// Once the Messages() channel is closed, the Handler must finish its processing</span><br><span class="hljs-comment">// loop and exit.</span><br>ConsumeClaim(ConsumerGroupSession, ConsumerGroupClaim) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个空结构体去实现这个接口，暂时先不关注<code>Setup</code>和<code>Cleanup</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 同步提交</span><br>      session.Commit()<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips: <code>session.MarkMessage(message, &quot;&quot;)</code>是很重要的操作，标记当前消息已经处理完成并在内部记录当前分区的偏移量，但并不是提交偏移量，Mark 的作用相当于 flink 的状态，当调用<code>session.Commit()</code>时才会将内部保存的 offset 提交到 kafka 中。为了确保消息不丢失一定是先处理数据再标记消息</p></blockquote><p>为了提高效率需要将<code>session.Commit()</code>进行异步处理，因此在<code>Setup</code>中启动一个 goroutine 专门用于异步提交，当消息处理完告知这个 goroutine 进行一次 Commit，因此需要维护一个 channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> asyncOffset <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// 后面再解释</span><br><span class="hljs-keyword">const</span> defaultOffsetChannelSize = math.MaxInt<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Setup(session sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 初始化异步提交的channel</span><br>asyncOffset = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, defaultOffsetChannelSize)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 异步提交偏移量</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> asyncOffset &#123;<br>session.Commit()<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Cleanup</code>用于关闭通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Cleanup(_ sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 关闭通道</span><br><span class="hljs-built_in">close</span>(asyncOffset)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConsumeClaim</code>则触发提交偏移量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 异步提交</span><br>asyncOffset &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> Tips: 空 struct{} 在 go 中是不占用内存空间的</p></blockquote><p>为了当客户端停止消费时所有的偏移量都能提交则使用<code>sync.WaitGroup</code>，最终完整代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> groupID = <span class="hljs-string">&quot;sarama-consumer&quot;</span><br><span class="hljs-keyword">var</span> asyncOffset <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-keyword">const</span> defaultOffsetChannelSize = math.MaxInt<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleConsumer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 消费者配置</span><br>config := sarama.NewConfig()<br><span class="hljs-comment">// 关闭自动提交</span><br>config.Consumer.Offsets.AutoCommit.Enable = <span class="hljs-literal">false</span><br>config.Consumer.Offsets.Initial = sarama.OffsetOldest<br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = consumer.Close() &#125;()<br><span class="hljs-comment">// 搞一个上下文用于终止消费者</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-comment">// 监听终止信号</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>logger.Println(<span class="hljs-string">&quot;monitor signal&quot;</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(quit, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)<br>&lt;-quit<br>logger.Println(<span class="hljs-string">&quot;stop consumer&quot;</span>)<br>cancelFunc()<br>&#125;()<br><span class="hljs-comment">// 消费数据</span><br>err = consumer.Consume(ctx, []<span class="hljs-type">string</span>&#123;topic&#125;, &amp;Consumer&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">// 等待所有偏移量都提交完毕再退出</span><br>logger.Println(<span class="hljs-string">&quot;当前存在未提交的偏移量&quot;</span>)<br>wg.Wait()<br>&#125;<br><br><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Setup(session sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 初始化异步提交的channel</span><br>asyncOffset = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, defaultOffsetChannelSize)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 异步提交偏移量</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> asyncOffset &#123;<br>session.Commit()<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Cleanup(_ sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 关闭通道</span><br><span class="hljs-built_in">close</span>(asyncOffset)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 异步提交</span><br>asyncOffset &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级1</title>
    <link href="/2024/05/27/tools/Mysql%E9%AB%98%E7%BA%A71/"/>
    <url>/2024/05/27/tools/Mysql%E9%AB%98%E7%BA%A71/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql高级1"><a href="#Mysql高级1" class="headerlink" title="Mysql高级1"></a>Mysql高级1</h1><h3 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h3><table><thead><tr><th align="center">序号</th><th>Day01</th><th>Day02</th><th>Day03</th><th>Day04</th></tr></thead><tbody><tr><td align="center">1</td><td>Linux系统安装MySQL</td><td>体系结构</td><td>应用优化</td><td>MySQL 常用工具</td></tr><tr><td align="center">2</td><td>索引</td><td>存储引擎</td><td>查询缓存优化</td><td>MySQL 日志</td></tr><tr><td align="center">3</td><td>视图</td><td>优化SQL步骤</td><td>内存管理及优化</td><td>MySQL 主从复制</td></tr><tr><td align="center">4</td><td>存储过程和函数</td><td>索引使用</td><td>MySQL锁问题</td><td>综合案例</td></tr><tr><td align="center">5</td><td>触发器</td><td>SQL优化</td><td>常用SQL技巧</td><td></td></tr></tbody></table><h3 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1. Linux 系统安装MySQL"></a>1. Linux 系统安装MySQL</h3><h4 id="1-1-下载Linux-安装包"><a href="#1-1-下载Linux-安装包" class="headerlink" title="1.1 下载Linux 安装包"></a>1.1 下载Linux 安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/downloads/my</span>sql/<span class="hljs-number">5.7</span>.html<span class="hljs-comment">#downloads</span><br></code></pre></td></tr></table></figure><h4 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1.2 安装MySQL"></a>1.2 安装MySQL</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>). 卸载 centos 中预安装的 mysql<br><br><span class="hljs-attribute">rpm</span> -qa | grep -i mysql<br><br><span class="hljs-attribute">rpm</span> -e mysql-libs-<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">71</span>-<span class="hljs-number">1</span>.el6.x86_64 --nodeps<br><br><span class="hljs-attribute">2</span>). 上传 mysql 的安装包<br><br><span class="hljs-attribute">alt</span> + p -------&gt; put  E:/test/MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar<br><br><span class="hljs-attribute">3</span>). 解压 mysql 的安装包 <br><br><span class="hljs-attribute">mkdir</span> mysql<br><br><span class="hljs-attribute">tar</span> -xvf MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar -C /root/mysql<br><br><span class="hljs-attribute">4</span>). 安装依赖包 <br><br><span class="hljs-attribute">yum</span> -y install libaio.so.<span class="hljs-number">1</span> libgcc_s.so.<span class="hljs-number">1</span> libstdc++.so.<span class="hljs-number">6</span> libncurses.so.<span class="hljs-number">5</span> --setopt=protected_multilib=false<br><br><span class="hljs-attribute">yum</span>  update libstdc++-<span class="hljs-number">4</span>.<span class="hljs-number">4</span>.<span class="hljs-number">7</span>-<span class="hljs-number">4</span>.el6.x86_64<br><br><span class="hljs-attribute">5</span>). 安装 mysql-client<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-client-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br><span class="hljs-attribute">6</span>). 安装 mysql-server<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-server-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br></code></pre></td></tr></table></figure><h4 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">service mysql <span class="hljs-keyword">start</span><br><br>service mysql stop<br><br>service mysql status<br><br>service mysql restart<br></code></pre></td></tr></table></figure><h4 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : /root/.mysql_secret<br><br>mysql -u root -p <br><br>登录之后, 修改密码 :<br><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> = <span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;itcast&#x27;</span>);<br><br>授权远程访问 : <br><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span> @<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br><br></code></pre></td></tr></table></figure><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的&#x3D;&#x3D;示意图&#x3D;&#x3D;所示 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093105938.png?raw=true" alt="image-20240511093105938"></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><h4 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h4><p>优势</p><p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p><p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>劣势</p><p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p><p>2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><h4 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h4><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h5 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h5><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m&#x2F;2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。所以 2 &lt;&#x3D; n &lt;&#x3D;4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p>演变过程如下：</p><p>1). 插入前4个字母 C N G A </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093133875.png?raw=true" alt="image-20240511093133875"></p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093226560.png?raw=true" alt="image-20240511093226560"></p><p>3). 插入E，K，Q不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093242231.png?raw=true" alt="image-20240511093242231"></p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093256714.png?raw=true" alt="image-20240511093256714"></p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093311693.png?raw=true" alt="image-20240511093311693"></p><p>6). 插入Z，中间元素T向上分裂到父节点中 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093325753.png?raw=true" alt="image-20240511093325753"></p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093339035.png?raw=true" alt="image-20240511093339035"> </p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p> <img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093408372.png?raw=true" alt="image-20240511093408372"></p><p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p><h5 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h5><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p><p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p><p>3). 所有的非叶子节点都可以看作是key的索引部分。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511095521998.png?raw=true" alt="image-20240511095521998"></p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><h5 id="2-3-3-MySQL中的B-Tree"><a href="#2-3-3-MySQL中的B-Tree" class="headerlink" title="2.3.3 MySQL中的B+Tree"></a>2.3.3 MySQL中的B+Tree</h5><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>MySQL中的 B+Tree 索引结构示意图: </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093508330.png?raw=true" alt="image-20240511093508330">  </p><h4 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h4><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p><p>2） 唯一索引 ：索引列的值必须唯一，但允许有空值</p><p>3） 复合索引 ：即一个索引包含多个列</p><h4 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h4><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p><p>准备环境:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database demo_01 <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br>use demo_01;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `city` (<br>  `city_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `city_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`city_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `country` (<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `country_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`country_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;西安&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;NewYork&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;China&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;America&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Japan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;UK&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h5><p>语法 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span><span class="hljs-operator">|</span>FULLTEXT<span class="hljs-operator">|</span>SPATIAL]  INDEX index_name <br>[<span class="hljs-keyword">USING</span>  index_type]<br><span class="hljs-keyword">ON</span> tbl_name(index_col_name,...)<br><br><br>index_col_name : column_name[(length)][<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure><p>示例 ： 为city表中的city_name字段创建索引 ；</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093540046.png?raw=true" alt="image-20240511093540046">      </p><p>​</p><h5 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h5><p>语法： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span>  <span class="hljs-keyword">from</span>  <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure><p>示例：查看city表中的索引信息；</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093603250.png?raw=true" alt="image-20240511093603250"> </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093619542.png?raw=true" alt="image-20240511093619542">  </p><h5 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h5><p>语法 ：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">INDEX</span>  index_name  <span class="hljs-keyword">ON</span>  tbl_name;<br></code></pre></td></tr></table></figure><p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093636153.png?raw=true" alt="image-20240511093636153">  </p><h5 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sas">1). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">primary</span>  <span class="hljs-keyword">key</span>(column_list); <br><br>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="hljs-keyword">NULL</span><br><br>2). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">unique</span> index_name(column_list);<br><br>这条语句创建索引的值必须是唯一的（除了<span class="hljs-keyword">NULL</span>外，<span class="hljs-keyword">NULL</span>可能会出现多次）<br><br>3). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">index</span> index_name(column_list);<br><br>添加普通索引， 索引值可以出现多次。<br><br>4). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  fulltext  index_name(column_list);<br><br>该语句指定了索引为FULLTEXT， 用于全文索引<br><br></code></pre></td></tr></table></figure><h4 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h4><p>​索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li><p>对查询频次较高，且数据量比较大的表建立索引。</p></li><li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p></li><li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p></li><li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。</p></li><li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">创建复合索引:<br><br>CREATE <span class="hljs-built_in">INDEX</span> idx_name_email_status ON tb_seller(<span class="hljs-keyword">NAME</span>,email,<span class="hljs-keyword">STATUS</span>);<br><br>就相当于<br>对<span class="hljs-keyword">name</span> 创建索引 ;<br>对<span class="hljs-keyword">name</span> , email 创建了索引 ;<br>对<span class="hljs-keyword">name</span> , email, <span class="hljs-keyword">status</span> 创建了索引 ;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h3><h4 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h4><p>​视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li></ul><h4 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h4><p>创建视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><p>修改视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">选项 : <br><span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION 决定了是否允许更新数据使记录不再满足视图的条件。<br><br><span class="hljs-keyword">LOCAL</span> ： 只要满足本视图的条件就可以更新。<br><span class="hljs-keyword">CASCADED</span> ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.<br></code></pre></td></tr></table></figure><p>示例 , 创建city_country_view视图 , 执行如下SQL : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> city_country_view <br><span class="hljs-keyword">as</span> <br><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span>,c.country_name <span class="hljs-keyword">from</span> country c , city t <span class="hljs-keyword">where</span> c.country_id <span class="hljs-operator">=</span> t.country_id;<br><br></code></pre></td></tr></table></figure><p>查询视图 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093657857.png?raw=true" alt="image-20240511093657857"> </p><h4 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h4><p>​从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093713607.png?raw=true" alt="image-20240511093713607"> </p><p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093736277.png?raw=true" alt="image-20240511093736277"> </p><p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093747136.png?raw=true" alt="image-20240511093747136">  </p><h4 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h4><p>语法 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT <span class="hljs-operator">|</span> CASCADE]<br></code></pre></td></tr></table></figure><p>示例 , 删除视图city_country_view :</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">DROP</span> <span class="hljs-built_in">VIEW</span> city_country_view ;<br></code></pre></td></tr></table></figure><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><h4 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h4><p>​存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>​存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p><p>​函数 ： 是一个有返回值的过程 ；</p><p>​过程 ： 是一个没有返回值的函数 ；</p><h4 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> procedure_name ([proc_parameter[,...]])<br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">end</span> ;<br></code></pre></td></tr></table></figure><p>示例 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test1()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Hello Mysql&#x27;</span> ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong><font color="red">知识小贴士</font></strong></p><p>DELIMITER</p><p>​该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p><p>dbeaver 图形工具新修改执行命令即可</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4570978019.jpg?raw=true" alt="img"></p><h4 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> procedure_name() ;<br></code></pre></td></tr></table></figure><h4 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询db_name数据库中的所有的存储过程</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> mysql.proc <span class="hljs-keyword">where</span> db<span class="hljs-operator">=</span><span class="hljs-string">&#x27;db_name&#x27;</span>;<br><br><br><span class="hljs-comment">-- 查询存储过程的状态信息</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">procedure</span> status;<br><br><br><span class="hljs-comment">-- 查询某个存储过程的定义</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> test.pro_test1 \G;<br></code></pre></td></tr></table></figure><h4 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span>  [IF <span class="hljs-keyword">EXISTS</span>] sp_name ；<br></code></pre></td></tr></table></figure><h4 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h4><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p><h5 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h5><ul><li>DECLARE</li></ul><p>  通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> var_name[,...] type [<span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">value</span>]<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test2() <br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> num<span class="hljs-operator">+</span> <span class="hljs-number">10</span>; <br><span class="hljs-keyword">end</span>$<br><br>delimiter ; <br></code></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET var_name = <span class="hljs-built_in">expr</span> [, var_name = <span class="hljs-built_in">expr</span>] ...<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test3()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">SET</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MYSQL&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> NAME ;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>也可以通过select … into 方式进行赋值操作 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test5()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">declare</span>  countnum <span class="hljs-type">int</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> countnum <span class="hljs-keyword">from</span> city;<br><span class="hljs-keyword">select</span> countnum;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h5 id="4-6-2-if条件判断"><a href="#4-6-2-if条件判断" class="headerlink" title="4.6.2 if条件判断"></a>4.6.2 if条件判断</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">if search_condition <span class="hljs-keyword">then</span> statement_list<br><br>[elseif search_condition <span class="hljs-keyword">then</span> statement_list] ...<br><br>[<span class="hljs-keyword">else</span> statement_list]<br><br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><p>需求： </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">根据定义的身高变量，判定当前身高的所属的身材类型 <br><br><span class="hljs-number">180</span> 及以上 <span class="hljs-comment">----------&gt; 身材高挑</span><br><br><span class="hljs-number">170</span> - <span class="hljs-number">180</span>  <span class="hljs-comment">---------&gt; 标准身材</span><br><br><span class="hljs-number">170</span> 以下  <span class="hljs-comment">----------&gt; 一般身材</span><br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test6()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span>  height  <span class="hljs-type">int</span>  <span class="hljs-keyword">default</span>  <span class="hljs-number">175</span>; <br>  <span class="hljs-keyword">declare</span>  description  <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <br>  if  height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br>  <br>  <span class="hljs-keyword">select</span> description ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p>调用结果为 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240510165046431.png?raw=true" alt="image-20240510165046431"></p><h5 id="4-6-3-传递参数"><a href="#4-6-3-传递参数" class="headerlink" title="4.6.3 传递参数"></a>4.6.3 传递参数</h5><p>语法格式 : </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">procedure_name</span><span class="hljs-params">([<span class="hljs-keyword">in</span>/<span class="hljs-keyword">out</span>/inout] 参数名   参数类型)</span><br>...<br><br><br><span class="hljs-title function_">IN</span> :   该参数可以作为输入，也就是需要调用方传入值 , 默认<br><span class="hljs-keyword">OUT</span>:   该参数作为输出，也就是该参数可以作为返回值<br>INOUT: 既可以作为输入参数，也可以作为输出参数<br></code></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据定义的身高变量，判定当前身高的所属的身材类型 <br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;身高 &#x27;</span>, height , <span class="hljs-string">&#x27;对应的身材类型为:&#x27;</span>,description);<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br><span class="hljs-keyword">CALL</span> pro_test5(<span class="hljs-number">180</span>); #调用<br><br># 返回<br>身高 <span class="hljs-number">180</span>对应的身材类型为:身材高挑<br></code></pre></td></tr></table></figure><p><strong>OUT-输出</strong></p><p> 需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据传入的身高变量，获取当前身高的所属的身材类型  <br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span> , <span class="hljs-keyword">out</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>))<br><span class="hljs-keyword">begin</span><br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>$<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">call</span> <span class="hljs-selector-tag">pro_test5</span>(<span class="hljs-number">168</span>, <span class="hljs-variable">@description</span>);<br><span class="hljs-selector-tag">select</span> @<span class="hljs-selector-tag">description</span>;<br></code></pre></td></tr></table></figure><p><font color='red'><strong>小知识</strong> </font></p><p>@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p><p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 </p><h5 id="4-6-4-case结构"><a href="#4-6-4-case结构" class="headerlink" title="4.6.4 case结构"></a>4.6.4 case结构</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs SQL">方式一 : <br><br><span class="hljs-keyword">CASE</span> case_value<br><br>  <span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br><br>方式二 : <br><br><span class="hljs-keyword">CASE</span><br><br>  <span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个月份, 然后计算出所在的季度<br></code></pre></td></tr></table></figure><p>示例  :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test9(<span class="hljs-keyword">month</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">case</span> <br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">3</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第一季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">6</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第二季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">9</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第三季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">12</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第四季度&#x27;</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br>  <br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;您输入的月份为 :&#x27;</span>, <span class="hljs-keyword">month</span> , <span class="hljs-string">&#x27; , 该月份为 : &#x27;</span> , <span class="hljs-keyword">result</span>) <span class="hljs-keyword">as</span> content ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br><br><br><span class="hljs-keyword">call</span> pro_test9(<span class="hljs-number">3</span>);<br><br># 返回<br>content<br>您输入的月份为 :<span class="hljs-number">3</span> , 该月份为 : 第一季度<br></code></pre></td></tr></table></figure><h5 id="4-6-5-while循环"><a href="#4-6-5-while循环" class="headerlink" title="4.6.5 while循环"></a>4.6.5 while循环</h5><p>语法结构: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">while search_condition do<br><br>statement_list<br><br><span class="hljs-keyword">end</span> while;<br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test8(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  while num<span class="hljs-operator">&lt;=</span>n do<br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> num;<br><span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span> while;<br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test8(<span class="hljs-number">3</span>);<br><br>#返回<br>totle<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h5 id="4-6-6-repeat结构"><a href="#4-6-6-repeat结构" class="headerlink" title="4.6.6 repeat结构"></a>4.6.6 repeat结构</h5><p>有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。</p><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">REPEAT<br><br>  statement_list<br><br>  UNTIL search_condition<br><br><span class="hljs-keyword">END</span> REPEAT;<br></code></pre></td></tr></table></figure><p>需求: </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test10(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  repeat <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>    until n<span class="hljs-operator">=</span><span class="hljs-number">0</span>  <br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">select</span> total ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test10(<span class="hljs-number">5</span>);<br><br># 返回<br>totle<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h5 id="4-6-7-loop语句"><a href="#4-6-7-loop语句" class="headerlink" title="4.6.7 loop语句"></a>4.6.7 loop语句</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">[begin_label:] LOOP<br><br>  statement_list<br><br><span class="hljs-keyword">END</span> LOOP [end_label]<br></code></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。</p><h5 id="4-6-8-leave语句"><a href="#4-6-8-leave语句" class="headerlink" title="4.6.8 leave语句"></a>4.6.8 leave语句</h5><p>用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SQL">delimiter $<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> pro_test11(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  ins: LOOP<br>    <br>    IF n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>      leave ins;<br>    <span class="hljs-keyword">END</span> IF;<br>    <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">END</span> LOOP ins;<br>  <br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">END</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-9-游标-光标"><a href="#4-6-9-游标-光标" class="headerlink" title="4.6.9 游标&#x2F;光标"></a>4.6.9 游标&#x2F;光标</h5><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> cursor_name <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> select_statement ;<br></code></pre></td></tr></table></figure><p>OPEN 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>FETCH 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> cursor_name <span class="hljs-keyword">INTO</span> var_name [, var_name] ...<br></code></pre></td></tr></table></figure><p>CLOSE 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>示例 : </p><p>初始化脚本:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment ,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;薪水&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;金毛狮王&#x27;</span>,<span class="hljs-number">55</span>,<span class="hljs-number">3800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;白眉鹰王&#x27;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">4000</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;青翼蝠王&#x27;</span>,<span class="hljs-number">38</span>,<span class="hljs-number">2800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;紫衫龙王&#x27;</span>,<span class="hljs-number">42</span>,<span class="hljs-number">1800</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 查询emp表中数据, 并逐行获取进行展示</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test11()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> e_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">declare</span> e_age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> emp_result <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test11();<br><br># 返回 <br><span class="hljs-keyword">No</span> data <span class="hljs-operator">-</span> zero <span class="hljs-keyword">rows</span> fetched, selected, <span class="hljs-keyword">or</span> processed    # 因为多出一次获取游标数据 四次返回正常<br><br><br></code></pre></td></tr></table></figure><p>通过循环结构 , 获取游标中的数据 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test12()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">DECLARE</span> age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> has_data <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">DECLARE</span> emp_result <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <span class="hljs-keyword">DECLARE</span> EXIT HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  repeat<br>    <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> id , name , age , salary;<br>    <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id为&#x27;</span>,id, <span class="hljs-string">&#x27;, name 为&#x27;</span> ,name , <span class="hljs-string">&#x27;, age为 &#x27;</span> ,age , <span class="hljs-string">&#x27;, 薪水为: &#x27;</span>, salary);<br>    until has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br>DELIMITER ; <br># 调用<br><span class="hljs-keyword">call</span> pro_test11();<br><br># 返回 <br>id为<span class="hljs-number">1</span>, name 为金毛狮王, age为 <span class="hljs-number">55</span>, 薪水为: <span class="hljs-number">3800</span><br>id为<span class="hljs-number">2</span>, name 为白眉鹰王, age为 <span class="hljs-number">60</span>, 薪水为: <span class="hljs-number">4000</span><br>id为<span class="hljs-number">3</span>, name 为青翼蝠王, age为 <span class="hljs-number">38</span>, 薪水为: <span class="hljs-number">2800</span><br>id为<span class="hljs-number">4</span>, name 为紫衫龙王, age为 <span class="hljs-number">42</span>, 薪水为: <span class="hljs-number">1800</span><br></code></pre></td></tr></table></figure><h4 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h4><p>语法结构:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> function_name([param <span class="hljs-built_in">type</span> ... ]) <br>RETURNS <span class="hljs-built_in">type</span> <br><span class="hljs-keyword">BEGIN</span><br>...<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>案例 : </p><p>定义一个存储过程, 请求满足条件的总记录数 ;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><br>delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> count_city(countryId <span class="hljs-type">int</span>)<br><span class="hljs-keyword">returns</span> <span class="hljs-type">int</span> <span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> cnum <span class="hljs-type">int</span> ;<br>  <br>  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> cnum <span class="hljs-keyword">from</span> city <span class="hljs-keyword">where</span> country_id <span class="hljs-operator">=</span> countryId;<br>  <br>  <span class="hljs-keyword">return</span> cnum;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br># 确定函数属性 不确定无法创建<br><span class="hljs-keyword">DETERMINISTIC</span>: 如果你的函数对于相同的输入参数，每次调用都返回相同的结果，且不依赖于外部状态或数据库状态的变化，就可以声明为 <span class="hljs-keyword">DETERMINISTIC</span>。例如，一个计算两个数字相加的函数就是确定性的。<br><br><span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span>: 如果你的函数完全不包含任何 <span class="hljs-keyword">SQL</span> 语句，也就是说它不读取也不修改数据库中的数据，可以声明为 <span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span>。<br><br><span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA: 如果你的函数读取数据库中的数据但不修改数据，应声明为 <span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA。<br></code></pre></td></tr></table></figure><p>调用: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h4 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h4><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> trigger_name <br><br>before<span class="hljs-operator">/</span>after <span class="hljs-keyword">insert</span><span class="hljs-operator">/</span><span class="hljs-keyword">update</span><span class="hljs-operator">/</span><span class="hljs-keyword">delete</span><br><br><span class="hljs-keyword">on</span> tbl_name <br><br>[ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> ]  <span class="hljs-comment">-- 行级触发器</span><br><br><span class="hljs-keyword">begin</span><br><br>trigger_stmt ;<br><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>示例 </p><p>需求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;<br></code></pre></td></tr></table></figure><p>首先创建一张日志表 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp_logs(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>  operation <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作类型, insert/update/delete&#x27;</span>,<br>  operate_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,<br>  operate_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作表的ID&#x27;</span>,<br>  operate_params <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) comment <span class="hljs-string">&#x27;操作参数&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>创建 insert 型触发器，完成插入数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_insert_trigger<br>after <span class="hljs-keyword">insert</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));<br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建 update 型触发器，完成更新数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_update_trigger<br>after <span class="hljs-keyword">update</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="hljs-string">&#x27;name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_delete_trigger<br>after <span class="hljs-keyword">delete</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="hljs-string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明左使&#x27;</span>,<span class="hljs-number">30</span>,<span class="hljs-number">3500</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明右使&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-number">3200</span>);<br><br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">39</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h4><p>语法结构 : </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> [<span class="hljs-built_in">schema_name</span>.]trigger_name<br></code></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h4 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h4><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> triggers ；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora 用法</title>
    <link href="/2024/05/27/tools/Typora%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/27/tools/Typora%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Typora的语法"><a href="#Typora的语法" class="headerlink" title="Typora的语法"></a>Typora的语法</h2><p>表格<br>可以在—分割线加入：设置表格对齐方式<br>“:——–“表示左对齐，”:———:“表示居中对齐，”———-:”表示右对齐</p><p>无序列表：- + 空格<br>有序列表：1. + 空格<br>引用：&gt; + 空格<br>标题：ctrl + 数字<br>表格：ctrl + t<br>生成目录：[TOC] + 回车<br>选中一整行：ctrl + l<br>选中单词：ctrl + d<br>选中相同格式的文字：ctrl + e<br>跳转到文章开头：ctrl + home<br>跳转到文章结尾：ctrl + end<br>搜索：ctrl + f<br>替换：ctrl + h<br>加粗：ctrl + b<br>倾斜：ctrl + i<br>下划线：ctrl + u<br>删除线：alt + shift + 5<br>插入图片：直接拖动到指定位置即可或者ctrl + shift + i<br>插入链接：ctrl + k</p><p><a href="https://blog.csdn.net/qq_40896997/article/details/106551767">表情</a></p><p>:white_check_mark:</p><p>:x:</p><p>:heavy_check_mark:</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 入门</title>
    <link href="/2024/05/27/tools/Redis%E5%85%A5%E9%97%A8/"/>
    <url>/2024/05/27/tools/Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis基本介绍和基本使用方法"><a href="#Redis基本介绍和基本使用方法" class="headerlink" title="Redis基本介绍和基本使用方法"></a>Redis基本介绍和基本使用方法</h2><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h2><p>Redis是一个开源的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">内存数据库</a>，属于NoSQL数据库的一种。它以高性能、支持丰富的数据结构、持久化特性、复制、集群以及发布&#x2F;订阅等特性而闻名。，遵守BSD协议，是一个高性能的key-value非关系型数据库。</p><h3 id="Redis特点："><a href="#Redis特点：" class="headerlink" title="Redis特点："></a>Redis特点：</h3><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</p><p>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, 设置key有效期等等特性。</p><h3 id="redis作用"><a href="#redis作用" class="headerlink" title="redis作用:"></a>redis作用:</h3><p>可以减轻数据库压力，查询内存比查询数据库效率高。</p><h3 id="Redis应用："><a href="#Redis应用：" class="headerlink" title="Redis应用："></a>Redis应用：</h3><p>token生成、session共享、分布式锁、自增id、验证码等。</p><h3 id="比较重要的3个可执行文件："><a href="#比较重要的3个可执行文件：" class="headerlink" title="比较重要的3个可执行文件："></a>比较重要的3个可执行文件：</h3><p>redis-server：Redis服务器程序</p><p>redis-cli：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。</p><p>redis-benchmark：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能。</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Redis key值是二进制安全的，即可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效key值</p><p>注：<br>定义key的规则：<br>  避免太长的键，不仅因为消耗内存，而且在数据中查找这类键值的计算成本很高；<br>  避免太短的键，如使用u:1000:pwd代替user:1000:password，但后者更易阅读，并且由此增加的空间消耗相对于key object和value object本身来说很小；<br>  最好坚持一种模式。如：<code>object-type:id:field</code></p><h3 id="2-key使用"><a href="#2-key使用" class="headerlink" title="2 key使用"></a>2 key使用</h3><h4 id="2-1-按模式匹配对应的key"><a href="#2-1-按模式匹配对应的key" class="headerlink" title="2.1 按模式匹配对应的key"></a>2.1 按模式匹配对应的key</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"> keys <span class="hljs-keyword">pattern</span><br> <br> gva164:db0<span class="hljs-operator">&gt;</span> keys <span class="hljs-operator">*</span><span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;k1:1&quot;<br><span class="hljs-number">2</span>) &quot;k11&quot;<br><span class="hljs-number">3</span>) &quot;k1&quot;<br>gva164:db0<span class="hljs-operator">&gt;</span> keys <span class="hljs-operator">*</span><span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;k12&quot;<br><span class="hljs-number">2</span>) &quot;k2&quot;<br></code></pre></td></tr></table></figure><h4 id="2-2-判断key是否存在"><a href="#2-2-判断key是否存在" class="headerlink" title="2.2 判断key是否存在"></a>2.2 判断key是否存在</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exists</span> key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">exists</span> k1 k2 k5<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="2-3-查看key的类型"><a href="#2-3-查看key的类型" class="headerlink" title="2.3 查看key的类型"></a>2.3 查看key的类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">type key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> type k2<br>string<br></code></pre></td></tr></table></figure><h4 id="2-4删除指定的key"><a href="#2-4删除指定的key" class="headerlink" title="2.4删除指定的key"></a>2.4删除指定的key</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">del key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> del k3 k13<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="2-5-根据value选择非阻塞删除"><a href="#2-5-根据value选择非阻塞删除" class="headerlink" title="2.5 根据value选择非阻塞删除"></a>2.5 根据value选择非阻塞删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlink key  <br></code></pre></td></tr></table></figure><p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</p><h4 id="2-6-为给定的key设置过期时间（单位-秒）"><a href="#2-6-为给定的key设置过期时间（单位-秒）" class="headerlink" title="2.6 为给定的key设置过期时间（单位 秒）"></a>2.6 为给定的key设置过期时间（单位 秒）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">expire key <span class="hljs-number">10</span> <br><br>gva164:db0<span class="hljs-operator">&gt;</span> expire k1 <span class="hljs-number">10</span><br><span class="hljs-number">1</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello<br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1# 查看key还有多少秒到期,<span class="hljs-number">-1</span>表示用不过期,<span class="hljs-number">-2</span>表示已经过期<br><span class="hljs-number">1</span><br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1<br><span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><h3 id="3-redis-原子性"><a href="#3-redis-原子性" class="headerlink" title="3 redis 原子性"></a>3 redis 原子性</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240515171954888.png?raw=true" alt="image-20240515171954888"></p><p>  原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</p><p>​<strong>Redis命令的原子性主要得益于Redis的单线程</strong></p><h2 id="value的五种数据类型"><a href="#value的五种数据类型" class="headerlink" title="value的五种数据类型"></a>value的五种数据类型</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>  String是Redis value的最基本类型<br>  String类型是二进制安全的，意味着Redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br>  String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M<br>  字符串类型的内部编码有3种：int：8个字节的长整型；embstr：小于等于39个字节的字符串；raw：大于39个字节的字符串</p><h4 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h4><p><strong>添加键值对</strong></p><p>若原来存在，默认会存在覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello world<br>ERR syntax error<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello,world<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello,world<br></code></pre></td></tr></table></figure><p>NX：当数据库中key不存在时，可以将key-value添加数据库，<code>可用于分布式锁</code><br>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>EX：key的超时秒数<br>PX：key的超时毫秒数，与EX互斥</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v100 ex <span class="hljs-number">20</span> nx<br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v100 ex <span class="hljs-number">20</span> xx<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v100<br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1<br><span class="hljs-number">13</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>查询对应键值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br></code></pre></td></tr></table></figure><p><strong>将给定的value 追加到原值的末尾</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">append  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v1<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> append k1 v2<br><span class="hljs-number">4</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v1v2<br></code></pre></td></tr></table></figure><p><strong>获得值的长度</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">strlen  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> strlen k1<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>将 key 中储存的数字值增1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">incr  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k2 <span class="hljs-number">2</span><br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> incr k2<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR 和 DECRBY，实际上他们在内部就是同一个命令。<br>  INCR是原子操作意味着什么呢？即使多个客户端对同一个key发出INCR命令，也决不会导致竞争的情况。客户端1和客户端2同时读出“10”，二者均对其加到11，然后将新值最终设置为11永远不可能发生，最终的值一定是12。read-increment-set操作完成时，其他客户端不会在同一时间执行任何命令。</p><p><strong>将 key 中储存的数字值减1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">decr  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k3<br><br>gva164:db0<span class="hljs-operator">&gt;</span> decr k3<br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>只能对数字值操作，如果为空，值为-1</p><p><strong>将 key 中储存的数字值增减，自定义步长</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">incrby <span class="hljs-operator">/</span> decrby  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span>步长<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k2<br><span class="hljs-number">3</span><br>gva164:db0<span class="hljs-operator">&gt;</span> incrby k2 <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k3 <span class="hljs-number">2</span><br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> decrby k3 <span class="hljs-number">5</span><br><span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure><p><strong>同时设置一个或多个 key-value对</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mset  <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>  ..... <br>gva164:db0<span class="hljs-operator">&gt;</span> mset k1 v1 k2 v2 k3 v3<br>OK<br></code></pre></td></tr></table></figure><p><strong>同时获取一个或多个value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mget <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> mget k1 k2 k3<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">msetnx <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>  ..... <br></code></pre></td></tr></table></figure><p>原子性，有一个失败则都失败</p><p><strong>截取字符串</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">getrange  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>起始位置<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>结束位置<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> ks abcdef<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> getrange ks <span class="hljs-number">13</span><br>ERR wrong number <span class="hljs-keyword">of</span> arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getrange&#x27;</span> command<br>gva164:db0<span class="hljs-operator">&gt;</span> getrange ks <span class="hljs-number">1</span> <span class="hljs-number">3</span><br>bcd<br></code></pre></td></tr></table></figure><p><strong>用 value 覆写key所储存的字符串值，从起始位置开始(索引从0开始)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">setrange  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>起始位置<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>设置键值的同时，设置过期时间，单位秒</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">setex  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>过期时间<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>以新换旧，设置了新值同时获得旧值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">getset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v1<br>gva164:db0<span class="hljs-operator">&gt;</span> getset k1 v100<br>v1<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v100<br></code></pre></td></tr></table></figure><p>如：系统中每当有新用户访问时就用INCR命令操作一个Redis key。若每小时对这个信息收集一次。可使用GETSET给其赋值0并读取原值。</p><h4 id="1-3-数据结构"><a href="#1-3-数据结构" class="headerlink" title="1.3  数据结构"></a>1.3  数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。采用预分配冗余空间的方式来减少内存的频繁分配。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240515175615866.png?raw=true" alt="image-20240515175615866"></p><p>如图中所示，为String类型实际分配的空间一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。</p><h3 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p><strong>单键多值</strong></p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边).</p><p>Redis lists基于LinkedList实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p><p>相对应的，在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linkedlist实现的list上没有那么快。</p><blockquote><p>所以：如何快速地在很大的列表上添加元素，建议使用List;如果快速访问集合元素很重要，建议使用可排序集合(sorted sets)。</p></blockquote><h4 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h4><p><strong>从左边&#x2F;右边插入一个或多个值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">lpush<span class="hljs-operator">/</span>rpush  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value3<span class="hljs-operator">&gt;</span> .... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v3&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lpush k1 v<span class="hljs-number">-3</span> v<span class="hljs-number">-2</span> v<span class="hljs-number">-1</span> <span class="hljs-number">0</span><br><span class="hljs-number">7</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;0&quot;<br><span class="hljs-number">2</span>) &quot;v-1&quot;<br><span class="hljs-number">3</span>) &quot;v-2&quot;<br><span class="hljs-number">4</span>) &quot;v-3&quot;<br><span class="hljs-number">5</span>) &quot;v3&quot;<br><span class="hljs-number">6</span>) &quot;v2&quot;<br><span class="hljs-number">7</span>) &quot;v1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> rpush k1 v8 v9 v10<br><span class="hljs-number">10</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;0&quot;<br><span class="hljs-number">2</span>) &quot;v-1&quot;<br><span class="hljs-number">3</span>) &quot;v-2&quot;<br><span class="hljs-number">4</span>) &quot;v-3&quot;<br><span class="hljs-number">5</span>) &quot;v3&quot;<br><span class="hljs-number">6</span>) &quot;v2&quot;<br><span class="hljs-number">7</span>) &quot;v1&quot;<br><span class="hljs-number">8</span>) &quot;v8&quot;<br><span class="hljs-number">9</span>) &quot;v9&quot;<br><span class="hljs-number">10</span>) &quot;v10&quot;<br></code></pre></td></tr></table></figure><p>如：在博客引擎实现中，可为每篇日志设置一个list，推入博客评论</p><p>注：<br>  使用LPUSH和RPOP实现生产者和消费者模型，会遇到这种情景：list是空，这时候消费者就需要轮询来获取数据，这样就会增加redis的访问压力、增加消费端的cpu时间，而很多访问都是无用的。为此redis提供了阻塞式访问 BRPOP 和 BLPOP 命令。 消费者可以在获取数据时指定如果数据不存在阻塞的时间，如果在时限内获得数据则立即返回，如果超时还没有数据则返回null, 0表示一直阻塞。</p><p><strong>从左边&#x2F;右边吐出一个值。值在键在，值光键亡</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">lpop<span class="hljs-operator">/</span>rpop  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lpop k2<br>v1<br>localhost:db0<span class="hljs-operator">&gt;</span> rpop k2<br>v3<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v2&quot;<br></code></pre></td></tr></table></figure><p><strong>从key1列表右边吐出一个值，插到key2列表左边</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">rpoplpush  <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lpush <span class="hljs-keyword">order</span> a1 a2 a3 a4<br><span class="hljs-number">4</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange <span class="hljs-keyword">order</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a1<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a2<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a3<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a4<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br></code></pre></td></tr></table></figure><p><strong>按照索引下标获得元素(从左到右)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>stop<span class="hljs-operator">&gt;</span><br><br></code></pre></td></tr></table></figure><p>0左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p>如新闻网站,可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p><p><strong>按照索引下标获得元素(从左到右)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>index<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lindex history_order <span class="hljs-number">1</span><br>a3<br>localhost:db0<span class="hljs-operator">&gt;</span> lindex history_order <span class="hljs-number">3</span><br>a1<br></code></pre></td></tr></table></figure><p><strong>获得列表长度</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">llen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> llen history_order<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>在 value的前面或后面插入 newvalue</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>newvalue<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> linsert history_order before a3 mya3<br><span class="hljs-number">5</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;mya3&quot;<br><span class="hljs-number">3</span>) &quot;a3&quot;<br><span class="hljs-number">4</span>) &quot;a2&quot;<br><span class="hljs-number">5</span>) &quot;a1&quot;<br></code></pre></td></tr></table></figure><p><strong>从左到右删除n个value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">lrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>n<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lpush a a b a b a b<br><span class="hljs-number">6</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;b&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;b&quot;<br><span class="hljs-number">4</span>) &quot;a&quot;<br><span class="hljs-number">5</span>) &quot;b&quot;<br><span class="hljs-number">6</span>) &quot;a&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lrem a <span class="hljs-number">3</span> b<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;a&quot;<br></code></pre></td></tr></table></figure><p><strong>将列表key下标为index的值替换成value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">lset<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>index<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;a&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lset a <span class="hljs-number">1</span> bbb<br>OK<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;bbb&quot;<br><span class="hljs-number">3</span>) &quot;a<br></code></pre></td></tr></table></figure><h4 id="2-3-数据结构"><a href="#2-3-数据结构" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h4><p>​List的数据结构为快速链表quickList</p><p>​    首先在列表元素较少的情况下使用ziplist，即压缩列表。它将所有的元素紧挨在一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，需要两个额外的指针prev和next。Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516095854166.png?raw=true" alt="image-20240516095854166"></p><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>​set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的,且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>​</p><p>​Redis的Set是string类型的无序集合,底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1) ，O(1)，数据增加，查找数据的时间不变</p><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p><strong>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> ..... <br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 v1 v1 v2 v3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br><br></code></pre></td></tr></table></figure><p><strong>取出该集合的所有值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 v1 v1 v2 v3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p> <strong>判断集合key是否为含有该value值，有1，没有0</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> sismember<br>k1 v1<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>返回该集合的元素个数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> scard k1<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>删除集合中的某个元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> .... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> srem k1 v1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>随机从该集合中吐出n个值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [n]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> spop k1 <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>随机从该集合中取出n个值，不会从集合中删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">srandmember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [n]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> srandmember k1 <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br></code></pre></td></tr></table></figure><p><strong>把集合中一个值从一个集合移动到另一个集合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">smove <span class="hljs-operator">&lt;</span>source<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>destination<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k2 p1 p2 p3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;p2&quot;<br><span class="hljs-number">2</span>) &quot;p3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smove k1 k2 v1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的交集元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sinter k1 k2<br><br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 p1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> sinter k1 k2<br><span class="hljs-number">1</span>) &quot;p1&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的并集元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sunion k1 k2<br><span class="hljs-number">1</span>) &quot;p1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br><span class="hljs-number">4</span>) &quot;v1&quot;<br><span class="hljs-number">5</span>) &quot;p2&quot;<br><span class="hljs-number">6</span>) &quot;p3&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的差集元素(key1中与key2不重复的value)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sdiff k1 k2<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sdiff k2 k1<br><span class="hljs-number">1</span>) &quot;p2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br></code></pre></td></tr></table></figure><h4 id="2-3-数据结构-1"><a href="#2-3-数据结构-1" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h4><p>​Set数据结构是dict字典，字典是用哈希表实现的</p><p>​Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id="4-哈希-hash"><a href="#4-哈希-hash" class="headerlink" title="4 哈希(hash)"></a>4 哈希(hash)</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><p>​Redis hash 是一个键值对集合</p><p>​Redis hash 是一个string 类型的field和value的映射表 ,hash 特别适合用于存储对象,类似java里面的Map&lt;string,Object&gt;</p><h4 id="4-2-常用命令"><a href="#4-2-常用命令" class="headerlink" title="4.2 常用命令"></a>4.2 常用命令</h4><p><strong>给key集合中的 field键赋值value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hset key [field <span class="hljs-keyword">value</span> ...]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> hset <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name cz grade <span class="hljs-number">88</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>从集合取出 value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hget <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br>cz<br></code></pre></td></tr></table></figure><p><strong>批量设置hash的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hmset <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field2<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> hmset <span class="hljs-keyword">user</span>:<span class="hljs-number">2</span> name yu grade <span class="hljs-number">90</span><br>OK<br></code></pre></td></tr></table></figure><p><strong>查看哈希表 key 中，给定域 field 是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hexists<span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hexists <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>列出该hash集合的所有field</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">hkeys <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hkeys <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;name&quot;<br><span class="hljs-number">2</span>) &quot;grade&quot;<br></code></pre></td></tr></table></figure><p><strong>列出该hash集合的所有value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hvals <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;cz&quot;<br><span class="hljs-number">2</span>) &quot;88&quot;<br></code></pre></td></tr></table></figure><p><strong>为哈希表 key 中的域 field 的值加上增量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">hincrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>increment<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hincrby <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> grade <span class="hljs-number">4</span><br><span class="hljs-number">92</span><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> grade<br><span class="hljs-number">92</span><br></code></pre></td></tr></table></figure><p><strong>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">hsetnx <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>.<br><br>localhost:db0<span class="hljs-operator">&gt;</span> hsetnx <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name io<br><span class="hljs-number">0</span><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br>cz<br></code></pre></td></tr></table></figure><h4 id="4-3-数据结构"><a href="#4-3-数据结构" class="headerlink" title="4.3 数据结构"></a>4.3 数据结构</h4><p>​Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id="5-有序集合-Zset-sorted-set"><a href="#5-有序集合-Zset-sorted-set" class="headerlink" title="5 有序集合(Zset(sorted set))"></a>5 有序集合(Zset(sorted set))</h3><h4 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h4><p>​序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>​不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可重复因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h4><p><strong>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">zadd  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>score1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>score2<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>…<br><br>localhost:db0<span class="hljs-operator">&gt;</span> zadd topn <span class="hljs-number">200</span> java <span class="hljs-number">300</span> python <span class="hljs-number">150</span> c<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>返回有序集 key 中，下标在 start stop之间的元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>stop<span class="hljs-operator">&gt;</span>  [WITHSCORES]  <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</strong></p><p>有序集成员按 score 值递增(从小到大)次序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrangebyscore key min max [withscores] [limit <span class="hljs-keyword">offset</span> count]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrangebyscore topn <span class="hljs-number">200</span> <span class="hljs-number">500</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>有序集成员按 score 值递增(从大到小)次序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrevrangebyscore key max min [withscores] [limit <span class="hljs-keyword">offset</span> count]    <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrevrangebyscore topn <span class="hljs-number">500</span> <span class="hljs-number">200</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p><strong>为元素的score加上增量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">zincrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>increment<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>    <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zincrby topn <span class="hljs-number">50</span> java<br><span class="hljs-number">250</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">250</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>删除该集合下，指定值的元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrem  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrem topc c<br><span class="hljs-number">0</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">250</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>统计该集合，分数区间内的元素个数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>min<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>max<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zcount topn <span class="hljs-number">100</span> <span class="hljs-number">500</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>返回该值在集合中的排名，从0开始</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrank topn python<br><span class="hljs-number">2</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrank topn java<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="5-3-数据结构"><a href="#5-3-数据结构" class="headerlink" title="5.3 数据结构"></a>5.3 数据结构</h4><p>​SortedSet(zset)是Redis提供的一个非常特别的数据结构,一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>set底层使用了两个数据结构<br>（1）<strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）<strong>跳跃表</strong>，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</p><h5 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a><strong>跳跃表（跳表）</strong></h5><p>1 简介</p><pre><code class="hljs">      有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</code></pre><p>2、实例<br>         对比有序链表和跳跃表，从链表中查询出51<br>        （1）有序链表<br>      要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>​<img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516110419403.png?raw=true" alt="image-20240516110419403"></p><p>​（2）跳跃表</p><p>​   <img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516110521024.png?raw=true" alt="image-20240516110521024">  </p><p>​</p><p>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>跳跃表比有序链表效率要高</p><h2 id="reids-操作命令"><a href="#reids-操作命令" class="headerlink" title="reids 操作命令"></a>reids 操作命令</h2><blockquote><p>redis 默认为 16 个库 (在 redis.conf 文件可配置，该文件很重要，后续很多操作都是这个配置文件) redis 默认自动使用 0 号库</p></blockquote><p><strong>沟通命令，查看状态</strong></p><p>连接到客户端之后，输入ping，redis返回pong。表示redis能够正常运行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> ping<br>PONG<br></code></pre></td></tr></table></figure><p><strong>查看当前数据库中key的数量：dbsize</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> dbsize<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>切换库命令：select db</strong></p><p>库的下标从0开始，redis.conf配置中默认16个库。下标0-15</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-number">5</span><br>OK<br>localhost:db5<span class="hljs-operator">&gt;</span> dbsize<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>删除当前数据库的所有数据：flushdb</strong></p><p><strong>退出客户端连接：exit或者quit</strong></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu_for_clash</title>
    <link href="/2024/05/27/tools/Ubuntu_for_clash/"/>
    <url>/2024/05/27/tools/Ubuntu_for_clash/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu配置翻墙软件"><a href="#Ubuntu配置翻墙软件" class="headerlink" title="Ubuntu配置翻墙软件"></a>Ubuntu配置翻墙软件</h1><p><a href="https://opclash.com/article/302.html">参考地址</a></p><h2 id="安装包配置"><a href="#安装包配置" class="headerlink" title="安装包配置"></a><strong>安装包配置</strong></h2><h3 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h3><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> clash &amp;&amp; <span class="hljs-built_in">cd</span> clash<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/Dreamacro/clash/releases/download/v1.18.0/clash-linux-amd64-v1.18.0.gz<br></code></pre></td></tr></table></figure><h3 id="2、解压授权"><a href="#2、解压授权" class="headerlink" title="2、解压授权"></a>2、解压授权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件</span><br>gzip -d clash-linux-amd64-v1.18.0.gz<br><br><span class="hljs-comment"># 给予权限</span><br><span class="hljs-built_in">chmod</span> +x clash-linux-amd64-v1.18.0<br><br><br><span class="hljs-comment"># 查看版本</span><br>./clash-linux-amd64-v1.18.0 -v<br></code></pre></td></tr></table></figure><h3 id="3、启动创建文件夹"><a href="#3、启动创建文件夹" class="headerlink" title="3、启动创建文件夹"></a>3、启动创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 Clash</span><br>./clash-linux-amd64-v1.18.0<br><br><span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">cd</span> ~/.config/clash/<br><br><span class="hljs-comment"># 导入订阅(尝试失败)</span><br>wget -O config.yaml 订阅地址<br><br><span class="hljs-comment"># 手动节点（适用于自建 复制config地址信息）</span><br><br>vim ~/.config/clash/config.yaml<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310271642850.png" alt="image-20231027164226790"></p><h3 id="4、配置环境变量"><a href="#4、配置环境变量" class="headerlink" title="4、配置环境变量"></a>4、配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;export http_proxy=http://127.0.0.1:7890\nexport https_proxy=http://127.0.0.1:7890&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>为防止意外，打开Ubuntu的“设置” 管理，在网络内将“网络代理”的自动改为“手动”</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310271644906.png" alt="image-20231027164429813"></p><h3 id="5、启动clash"><a href="#5、启动clash" class="headerlink" title="5、启动clash"></a>5、启动clash</h3><p>进入clash 二进制文件目录</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./clash-linux-amd64-<span class="hljs-built_in">v1</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>web页面cat </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 节点管理</span><br>http://clash.razord.top/<span class="hljs-comment">#/proxies</span><br><br><span class="hljs-comment">#设置凭证密码</span><br></code></pre></td></tr></table></figure><p>需要后台运行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nohup</span> ./clash-linux-amd64-v1.<span class="hljs-number">18</span>.<span class="hljs-number">0</span> &gt;/dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>停止查看进程id kill</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">super</span>@super:~/work/tools/clash$ ps -ef | grep clash<br><span class="hljs-attribute">super</span>      <span class="hljs-number">63953</span>   <span class="hljs-number">51347</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ./clash-linux-amd64-v1.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">super</span>      <span class="hljs-number">64324</span>   <span class="hljs-number">64035</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span>:<span class="hljs-number">54</span> pts/<span class="hljs-number">4</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto clash<br><br><span class="hljs-attribute">super</span>@super:~/work/tools/clash$ kill <span class="hljs-number">63953</span><br></code></pre></td></tr></table></figure><p>停止不能访问网络将代理设置禁用即可</p><p>脚本proxy.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>status=$1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设 status 参数用于决定是否开启或关闭代理配置</span><br>if [ &quot;$status&quot; = &quot;on&quot; ]; then<br>    echo &quot;开启代理配置&quot;<br>    sed -i &#x27;s/#export http_proxy/export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/#export https_proxy/export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>    echo &quot;启动clash服务&quot;<br>    clash<br>elif [ &quot;$status&quot; = &quot;off&quot; ]; then<br>    echo &quot;关闭代理配置&quot;<br>    sed -i &#x27;s/export http_proxy/#export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/export https_proxy/#export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>else<br>    echo &quot;未知的状态指令，请输入 &#x27;on&#x27; 或 &#x27;off&#x27;&quot;<br>fi<br><br></code></pre></td></tr></table></figure><p>通过参数控制是否配置本地代理环境，每次建议手动开启系统界面的网络配置</p><h2 id="docker-compose-yml-配置"><a href="#docker-compose-yml-配置" class="headerlink" title="docker-compose.yml 配置"></a>docker-compose.yml 配置</h2><h3 id="1、修改config-yaml配置"><a href="#1、修改config-yaml配置" class="headerlink" title="1、修改config.yaml配置"></a>1、修改config.yaml配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim  config.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将host从127.0.0.1 改称0.0.0.0 配合ui获取接口</span><br>external-controller: &#x27;0.0.0.0:9090&#x27;<br></code></pre></td></tr></table></figure><h3 id="2、配置环境变量代理"><a href="#2、配置环境变量代理" class="headerlink" title="2、配置环境变量代理"></a>2、配置环境变量代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh proxy.sh on<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>status=$1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设 status 参数用于决定是否开启或关闭代理配置</span><br>if [ &quot;$status&quot; = &quot;on&quot; ]; then<br>    echo &quot;开启代理配置&quot;<br>    sed -i &#x27;s/#export http_proxy/export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/#export https_proxy/export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>elif [ &quot;$status&quot; = &quot;off&quot; ]; then<br>    echo &quot;关闭代理配置&quot;<br>    sed -i &#x27;s/export http_proxy/#export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/export https_proxy/#export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>else<br>    echo &quot;未知的状态指令，请输入 &#x27;on&#x27; 或 &#x27;off&#x27;&quot;<br>fi<br></code></pre></td></tr></table></figure><p>并且在系统网络里面配置网络代理，手动——http&#x2F;https代理 127.0.0.1:7890   Socks主机 127.0.0.1:7891</p><h3 id="3、启动clash服务"><a href="#3、启动clash服务" class="headerlink" title="3、启动clash服务"></a>3、启动clash服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker-compose</span> <span class="hljs-string">up</span> <span class="hljs-string">-d</span><br><br><br><span class="hljs-comment"># docker-compose.yml</span><br><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.7&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">clash-server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">dreamacro/clash</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">clash</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7890:7890&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7891:7891&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config.yaml:/root/.config/clash/config.yaml</span><br><br>  <span class="hljs-attr">clash-ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">haishanh/yacd</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">clash-ui</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">5080</span><span class="hljs-string">:80</span><br></code></pre></td></tr></table></figure><h3 id="4、访问http-127-0-0-1-5080"><a href="#4、访问http-127-0-0-1-5080" class="headerlink" title="4、访问http://127.0.0.1:5080"></a>4、访问<a href="http://127.0.0.1:5080/">http://127.0.0.1:5080</a></h3><p>配置 API Base URL：<a href="http://localhost:9090/">http://localhost:9090</a>  ,点击add</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora 图床</title>
    <link href="/2024/05/27/tools/github%20%E5%9B%BE%E5%BA%8A/"/>
    <url>/2024/05/27/tools/github%20%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="typora-图床"><a href="#typora-图床" class="headerlink" title="typora 图床"></a>typora 图床</h1><h2 id="1、配置Github"><a href="#1、配置Github" class="headerlink" title="1、配置Github"></a>1、配置Github</h2><p>进入github平台 <a href="https://github.com/">github</a></p><p>登录账号 创建仓库</p><p>配置仓库名 勾选 Add a README file 点击create</p><p>点击头像 创建token 界面划到最下面 点击&lt;&gt;Developer settings 设置token永不过期</p><p>创建完保存好 仅可见一次</p><h2 id="2、配置PicGo"><a href="#2、配置PicGo" class="headerlink" title="2、配置PicGo"></a>2、<strong>配置PicGo</strong></h2><p>官网网站下载 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD">PicGo</a></p><p>安装完成之后配置Github图床配置</p><p>设定仓库名：Github用户名&#x2F;仓库名</p><p>设定分支名：main </p><p>设定Token: 前面保存的token信息</p><p>设定存储路径：img&#x2F;</p><p>设定自定义域名：使用cdn加速域名   </p><p><a href="https://cdn.staticaly.com/gh/gondmhd/blogImage@main">https://cdn.staticaly.com/gh/gondmhd/blogImage@main</a></p><h2 id="3、配置typora"><a href="#3、配置typora" class="headerlink" title="3、配置typora"></a>3、配置typora</h2><p>文件-偏好设置-图像设置图床配置 </p><p>外观 自定义字段大小</p><h3 id="3-1-typora颜色样式"><a href="#3-1-typora颜色样式" class="headerlink" title="3.1 typora颜色样式"></a>3.1 typora颜色样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;cornflowerblue&quot;</span>&gt;</span>蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;orange&quot;</span>&gt;</span>橘色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;<font color="cornflowerblue">蓝色</font>&#x3D;&#x3D;<br>&#x3D;&#x3D;<font color="orange">橘色</font>&#x3D;&#x3D;<br>&#x3D;&#x3D;<font color="red">红色</font>&#x3D;&#x3D;</p><h3 id="3-2-代码块Mac风格三个圆点"><a href="#3-2-代码块Mac风格三个圆点" class="headerlink" title="3.2 代码块Mac风格三个圆点"></a>3.2 代码块Mac风格三个圆点</h3><p><strong>偏好设置-外观-打开主题-找到在使用主题css-修改代码块样式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 代码块主题 */</span><br><span class="hljs-comment">/* 顶部 */</span><br><span class="hljs-selector-class">.md-fences</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#c5c8c6</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#21252b</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> / <span class="hljs-number">40%</span>);<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">font-family</span>: monospace, <span class="hljs-string">&#x27;PingFang SC&#x27;</span>, <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.md-fences</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span>;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭所有typora窗口 重新打开 即可获取小圆点</p><h2 id="4、配置Pandoc"><a href="#4、配置Pandoc" class="headerlink" title="4、配置Pandoc"></a>4、配置Pandoc</h2><p><a href="https://github.com/jgm/pandoc/releases/tag/3.1.6.1">Pandoc下载地址</a></p><p>将解压安装路径配置window环境变量path</p><p>pandoc –version# 检查是否生效</p><p>重启Typora</p><h2 id="5、ubuntu情况下-picgo-存在问题"><a href="#5、ubuntu情况下-picgo-存在问题" class="headerlink" title="5、ubuntu情况下 picgo 存在问题"></a>5、ubuntu情况下 picgo 存在问题</h2><blockquote><p>手动方案</p></blockquote><p><strong>5.1 git clone 图片仓库</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:gondmhd/XXXX.git<br></code></pre></td></tr></table></figure><p><strong>5.2 typora保存图片到本地仓库路径下</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240508164956733.png?raw=true" alt="image-20240508164956733"></p><p><strong>5.3 使用typora正常编辑保存图片</strong></p><p><strong>5.4 git push 图片到仓库 复制图片链接到md文档</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240508165232708.png?raw=true" alt="image-20240508165232708"></p><p><strong>5.5 将图片路径修改</strong></p><p>修改成复制的网络地址(也可修改路径拼接后面 ?raw&#x3D;true)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">https://github.com/gondmhd/blogImage/blob/main/img/image-20240508165232708.png?raw=true<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx集成keycloak</title>
    <link href="/2024/05/27/linux/nginx%20%E6%8E%A5%E5%85%A5keycloak%20sso%E5%B9%B3%E5%8F%B0/"/>
    <url>/2024/05/27/linux/nginx%20%E6%8E%A5%E5%85%A5keycloak%20sso%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx-接入keycloak-sso平台"><a href="#nginx-接入keycloak-sso平台" class="headerlink" title="nginx 接入keycloak sso平台"></a>nginx 接入keycloak sso平台</h1><blockquote><p>背景</p></blockquote><p>有许多用于验证 API 调用的选项，但是，OAuth 2.0 身份验证机制是主要使用的一种。在这里，OAuth 2.0 访问令牌是从客户端传递到 API 服务器的身份验证凭据，通常作为 HTTP 标头携带。</p><p>Keycloak支持OIDC（OAuth 2.0的扩展），并在对客户端进行身份验证时充当IdP。</p><p>使用 IdP 验证访问令牌的标准方法称为<em>令牌自检</em>。Nginx 充当 OAuth 2.0 <a href="https://en.wikipedia.org/wiki/Relying_party">信赖方</a>，将访问令牌发送到 IdP 进行验证，即令牌自检，并且仅代理通过验证过程的请求 。</p><h2 id="为什么要在Nginx执行令牌验证"><a href="#为什么要在Nginx执行令牌验证" class="headerlink" title="为什么要在Nginx执行令牌验证"></a>为什么要在Nginx执行令牌验证</h2><p>在每个后端服务或应用程序上执行验证会导致大量重复代码和不必要的处理。需要考虑各种错误条件和边缘情况，在每个后端服务中这样做会导致实现不一致，从而导致不可预测的用户体验。</p><p>为了避免代码重复和由此产生的问题，我们可以使用 Nginx 代表后端服务验证访问令牌。</p><h2 id="自定义Nginx"><a href="#自定义Nginx" class="headerlink" title="自定义Nginx"></a>自定义Nginx</h2><p>要将 Nginx 与 Keycloak 集成，我们需要 Lua 依赖。我们没有向Nginx添加依赖项，而是使用Openresty，这是一个建立在Nginx之上的Web服务器。</p><p>以下是用于构建 Nginx 映像所需的内容。<code>Dockerfile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM openresty/openresty:alpine-fat<br> <br>RUN <span class="hljs-built_in">mkdir</span> /var/log/nginx<br> <br>RUN apk add --no-cache openssl-dev<br>RUN apk add --no-cache git<br>RUN apk add --no-cache gcc<br>RUN luarocks install lua-resty-openidc<br> <br>ENTRYPOINT [<span class="hljs-string">&quot;/usr/local/openresty/nginx/sbin/nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]<br>EXPOSE 80<br></code></pre></td></tr></table></figure><p>在下面的配置文件中，我们保护了两个后端应用程序。<code>nginx.conf</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs json">  server <span class="hljs-punctuation">&#123;</span><br>       listen   <span class="hljs-number">8888</span> ssl;<br>       root     /opt/nginx/html;<br>       #ssl on;<br>       ssl_certificate /etc/nginx/certs/cert.pem;<br>       ssl_certificate_key /etc/nginx/certs/key.pem;<br>       access_by_lua &#x27;<br>         local opts = <span class="hljs-punctuation">&#123;</span><br>           redirect_uri_path = <span class="hljs-string">&quot;/redirect_uri&quot;</span><span class="hljs-punctuation">,</span><br>           accept_none_alg = <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>           discovery = <span class="hljs-string">&quot;http://192.168.0.179:3333/auth/realms/test/.well-known/openid-configuration&quot;</span><span class="hljs-punctuation">,</span><br>           client_id = <span class="hljs-string">&quot;nginx&quot;</span><span class="hljs-punctuation">,</span><br>           client_secret = <span class="hljs-string">&quot;j6KPHwwNW5l5wGVrMFeIEkyZzj6Fh56I&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_uri_scheme = <span class="hljs-string">&quot;https&quot;</span><span class="hljs-punctuation">,</span>  #重定向协议<br>           logout_path = <span class="hljs-string">&quot;/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_uri = <span class="hljs-string">&quot;http://192.168.0.135:3333/auth/realms/test/protocol/openid-connect/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_with_id_token_hint = <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>           session_contents = <span class="hljs-punctuation">&#123;</span>id_token=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><br>         -- call introspect for OAuth <span class="hljs-number">2.0</span> Bearer Access Token validation<br>         local res<span class="hljs-punctuation">,</span> err = require(<span class="hljs-string">&quot;resty.openidc&quot;</span>).authenticate(opts)<br>         if err then<br>           ngx.status = <span class="hljs-number">403</span><br>           ngx.say(err)<br>           ngx.exit(ngx.HTTP_FORBIDDEN)<br>         end<br>      &#x27;;<br> <br>      # I disabled caching so the browser won&#x27;t cache the site.<br>      expires           <span class="hljs-number">0</span>;<br>      add_header        Cache-Control private;<br>      <br>      location / <span class="hljs-punctuation">&#123;</span><br>          proxy_pass    https<span class="hljs-punctuation">:</span><span class="hljs-comment">//nginx-proxy;# nginx转发的地址</span><br>          proxy_set_header    X-Forwarded-For         $remote_addr;<br>          proxy_set_header Host arkime.malcolm.local;<br>          #proxy_set_header http_auth_http_user $authenticated_user;<br>          proxy_set_header Authorization <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-punctuation">&#125;</span><br>      <br>      # redirect server error pages to the static page /<span class="hljs-number">40</span>x.html<br>      #<br>      error_page <span class="hljs-number">404</span> /<span class="hljs-number">404.</span>html;<br>          location = /<span class="hljs-number">40</span>x.html <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-punctuation">&#125;</span><br> <br>      # redirect server error pages to the static page /<span class="hljs-number">50</span>x.html<br>      #<br>      error_page <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /<span class="hljs-number">50</span>x.html;<br>          location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>            root /usr/share/nginx/html;<br>      <span class="hljs-punctuation">&#125;</span><br><br>      <br><span class="hljs-punctuation">&#125;</span><br><br>server <span class="hljs-punctuation">&#123;</span><br>       listen   <span class="hljs-number">8889</span> ;<br>       root     /opt/nginx/html;<br>       #ssl on;<br>       ssl_certificate /etc/nginx/certs/cert.pem;<br>       ssl_certificate_key /etc/nginx/certs/key.pem;<br>       access_by_lua &#x27;<br>         local opts = <span class="hljs-punctuation">&#123;</span><br>           redirect_uri_path = <span class="hljs-string">&quot;/redirect_uri&quot;</span><span class="hljs-punctuation">,</span><br>           accept_none_alg = <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>           discovery = <span class="hljs-string">&quot;http://192.168.0.179:3333/auth/realms/test/.well-known/openid-configuration&quot;</span><span class="hljs-punctuation">,</span><br>           client_id = <span class="hljs-string">&quot;nginx&quot;</span><span class="hljs-punctuation">,</span><br>           client_secret = <span class="hljs-string">&quot;j6KPHwwNW5l5wGVrMFeIEkyZzj6Fh56I&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_uri_scheme = <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>           logout_path = <span class="hljs-string">&quot;/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_uri = <span class="hljs-string">&quot;http://192.168.0.135:3333/auth/realms/test/protocol/openid-connect/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_with_id_token_hint = <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>           session_contents = <span class="hljs-punctuation">&#123;</span>id_token=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><br>         -- call introspect for OAuth <span class="hljs-number">2.0</span> Bearer Access Token validation<br>         local res<span class="hljs-punctuation">,</span> err = require(<span class="hljs-string">&quot;resty.openidc&quot;</span>).authenticate(opts)<br>         if err then<br>           ngx.status = <span class="hljs-number">403</span><br>           ngx.say(err)<br>           ngx.exit(ngx.HTTP_FORBIDDEN)<br>         end<br>      &#x27;;<br> <br>      # I disabled caching so the browser won&#x27;t cache the site.<br>      expires           <span class="hljs-number">0</span>;<br>      add_header        Cache-Control private;<br>      <br>      location / <span class="hljs-punctuation">&#123;</span><br>          proxy_pass    https<span class="hljs-punctuation">:</span><span class="hljs-comment">//nginx-proxy;    # nginx转发的地址</span><br>          proxy_set_header    X-Forwarded-For         $remote_addr;<br>          proxy_set_header Host arkime.malcolm.local;<br>          #proxy_set_header http_auth_http_user $authenticated_user;<br>          proxy_set_header Authorization <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-punctuation">&#125;</span><br>      <br>      # redirect server error pages to the static page /<span class="hljs-number">40</span>x.html<br>      #<br>      error_page <span class="hljs-number">404</span> /<span class="hljs-number">404.</span>html;<br>          location = /<span class="hljs-number">40</span>x.html <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-punctuation">&#125;</span><br> <br>      # redirect server error pages to the static page /<span class="hljs-number">50</span>x.html<br>      #<br>      error_page <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /<span class="hljs-number">50</span>x.html;<br>          location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>            root /usr/share/nginx/html;<br>      <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>在启动 Docker 容器时，我们可以访问 Keycloak 管理门户，网址为 。登录后，我们创建一个新领域以添加客户端。<code>http://localhost:3333``myrealm</code></p><p>创建客户端 <code>nginx</code>  我们需要将选项卡中的密钥添加到 Nginx 配置文件中。<code>Credentials</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Access Type :</span> <span class="hljs-string">confidential</span><br><span class="hljs-attr">Valid Redirect URIs:</span> <span class="hljs-string">*</span> <span class="hljs-comment"># 重定向匹配所有</span><br><span class="hljs-string">Web</span> <span class="hljs-string">Origins：*</span> <span class="hljs-comment"># 重定向匹配所有</span><br></code></pre></td></tr></table></figure><p>创建客户端用户密码（用户密码跟随领域）</p><p>设置密码</p><h2 id="使用docker-compose部署环境"><a href="#使用docker-compose部署环境" class="headerlink" title="使用docker-compose部署环境"></a>使用docker-compose部署环境</h2><p>我们使用 Postgres 作为 keycloak 的后端数据库来存储客户端设置。Nginx 容器用于表示演示应用程序，以及 .<code>app_1``app_2</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml">version: &#x27;3.7&#x27;<br>x-tz-variables: &amp;tz-variables<br>  TZ : &#x27;Asia/Shanghai&#x27;<br>networks:<br>    mynetwork:<br>        name: mynetwork<br> <br>volumes:<br>    postgres_data:<br>    <br>services:<br>  postgres:<br>    image: postgres<br>    container_name: postgres<br>    volumes:<br>      - postgres_data:/var/lib/postgresql/data<br>      - ./keycloak_nginx/keycloak.sql:/docker-entrypoint-initdb.d/keycloak.sql:rw<br>    environment: <br>      POSTGRES_DB: keycloak<br>      POSTGRES_USER: keycloak<br>      POSTGRES_PASSWORD: keycloak<br>    ports:<br>      - 5433:5432<br>    networks: <br>      - default<br>  keycloak:<br>    image: super/keycloak:16.1.1<br>    container_name: keycloak<br>    environment:<br>      DB_VENDOR: POSTGRES<br>      DB_ADDR: postgres<br>      DB_DATABSE: keycloak<br>      DB_USER: keycloak<br>      DB_SCHEMA: public<br>      DB_PASSWORD: keycloak<br>      KEYCLOAK_USER: admin<br>      KEYCLOAK_PASSWORD: keycloak            <br>    ports:<br>      - 3333:8080<br>    depends_on:<br>      - postgres<br>    networks:<br>      - default<br>  keycloak_nginx:<br>    build:<br>      context: ./keycloak_nginx<br>      dockerfile: nginx.dockerfile<br>    image: nginx:keycloak<br>    container_name: keycloak_nginx<br>    #environment:<br>    #  KEYCLOAK_IP: 192.168.0.71<br>    ports:<br>      - 8888:8888 <br>      - 8889:8889           <br>    networks:<br>      - default<br>    volumes: <br>      - ./keycloak_nginx/nginx.conf:/etc/nginx/conf.d/default.conf<br>      - ./keycloak_nginx/certs:/etc/nginx/certs<br></code></pre></td></tr></table></figure><p>一旦一切启动并运行，任何访问端口上的应用程序的尝试都应该受到保护，用户将被Keycloak重定向到登录页面。成功登录后，用户将能够访问请求的资源</p><blockquote><p>此处nginx配置了http\https 模式，因iframe 内嵌网页无法验证信任ssl证书 ，使用nginx充当http反向代理</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile构建技巧</title>
    <link href="/2024/05/27/docker/Dockfile%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/05/27/docker/Dockfile%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile构建技巧"><a href="#Dockerfile构建技巧" class="headerlink" title="Dockerfile构建技巧"></a>Dockerfile构建技巧</h1><h2 id="1、不使用多阶段构建"><a href="#1、不使用多阶段构建" class="headerlink" title="1、不使用多阶段构建"></a>1、不使用多阶段构建</h2><p>我们知道在Dockerfile 中没新增一个指令都会在镜像中生产新的层，一个高校的Dockerfile应该在继续下一层之前清楚之前所有不需要的资源 </p><p>不使用多阶段构建时，<strong>我们通常会创建两个dockerfile文件，一个用于开发及编程应用，另一个用于构建精简的生成镜像，</strong>这样能比较大限度的减小镜像的大小。</p><p>我们以一个go应用来看看，首先创建一个dockerfile,构建这个镜像的主要目的就是编译我们的应用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-comment">#go编译</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build  -o myapp app.go</span><br></code></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost dockerfiles]<span class="hljs-comment"># docker build -t builder_app:v1 .</span><br>Sending build context to Docker daemon  3.072kB<br>Step 1/4 : FROM golang:1.16<br> ---&gt; 019c7b2e3cb8<br>Step 2/4 : WORKDIR /go/src<br> ---&gt; Using cache<br> ---&gt; 15362720e897<br>Step 3/4 : COPY app.go ./<br> ---&gt; Using cache<br> ---&gt; 8f14ac97a68a<br>Step 4/4 : RUN go build  -o myapp app.go<br> ---&gt; Running <span class="hljs-keyword">in</span> 4368cc4617a7<br>Removing intermediate container 4368cc4617a7<br> ---&gt; 631f67587803<br>Successfully built 631f67587803<br>Successfully tagged builder_app:v1<br></code></pre></td></tr></table></figure><p>这样在这个镜像中就包含了我们编译后的应用myapp，现在我们可以创建容器将myapp拷贝到宿主机等待后续使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker create --name builder builder_app:v1# 创建一个新的容器，但并不启动它 --name builder  builder_app:v1：这是指定要创建的容器所使用的镜像名称和标签</span><br>fafc1cf7ffa42e06d19430b807d24eafe0bf731fc45ff0ecf31ada5a6075f1d5<br><span class="hljs-comment"># docker cp builder:/go/src/myapp ./ # 从一个容器中复制文件或目录到本地主机。</span><br></code></pre></td></tr></table></figure><p>我们有了应用，下一步就是构建生产镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM scratch<br>WORKDIR /server<br>COPY myapp ./<br>CMD [<span class="hljs-string">&quot;./myapp&quot;</span>]<br></code></pre></td></tr></table></figure><p>由于此时我们不需要其他依赖环境，所以我们采用scratch这个空镜像，不仅可以减小容器尺寸，还可以提高安全性。</p><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker build  --no-cache -t server_app:v1 .   #  --no-cache 指示Docker在构建过程中不使用任何缓存。通常，Docker会缓存之前步骤的结果来加速连续构建过程，但是使用这个标志会强制Docker忽略所有缓存，从头开始构建每个层。</span><br></code></pre></td></tr></table></figure><p>我们看一次构建的两个镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker images </span><br>REPOSITORY            TAG       IMAGE ID       CREATED          SIZE<br>server_app            v1        6ebc0833cad0   6 minutes ago    1.94MB<br>builder_app           v1        801f0b615004   23 minutes ago   921MB<br></code></pre></td></tr></table></figure><p><strong>显然在不使用多阶段构建时，我们也可以构建出生产镜像，但是我们需要维护两个dockerfile，需要将app遗留到本地，并且带来了更多存储空间开销。在使用多阶段构建时能比较好的解决以上问题。</strong></p><h2 id="2、使用多阶段构建"><a href="#2、使用多阶段构建" class="headerlink" title="2、使用多阶段构建"></a>2、使用多阶段构建</h2><p>在一个Dockfile 中使用多个FROM 指令，每个FROM 都可以使用不同的基镜像，并且每条指令都将开始新阶段构建。在多阶段构建中，我们可以将资源从一个阶段复制到另一个阶段，在最终镜像中只保留我们所需要的内容。</p><p>我们将上面实例的两个Dockfile合并如下为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=0 /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># docker build --no-cache  -t server_app:v2 .</span><br></code></pre></td></tr></table></figure><p><strong>查看构建好的镜像</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># docker images</span><br><span class="hljs-attribute">REPOSITORY</span>            TAG       IMAGE ID       CREATED              SIZE<br><span class="hljs-attribute">server_app</span>            v2        <span class="hljs-number">20225</span>cb1ea6b   <span class="hljs-number">12</span> seconds ago       <span class="hljs-number">1</span>.<span class="hljs-number">94</span>MB<br></code></pre></td></tr></table></figure><p>这样我们无需创建额外镜像，以更简单的方式构建出了同样微小的目标镜像。可以看到在多阶段构建dockerfile中最关键的是<code>COPY --from=0 /go/src/myapp ./</code> 通过<code>--from=0</code>指定我们资源来源，这里的0即是指第一阶段。</p><p><strong>命令构建阶段</strong></p><p>默认情况下构建阶段没有名称，我们可以通过整数0~N来引用，即第一个from从0开始。其实我们还可以在<code>FROM</code>指令中添加<code>AS &lt;NAME&gt;</code> 来命名构建阶段，接着在COPY指令中通过<code>&lt;NAME&gt;</code>引用。我们对上面dockerfile修改如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1命名为builder</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span> as builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-comment">#通过名称引用</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>只构建某个接蹲</strong></p><p>构建镜像时，不一定需要构建整个 Dockerfile，我们可以通过<code>--target</code>参数指定某个目标阶段构建，比如我们开发阶段我们只构建builder阶段进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#docker build --target builder -t builder_app:v2 .</span><br></code></pre></td></tr></table></figure><p><strong>使用外部镜像</strong></p><p>使用多阶段构建时，我们局限于从之前在 Dockerfile 中创建的阶段进行复制。还可以使用<code>COPY --from</code>指令从单独的镜像复制，如本地镜像名称、本地或 Dockerhub上可用的标签或标签 ID。Docker 客户端在必要时会拉取需要的镜像到本地。</p><p><strong>从上一阶段创建新的阶段</strong></p><p>我们可以通过FROM指令来引用上一阶段作为新阶段的开始</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1命名为builder</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span> as builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> builder as builder_ex<br><span class="hljs-keyword">ADD</span><span class="language-bash"> dest.tar ./</span><br>...<br><br></code></pre></td></tr></table></figure><p><strong>使用本地环境构建镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=0 /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>使用本地脚本控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 根据是否有阶段参数执行构建</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$#</span>&quot;</span> -gt 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># 如果有参数，则执行带有 --cache-from 的构建，假定参数是期望的构建阶段名（这里假设为 builder）</span><br>    docker build --cache-from=builder_app:v3 --target final -t work:dev .<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># 没有参数，执行完整的构建流程</span><br>    <span class="hljs-comment"># 先构建 builder 阶段</span><br>    docker build --target builder -t builder_app:v3 .<br>    <span class="hljs-comment"># 使用 builder 镜像作为缓存来源，构建最终镜像</span><br>    docker build --cache-from=builder_app:v3 --target final -t work:dev .<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
