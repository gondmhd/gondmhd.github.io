<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>序列化之坑</title>
    <link href="/2024/06/07/go/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%9D%91/"/>
    <url>/2024/06/07/go/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="encoding-json"><a href="#encoding-json" class="headerlink" title="encoding&#x2F;json"></a>encoding&#x2F;json</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>JSON 作为一种数据格式，它的核心动作就是两个：<strong>序列化，反序列化</strong>。</p><p><strong>序列化就是把一个 Go 对象转化为 JSON 格式的字符串（或字节序列，这点区别不重要），反序列化则相反，把 JSON 格式的数据转化成 Go 对象</strong>。</p><p>这里说的对象是一个广义的概念，不单指结构体对象，包括 slice、map 类型数据也支持 JSON 的序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">uint</span><br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 序列化 </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        Age:  <span class="hljs-number">18</span>,<br>    &#125;<br>    output, err := json.Marshal(p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;Age&quot;:18&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-坑"><a href="#2-坑" class="headerlink" title="2 坑"></a>2 坑</h3><h4 id="2-1-公开（public）成员字段"><a href="#2-1-公开（public）成员字段" class="headerlink" title="2.1 公开（public）成员字段"></a>2.1 公开（public）成员字段</h4><p><strong>如果我们用结构体来操作 JSON，那么结构体的成员字段必须为公开成员，也就是首字母大写，私有成员无法被解析</strong>。</p><p>列子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">uint</span><br>    Name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        age:  <span class="hljs-number">18</span>,<br>    &#125;<br>    output, err := json.Marshal(p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPerson</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;age&quot;:18&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output Marshal:</span><br>&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;<br><br><span class="hljs-comment">// Output Unmarshal:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce age:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>age</code> 被设为了私有变量，于是序列化后的 JSON 串中没有 <code>age</code> 这个字段了。同理，从一个 JSON 字符串反序列化为 <code>Person</code> 后，也无法正确读取到 <code>age</code> 的值。</p><h4 id="2-2-少用-map"><a href="#2-2-少用-map" class="headerlink" title="2.2 少用 map"></a>2.2 少用 map</h4><p>JSON 不仅能操作结构体，还能操作 slice、map 等类型的数据。slice 比较特殊，但 map 和结构体表现在 JSON 格式下其实是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ID&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bruce&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这种情况下，除非有特情况或需求，否则，少用 map。因为 map 会带来额外的开销，额外的代码量，以及额外的维护成本。</p><p>首先，像上面的 Person 例子，由于 ID 和 Name 是不同类型，因此我们如果要用 map 反序列化这个 JSON 数据，就只能申明一个 <code>map[string]any</code> 类型的 map。<code>any</code>，也就是 <code>interface&#123;&#125;</code> ，就意味着我们如果要单独使用 Name 或 ID 时，需要用类型断言来转换类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any<br><span class="hljs-comment">// ...反序列化 JSON 数据，代码忽略...</span><br><span class="hljs-comment">// 获取成员</span><br>name, ok := m[<span class="hljs-string">&quot;Name&quot;</span>].(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>类型断言本身就是一个额外的步骤，为防止 panic，我们还需要判断第二个参数 ok，这无疑增加了开发工作量以及代码负担。</p><p>另外，map 本身对数据就是无约束的。结构体中我们能够预先定义各成员字段以及类型，但 map 不行。这就意味着，我们只能通过文档或注释或代码本身来理解这个 map 里到底装了些什么东西。并且，结构体可以限制 JSON 数据的 key 和 value 类型不被乱改，而 map 同样无法约束 JSON 的变更，只能通过业务逻辑代码来检测。这其中的工作量和后期维护成本，想想就知道会有多少。</p><h4 id="2-3-小心结构体组合"><a href="#2-3-小心结构体组合" class="headerlink" title="2.3 小心结构体组合"></a>2.3 小心结构体组合</h4><p>Go 虽然面向对象，但没有 <code>class</code> ，只有结构体，并且结构体没有继承。因此 Go 采用了一种组合的方式来复用不同的结构体。很多时候，这种组合给我们带来了极大的便利，我们可以像操作结构体自己的成员一样去操作组合的其他结构体成员，就像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs css">type Person struct &#123;<br>    ID   uint<br>    Name string<br>    <span class="hljs-selector-tag">address</span><br>&#125;<br><br>type <span class="hljs-selector-tag">address</span> struct &#123;<br>    <span class="hljs-selector-tag">Code</span>   int<br>    Street string<br>&#125;<br><br>func (<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">address</span>) PrintAddr() &#123;<br>    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Code</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Street</span>)<br>&#125;<br><br>func Group() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        address: address&#123;<br>            <span class="hljs-selector-tag">Code</span>:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    // 用 <span class="hljs-selector-tag">p</span> 直接访问 <span class="hljs-selector-tag">Address</span> 的成员和方法<br>    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Code</span>, <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Street</span>)<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.PrintAddr</span>()<br>&#125;<br><br>// Output<br><span class="hljs-number">100</span> <span class="hljs-selector-tag">Main</span> St<br><span class="hljs-number">100</span> <span class="hljs-selector-tag">Main</span> St<br></code></pre></td></tr></table></figure><p>但当我们将组合融入到 JSON 的使用当中时，这里会有一个小坑需要注意。来看下面这段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 这里用的还是前面的结构体，就不重复写了。error 也不捕获了，节省篇幅。</span><br><br>func <span class="hljs-built_in">MarshalPerson</span>() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        <span class="hljs-selector-tag">address</span>: address&#123;<br>            Code:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    <span class="hljs-comment">// 用 MarshalIndent 打印更好看点</span><br>    output, _ := json<span class="hljs-selector-class">.MarshalIndent</span>(<span class="hljs-selector-tag">p</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-built_in">string</span>(output))<br>&#125;<br><br>func <span class="hljs-built_in">UnmarshalPerson</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:&#123;<span class="hljs-string">&quot;Code&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;Street&quot;</span>:<span class="hljs-string">&quot;Main St&quot;</span>&#125;&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output MarshalPerson:</span><br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Ouptput UnmarshalPerson:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce <span class="hljs-selector-tag">address</span>:&#123;Code:<span class="hljs-number">0</span> Street:&#125;&#125;<br></code></pre></td></tr></table></figure><p>但当我们将组合融入到 JSON 的使用当中时，这里会有一个小坑需要注意。来看下面这段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 这里用的还是前面的结构体，就不重复写了。error 也不捕获了，节省篇幅。</span><br><br>func <span class="hljs-built_in">MarshalPerson</span>() &#123;<br>    <span class="hljs-selector-tag">p</span> := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        <span class="hljs-selector-tag">address</span>: address&#123;<br>            Code:   <span class="hljs-number">100</span>,<br>            Street: <span class="hljs-string">&quot;Main St&quot;</span>,<br>        &#125;,<br>    &#125;<br>    <span class="hljs-comment">// 用 MarshalIndent 打印更好看点</span><br>    output, _ := json<span class="hljs-selector-class">.MarshalIndent</span>(<span class="hljs-selector-tag">p</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-built_in">string</span>(output))<br>&#125;<br><br>func <span class="hljs-built_in">UnmarshalPerson</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>:&#123;<span class="hljs-string">&quot;Code&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;Street&quot;</span>:<span class="hljs-string">&quot;Main St&quot;</span>&#125;&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output MarshalPerson:</span><br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Ouptput UnmarshalPerson:</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce <span class="hljs-selector-tag">address</span>:&#123;Code:<span class="hljs-number">0</span> Street:&#125;&#125;<br></code></pre></td></tr></table></figure><p>先看 <code>MarshalPerson</code> 函数。这里先申明了一个 Person 对象，然后用 <code>MarshalIndent</code> 美化一下序列化结果，并打印。从打印的结果中我们看到，整个 Person 对象被<strong>铺平</strong>了。对于 Person 结构体来说，尽管用了组合，但它看上去还是有一个 <code>address</code> 成员字段。所以有时候我们会想当然地以为 Person 序列化后的 JSON 长这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 想象中的 JSON 序列化结果<br>&#123;<br>  <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-string">&quot;address&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-string">&quot;Street&quot;</span>: <span class="hljs-string">&quot;Main St&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上并没有，它被铺平了。这一点倒是比较符合前面我们直接通过 Person 访问 address 成员时的感觉，即，address 的成员似乎直接变成了 Person 的成员。这是一个需要注意的地方，组合会让序列化后的 JSON 结果铺平。</p><p>另一个稍微有些反直觉的点是，address 结构体是一个私有结构体，而私有成员似乎不应该被序列化？没错，这就是组合这种形式有一点不太好的地方了：<strong>它会暴露私有组合对象的公共成员</strong>。所以这里就要注意了，<strong>这种暴露有时候是无意的，但它可能会造成不必要的数据泄漏</strong>。</p><p>然后是 <code>UnmarshalPerson</code> 函数。有了上一个函数的解读，这个就好理解了，其实还是组合后 JSON 结果被铺平的问题。因此我们如果需要反序列化回 Person 时，也需要一个铺平后的 JSON 数据。</p><p>对 Go 的使用过程中，遇到这类需要转化成 JSON 的结构体时，通常不太会用组合，除非有一些特殊的情况。毕竟它太容易带来上面提及的问题了。并且，由于 JSON 是平铺的而结构体定义上没有平铺，一旦这个结构体组被定义的越来越复杂，那么它和原始铺平的 JSON 数据就越难去直观对比了，这样会使这个代码的可读性将直线下降。</p><p>如果没有特殊需求的话（譬如原始 JSON 数据就是平铺的，并且存在多个结构体有重复字段需要复用），从我个人的角度建议，尽量这么写：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Person</span> struct &#123;<br>    <span class="hljs-type">ID</span>      int<br>    <span class="hljs-type">Name</span>    string<br>    <span class="hljs-type">Address</span> address<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-部分成员反序列化时需要小心"><a href="#2-4-部分成员反序列化时需要小心" class="headerlink" title="2.4 部分成员反序列化时需要小心"></a>2.4 部分成员反序列化时需要小心</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>    ID   uint<br>    Name string<br>&#125;<br><br><span class="hljs-comment">// PartUpdateIssue 模拟了用同一个结构体解析两个不同的 JSON 字符串的场景</span><br>func <span class="hljs-built_in">PartUpdateIssue</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    <span class="hljs-comment">// 第一个数据有 ID 字段，且不为 0</span><br>    str := `&#123;<span class="hljs-string">&quot;ID&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;`<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>    <span class="hljs-comment">// 第二个数据没有 ID 字段，再次用 p 反序列化，会保留上次的值</span><br>    str = `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Jim&quot;</span>&#125;`<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    <span class="hljs-comment">// 注意输出的 ID 仍然是 1</span><br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce&#125;<br>&#123;ID:<span class="hljs-number">1</span> Name:Jim&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们用同一个结构体去反复反序列化不同的 JSON 数据时，一旦某个 JSON 数据的值只包含部分成员字段的，那么未被覆盖到的成员就会残留上一次反序列化的值</strong>。其实就是个脏数据污染的问题。</p><p>解决方案也很简单：<strong>每次反序列化 JSON 时，都使用全新的结构体对象来加载数据</strong>。</p><h4 id="2-5-处理指针成员"><a href="#2-5-处理指针成员" class="headerlink" title="2.5 处理指针成员"></a>2.5 处理指针成员</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID      <span class="hljs-type">uint</span><br>    Name    <span class="hljs-type">string</span><br>    Address *Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnmarshalPtr</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;&#125;`</span><br>    <span class="hljs-keyword">var</span> p Person<br>    _ = json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;p)<br>    fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br>    <span class="hljs-comment">// 下面这行会 panic</span><br>    <span class="hljs-comment">// fmt.Printf(&quot;%+v\n&quot;, p.Address.Street)</span><br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;ID:<span class="hljs-number">1</span> Name:Bruce Address:&lt;<span class="hljs-literal">nil</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>我们将 <code>Address</code> 成员定义为一个指针，此时我们去反序列化一段不包含 <code>Address</code> 的 JSON 数据时，这个指针成员由于没有对应的数据，会被置为 nil。<code>encoding/json</code> 不会为该成员创建一个空的 <code>&amp;Address</code> 。这个时候如果我们直接调用 <code>p.Address.xxx</code> ，程序就会因为 <code>p.Address</code> 为空而 panic。</p><p><strong>如果我们的结构体成员存在指针时，使用前请记得判断指针是否为空</strong>。</p><p>在创建一个有指针字段的结构体时，指针字段的赋值也会相对麻烦一些：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    ID   <span class="hljs-type">int</span>    <br>    Name <span class="hljs-type">string</span> <br>    Age  *<span class="hljs-type">int</span>   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        ID:   <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        Age:  <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>),<br>    &#125;<br>    *p.Age = <span class="hljs-number">20</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-零值造成的混淆"><a href="#2-6-零值造成的混淆" class="headerlink" title="2.6 零值造成的混淆"></a>2.6 零值造成的混淆</h4><p>所谓零值，是 Golang 中变量的一个特性，我们可以简单理解为默认值。即如果我们没有显式地为某个变量赋值，则 Golang 为为其赋一个默认值。譬如前文的例子中我们已经看到的，int 默认值 0，string 空字符串，指针零值为 nil 等等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>    Name        string<br>    ChildrenCnt int<br>&#125;<br><br>func <span class="hljs-built_in">ZeroValueConfusion</span>() &#123;<br>    str := `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Bruce&quot;</span>&#125;`<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span> Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str), &amp;p)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p)<br><br>    str2 := `&#123;<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Jim&quot;</span>,<span class="hljs-string">&quot;ChildrenCnt&quot;</span>:<span class="hljs-number">0</span>&#125;`<br>    <span class="hljs-selector-tag">var</span> p2 Person<br>    _ = json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str2), &amp;p2)<br>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%+v\n&quot;</span>, p2)<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;Name:Bruce ChildrenCnt:<span class="hljs-number">0</span>&#125;<br>&#123;Name:Jim ChildrenCnt:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>Person</code> 结构体中添加了一个 <code>ChildrenCnt</code> 字段，用于统计该人物的子女数量。由于零值的存在，当 <code>p</code> 加载的 JSON 数据里没有 <code>ChildrenCnt</code> 数据时，该字段被赋予 0。此时就产生了误解：<strong>我们无法将这种数据缺失的对象，与子女数确实为 0 的对象区分开</strong>。如例子里的 Bruce 和 Jim，一个是数据缺失导致的子女数为 0，另一个是本来就为 0。而实际上 Bruce 的子女数量应该是“未知“，我们如果真当作 0 处理，在业务上可能就会产生问题。</p><p><strong>解决办法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name        <span class="hljs-type">string</span><br>    ChildrenCnt *<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;Name:Bruce ChildrenCnt:&lt;<span class="hljs-literal">nil</span>&gt;&#125;<br>&#123;Name:Jim ChildrenCnt:<span class="hljs-number">0xc0000124c8</span>&#125;<br></code></pre></td></tr></table></figure><p>区别产生了。Bruce 没有数据，所以 <code>ChildrenCnt</code> 是个 nil，而 Jim 则是一个非空指针。此时就能明确地知晓，Bruce 的子女数量是未知了。</p><p>本质上这种方式还是利用了零值，指针的零值</p><h4 id="2-7-标签的坑"><a href="#2-7-标签的坑" class="headerlink" title="2.7 标签的坑"></a>2.7 标签的坑</h4><p>标签也是 Golang 中一个非常重要的特性，并且常与 JSON 相伴。而且其实用过 Go 标签的读者们应该知道，标签其实是一个非常灵活、好用的东西。那这样的好特性，在使用上会有什么坑要注意呢？</p><p>一个是名称问题。Tag 可以指定 JSON 数据中字段的名称显示，这点很灵活且实用，但它同时也容易出错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PersonWrong <span class="hljs-keyword">struct</span> &#123;<br>    FirstName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;last_name&quot;`</span><br>    LastName  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;first_name&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>omitempty</code> + <strong>零值的组合有关</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;person_name&quot;`</span><br>    ChildrenCnt <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;cnt,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TagMarshal</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;<br>        Name:        <span class="hljs-string">&quot;Bruce&quot;</span>,<br>        ChildrenCnt: <span class="hljs-number">0</span>,<br>    &#125;<br>    output, _ := json.MarshalIndent(p, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(output))<br>&#125;<br><br><span class="hljs-comment">// Output</span><br>&#123;<br>  <span class="hljs-string">&quot;person_name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在新建结构体对象 <code>p</code> 时，为 <code>ChildrenCnt</code> 赋值为 0。而因为 <code>omitempty</code> 标签的存在，<strong>它使得 JSON 被序列化或反序列化时，忽略空（empty）值。在序列化时的表现就是，输出的 JSON 数据里不包含 <code>ChildrenCnt</code>，看上去就像是没有这个数据。什么是空值？就是零值</strong>。</p><p>这种 <code>omitempty</code> 的问题又该怎么解决呢？由于本质上还是零值惹得祸，所以，用指针。</p><h3 id="3-map序列化"><a href="#3-map序列化" class="headerlink" title="3 map序列化"></a>3 map序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化 创建一个map</span><br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;name&quot;</span>:  <span class="hljs-string">&quot;Alice&quot;</span>,<br><span class="hljs-string">&quot;age&quot;</span>:   <span class="hljs-number">30</span>,<br><span class="hljs-string">&quot;hobby&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;reading&quot;</span>, <span class="hljs-string">&quot;cycling&quot;</span>&#125;,<br>&#125;<br><span class="hljs-comment">// 将map转换为JSON字符串</span><br>jsonBytes, err := json.Marshal(myMap)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error marshaling map to JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 将JSON字节切片转换为字符串并打印</span><br>jsonString := <span class="hljs-type">string</span>(jsonBytes)<br>fmt.Println(jsonString)<br>    <span class="hljs-comment">//输出  &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;hobby&quot;:[&quot;reading&quot;,&quot;cycling&quot;]&#125;</span><br><br>    <br>    <span class="hljs-comment">// 反序列化  定义一个JSON字符串，它表示一个键值对的集合</span><br>jsonString := <span class="hljs-string">`&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;is_student&quot;: false&#125;`</span><br><span class="hljs-comment">// 定义一个空的map，用于存放解码后的数据，键为字符串类型，值为interface&#123;&#125;</span><br><span class="hljs-keyword">var</span> person <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-comment">// 使用json.Unmarshal将JSON字符串解码到map中</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(jsonString), &amp;person)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error unmarshaling JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 打印解码后的map内容</span><br>fmt.Println(person)<br>    <span class="hljs-comment">//输出  map[age:30 is_student:false name:Alice]</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-切片序列化"><a href="#4-切片序列化" class="headerlink" title="4 切片序列化"></a>4 切片序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化 创建一个字符串切片</span><br>fruits := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;<br><span class="hljs-comment">// 将切片转换为JSON字符串</span><br>jsonBytes, err := json.Marshal(fruits)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error marshaling slice to JSON:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 将JSON字节切片转换为字符串并打印</span><br>jsonString := <span class="hljs-type">string</span>(jsonBytes)<br>fmt.Println(jsonString)<br>    <span class="hljs-comment">// 输出 [&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;]</span><br>    <br>    <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-comment">// 定义一个JSON字符串，它表示一个字符串数组</span><br>jsonString := <span class="hljs-string">`[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]`</span><br><span class="hljs-comment">// 创建一个空的字符串切片，用于存放解码后的数据</span><br><span class="hljs-keyword">var</span> fruits []<span class="hljs-type">string</span><br><span class="hljs-comment">// 使用json.Unmarshal将JSON字符串解码到切片中</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(jsonString), &amp;fruits)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error unmarshaling JSON: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 打印解码后的切片</span><br>fmt.Println(fruits)<br>    <span class="hljs-comment">// 输出    [apple banana cherry]</span><br>     <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gvm版本管理</title>
    <link href="/2024/05/27/go/GO%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
    <url>/2024/05/27/go/GO%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A4%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="GO解释器多版本安装"><a href="#GO解释器多版本安装" class="headerlink" title="GO解释器多版本安装"></a>GO解释器多版本安装</h1><h2 id="1、安装g版本管理工具"><a href="#1、安装g版本管理工具" class="headerlink" title="1、安装g版本管理工具"></a>1、安装<a href="https://github.com/voidint/g/blob/master/README_CN.md">g版本管理工具</a></h2><h3 id="Linux-macOS（适用于-bash、zsh）"><a href="#Linux-macOS（适用于-bash、zsh）" class="headerlink" title="Linux&#x2F;macOS（适用于 bash、zsh）"></a>Linux&#x2F;macOS（适用于 bash、zsh）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">建议安装前清空`GOROOT`、`GOBIN`等环境变量</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sSL https://raw.githubusercontent.com/voidint/g/master/install.sh | bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;unalias g&quot;</span> &gt;&gt; ~/.bashrc <span class="hljs-comment"># 可选。若其他程序（如&#x27;git&#x27;）使用了&#x27;g&#x27;作为别名。</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.g/env&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="2、使用命令"><a href="#2、使用命令" class="headerlink" title="2、使用命令"></a>2、使用命令</h2><h3 id="查询当前可供安装的stable状态的-go-版本"><a href="#查询当前可供安装的stable状态的-go-版本" class="headerlink" title="查询当前可供安装的stable状态的 go 版本"></a>查询当前可供安装的<code>stable</code>状态的 go 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g ls-remote stable<br></code></pre></td></tr></table></figure><h3 id="安装目标-go-版本1-20-5"><a href="#安装目标-go-版本1-20-5" class="headerlink" title="安装目标 go 版本1.20.5"></a>安装目标 go 版本<code>1.20.5</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g install 1.14.7</span><br>Downloading 100% [===============] (92/92 MB, 12 MB/s)               <br>Computing checksum with SHA256<br>Checksums matched<br>Now using go1.20.5<br></code></pre></td></tr></table></figure><h3 id="查询已安装的-go-版本"><a href="#查询已安装的-go-版本" class="headerlink" title="查询已安装的 go 版本"></a>查询已安装的 <code>go</code> 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g <span class="hljs-built_in">ls</span></span><br>  1.19.10<br>* 1.20.5<br></code></pre></td></tr></table></figure><h3 id="切换到另一个已安装的-go-版本"><a href="#切换到另一个已安装的-go-版本" class="headerlink" title="切换到另一个已安装的 go 版本"></a>切换到另一个已安装的 <code>go</code> 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g use 1.19.10</span><br>go version go1.19.10 darwin/arm64<br></code></pre></td></tr></table></figure><h3 id="卸载一个已安装的-go-版本"><a href="#卸载一个已安装的-go-版本" class="headerlink" title="卸载一个已安装的 go 版本"></a>卸载一个已安装的 go 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g uninstall 1.19.10</span><br>Uninstalled go1.19.10<br></code></pre></td></tr></table></figure><h3 id="清空-go-安装包文件缓存"><a href="#清空-go-安装包文件缓存" class="headerlink" title="清空 go 安装包文件缓存"></a>清空 go 安装包文件缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g clean</span> <br>Remove go1.18.10.darwin-arm64.tar.gz<br>Remove go1.19.10.darwin-arm64.tar.gz<br>Remove go1.20.5.darwin-arm64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="查看-g-版本信息"><a href="#查看-g-版本信息" class="headerlink" title="查看 g 版本信息"></a>查看 g 版本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">g version 1.5.0<br>build: 2023-01-01T21:01:52+08:00<br>branch: master<br>commit: cec84a3f4f927adb05018731a6f60063fd2fa216<br></code></pre></td></tr></table></figure><h3 id="更新-g-软件本身"><a href="#更新-g-软件本身" class="headerlink" title="更新 g 软件本身"></a>更新 g 软件本身</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g self update</span><br>You are up to date! g v1.5.0 is the latest version.<br></code></pre></td></tr></table></figure><h3 id="卸载-g-软件本身"><a href="#卸载-g-软件本身" class="headerlink" title="卸载 g 软件本身"></a>卸载 g 软件本身</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g self uninstall</span><br>Are you sure you want to uninstall g? (Y/n)<br>y<br>Remove /Users/voidint/.g/bin/g<br>Remove /Users/voidint/.g<br></code></pre></td></tr></table></figure><h2 id="3、GoLand配置-go解释器"><a href="#3、GoLand配置-go解释器" class="headerlink" title="3、GoLand配置 go解释器"></a>3、GoLand配置 go解释器</h2><h3 id="使用命令查看解释器路径"><a href="#使用命令查看解释器路径" class="headerlink" title="使用命令查看解释器路径"></a>使用命令查看解释器路径</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mhd@mhd-VirtualBox:~/.g$ which go<br><br><span class="hljs-regexp">/home/m</span>hd<span class="hljs-regexp">/.g/g</span>o<span class="hljs-regexp">/bin/g</span>o<span class="hljs-comment">#路径地址</span><br><br></code></pre></td></tr></table></figure><h3 id="GOland-中配置解释器地址"><a href="#GOland-中配置解释器地址" class="headerlink" title="GOland 中配置解释器地址"></a>GOland 中配置解释器地址</h3><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310241722115.png" alt="image-20231024172234898"></p><h3 id="设置代理及开启modle模式"><a href="#设置代理及开启modle模式" class="headerlink" title="设置代理及开启modle模式"></a>设置代理及开启modle模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs she">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.io,direct<br><br>goproxy<br>https://goproxy.io/zh/<br>阿里云<br>https://mirrors.aliyun.com/goproxy/<br>七牛云<br>https://goproxy.cn<br></code></pre></td></tr></table></figure><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>以 go 的 web 框架 gin 为例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> go get <span class="hljs-literal">-u</span> github.com/<span class="hljs-built_in">gin</span><span class="hljs-literal">-gonic</span>/<span class="hljs-built_in">gin</span><br></code></pre></td></tr></table></figure><h3 id="激活码"><a href="#激活码" class="headerlink" title="激活码"></a><strong>激活码</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">X96MBT55FM-eyJsaWNlbnNlSWQiOiJYOTZNQlQ1NUZNIiwibGljZW5zZWVOYW1lIjoiQWRtaW4iLCJhc3NpZ25lZU5hbWUiOiJndXJnbGVzIHR1bWJsZXMiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6ZmFsc2UsInByb3BlcnRpZXMiOnt9fSx7ImNvZGUiOiJBQyIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6ZmFsc2UsInByb3BlcnRpZXMiOnt9fSx7ImNvZGUiOiJEUE4iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiUFMiLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiR08iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiQ0wiLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiRE0iLCJmYWxsYmFja0RhdGUiOiIyMDI2LTEyLTMxIiwicGFpZFVwVG8iOiIyMDI2LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlLCJwcm9wZXJ0aWVzIjp7fX0seyJjb2RlIjoiUlMwIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJEIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlJNIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkRDIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkFJTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IkFJUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjYtMTItMzEiLCJwYWlkVXBUbyI6IjIwMjYtMTItMzEiLCJleHRlbmRlZCI6dHJ1ZSwicHJvcGVydGllcyI6e319LHsiY29kZSI6IlBDV01QIiwiZmFsbGJhY2tEYXRlIjoiMjAyNi0xMi0zMSIsInBhaWRVcFRvIjoiMjAyNi0xMi0zMSIsImV4dGVuZGVkIjp0cnVlLCJwcm9wZXJ0aWVzIjp7fX1dLCJtZXRhZGF0YSI6IjAxMjAyMzA1MTFQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOjIwMTYuMSIsImdyYWNlUGVyaW9kRGF5cyI6MywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-H9cXz3HGk4xN+0HYnyyYfhzVvXIIxr5xy1B5v/dxKU9rGr/nxnKBSlw6fVNvlNVS4tHDEYA3WEFap2xRO01Geoa9Sg1QPMQKDtfjCEKIDAKvbZLqp/coHX0pAS13tW1ILvyjGDaPhSo2UiXLHWMymW1m0iGJFHphbW2wWFlF5qqVnL15/iV5FNt9xFOwU6R1s2BTBpnHj/UUxrrv4x4m7jv9y3FvN4/Gn9U6SmUmvrla7K2Rn/yvn7DoAnV7z1A65x3BkMfaQVzsmJcjz7APnb/bnuKQckCGBovsy7FeqQqARg/WQRovQdkw2xeV/2txX6NxdEX8K0smrbqSIV2v7A==-MIIETzCCAjegAwIBAgIEU7kY4TANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCojNikMNM0jfXiA2dNmAi0vGQovFKiSkpw1vlr8LmIdkgGoUhlLQi45oHJgvLQOqqXEW7SmbZIRf7eKW0txBkhryKIWDh3VbcpvySP8fJ27gRfx4+1f3zBxWLvMnlyTMlsmXkm8uSKg0aHRBlqzAtLdpWGAFf11V3CfAA/UNPKDvVGfLC2nAwzVYz3DBpHHp4fq3eRglSJ77nKj8pAuLi/Kj6eq3EAXcxFR/2LXY6FydezbCMTaAQWRAuYLcrOpXiQYXGaohmmjXluxmDo3vB/H13mPohCpC9eFWXD4LWRnyr3AaxLDUTmYkVEYzN7r7bneh6pJXrdxL8T+fQ/uYzPAgMBAAGjgZkwgZYwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TAJBgNVHRMEAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAsGA1UdDwQEAwIFoDAdBgNVHQ4EFgQUrr79B9v2lrPP+wiumX6HlmSazsYwDQYJKoZIhvcNAQELBQADggIBACThwgi/0iU8tdgJ4BvSK236PuI0VmyK+uuluf0w3Ywr7VGs8oVj++EqRYQlMQMbtleRmrWQjg/86E1gO0MSVqua9rMti7AJEkq8nnslgvxqqr3mu9afre+hNDWJZTaOd5UaUtyCR61hPnonMyeZG7jmbgKsf2LML/9Bcbfjvpf7NqkWwssafzmyiq9PSJ/VFdWilahOFcaS2r88hL83b8/9W89sCCHxAq7O+FIygm0qhxw+WdGlvJDlF/YW73fb+aC2wNxzGt6X1aQoU/D/RfxoqpMVUrk+KoR0CSzhGp2NuLC2BeBa4XfsBpkyiQykLr2iWrgz7YjKCCf3kRoR1UPWOTC9sW4peivHBzOjDzRxEuxqU/Ue4DcQXkXWsgMbhRJPwSxEIsLhU7AfV78mGPaVmrTP/T9gDjvK0kIjJnvklElVL0yj7IW6dRJY3S+sjRwE9s1EBNXqoJvyA8FL6uUmNoBP3U6usxuGPLwpWh/jVQSM4KTccYBJmS+VBYmOoPSgBPGAMgPhkv9IBpGNVdhKx+QsituMvoXnR9OMOH8wKQWxWcqFlg88jZPkoxBu3X4mDx189BOr64Vc+CfKSVIhckAItafNR70Two8lEn61aNNTk2zZ/bvsYsEivOSEeHAxOj8g4YbLt3ptkI/BbiOChGFZlTN3h/l41M6zt04M<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译</title>
    <link href="/2024/05/27/go/Golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <url>/2024/05/27/go/Golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang交叉编译"><a href="#Golang交叉编译" class="headerlink" title="Golang交叉编译"></a>Golang交叉编译</h1><p><strong>知识点</strong></p><ul><li>跨平台编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example .</span><br></code></pre></td></tr></table></figure><h2 id="一、CGO-ENABLED"><a href="#一、CGO-ENABLED" class="headerlink" title="一、CGO_ENABLED"></a>一、CGO_ENABLED</h2><p><strong>作用</strong></p><p>用于标识（声明） cgo工具是否可用</p><p><strong>意义</strong></p><p>存在交叉编译的情况下，cgo工具是不可用的。在标准go命令的上下文环境中，交叉编译意味着程序构建环境中的目标计算架构的标识与程序运行环境的目标设计架构的标识不同，或者程序构建环境的目标操作系统的标识与程序运行环境的目标操作系统的标识不同</p><p><strong>小结</strong></p><p>我们在宿主机编译的可执行文件，而在 <code>Scratch</code> 镜像运行的可执行文件；显然两者的计算机架构、运行环境标识你无法确定它是否一致（毕竟构建的 <code>docker</code> 镜像还可以给他人使用），那么我们就要进行交叉编译，而交叉编译不支持 <code>cgo</code>，因此这里要禁用掉它</p><p>关闭 <code>cgo</code> 后，在构建过程中会忽略 <code>cgo</code> 并静态链接所有的依赖库，而开启 <code>cgo</code> 后，方式将转为动态链接</p><p><strong>补充</strong></p><p><code>golang</code> 是默认开启 <code>cgo</code> 工具的，可执行 <code>go env</code> 命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">super@super:~/GO_Work/gin_study/go-gin-example$ go env | grep CGO<br>GCCGO=&quot;gccgo&quot;<br>CGO_ENABLED=&quot;1&quot;<br>CGO_CFLAGS=&quot;-O2 -g&quot;<br>CGO_CPPFLAGS=&quot;&quot;<br>CGO_CXXFLAGS=&quot;-O2 -g&quot;<br>CGO_FFLAGS=&quot;-O2 -g&quot;<br>CGO_LDFLAGS=&quot;-O2 -g&quot;<br></code></pre></td></tr></table></figure><h2 id="二、GOOS"><a href="#二、GOOS" class="headerlink" title="二、GOOS"></a>二、GOOS</h2><p>用于标识（声明）程序构建环境中的目标操作系统</p><p>如：</p><ul><li>linux</li><li>window</li></ul><h2 id="三、GOARCH"><a href="#三、GOARCH" class="headerlink" title="三、GOARCH"></a>三、GOARCH</h2><p>用于标识(声明)程序构建环境的目标计算架构</p><p>若不设置，默认值与程序运行环境的目标计算架构一致</p><p>如：</p><ul><li>amd64</li><li>386</li></ul><table><thead><tr><th>系统</th><th>GOOS</th><th>GOARCH</th></tr></thead><tbody><tr><td>Windows 32 位</td><td>windows</td><td>386</td></tr><tr><td>Windows 64 位</td><td>windows</td><td>amd64</td></tr><tr><td>OS X 32 位</td><td>darwin</td><td>386</td></tr><tr><td>OS X 64 位</td><td>darwin</td><td>amd64</td></tr><tr><td>Linux 32 位</td><td>linux</td><td>386</td></tr><tr><td>Linux 64 位</td><td>linux</td><td>amd64</td></tr></tbody></table><h2 id="四、GOHOSTOS"><a href="#四、GOHOSTOS" class="headerlink" title="四、GOHOSTOS"></a>四、GOHOSTOS</h2><p>用于标识（声明）程序运行环境的目标操作系统</p><h2 id="五、GOHOSTARCH"><a href="#五、GOHOSTARCH" class="headerlink" title="五、GOHOSTARCH"></a>五、GOHOSTARCH</h2><p>用于标识（声明）程序运行环境的目标计算架构</p><h2 id="六、go-build"><a href="#六、go-build" class="headerlink" title="六、go build"></a>六、go build</h2><p><strong>-a</strong></p><p>强制重新编译，简单来说，就是不利用缓存或已编译好的部分文件，直接所有包都是最新的代码重新编译和关联</p><h4 id="installsuffix"><a href="#installsuffix" class="headerlink" title="-installsuffix"></a><strong>-installsuffix</strong></h4><p>作用：</p><p>在软件包安装的目录中增加后缀标识，以保持输出与默认版本分开</p><p><strong>补充：</strong></p><p>如果使用 -race 标识，则后缀就会默认设置为  -race标识，用于区分race和普通的版本</p><p><strong>-o</strong></p><p>指定编译后的可执行文件名称</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go堆栈分析</title>
    <link href="/2024/05/27/go/Go%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/"/>
    <url>/2024/05/27/go/Go%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Go栈内存、堆内存、逃逸分析"><a href="#Go栈内存、堆内存、逃逸分析" class="headerlink" title="Go栈内存、堆内存、逃逸分析"></a>Go栈内存、堆内存、逃逸分析</h1><h2 id="内存的作用"><a href="#内存的作用" class="headerlink" title="内存的作用"></a>内存的作用</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516143225329.png?raw=true" alt="代码是什么"></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516143333413.png?raw=true" alt="image-20240516143333413"></p><p>为了让程序员更好地专注于业务代码的实现，<code>Go</code>语言增加了<a href="https://blog.51cto.com/u_15730090/5510574">垃圾回收</a>机制，自动地回收不再使用的内存。</p><p><code>Go</code>语言有两部分<code>内存</code>空间：<strong>栈内存</strong> 和 <strong>堆内存</strong>。</p><h2 id="os的堆栈"><a href="#os的堆栈" class="headerlink" title="os的堆栈"></a>os的堆栈</h2><p>栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。</p><p>除此之外，堆也是计算机中的一种内存区域，<strong>堆与栈的区别</strong>如下：</p><ol><li><strong>栈</strong>一般由操作系统来分配和释放，<strong>堆</strong>由程序员通过编程语言来申请创建与释放。</li><li><strong>栈</strong>用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，<strong>堆</strong>用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。</li><li><strong>栈</strong>的访问速度相对比<strong>堆</strong>快。</li><li>一般来说，每个线程分配一个<strong>stack(栈)<strong>，每个进程分配一个</strong>heap(堆)<strong>，也就是说，</strong>stack</strong> 是线程独占的，<strong>heap</strong> 是线程共用的。</li><li><strong>stack</strong> 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而<strong>heap</strong>的大小是不确定的，需要的话可以不断增加。</li><li><strong>栈</strong>是由高地址向低地址增长的，而<strong>堆</strong>是由低地址向高地址增长的。</li></ol><p>在 C&#x2F;C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。</p><h2 id="Go的堆栈"><a href="#Go的堆栈" class="headerlink" title="Go的堆栈"></a>Go的堆栈</h2><p>首先，<strong>Go 是自己管理内存的，而不是交给操作系统</strong>，它每次从操作系统申请一大块内存，然后按照 Google 的 <strong><code>TCMalloc</code></strong> 算法进行内存分配，也划分为堆、栈等很多区域。</p><p>这里我们主要关心变量究竟放在堆还是栈里，官方有这么一段解释：</p><p>只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用<strong>垃圾回收</strong>机制进行管理，从而避免 <strong>指针悬空</strong>。此外，局部变量如果非常大，也会存在堆上。</p><p>在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。</p><p>总之，分配在堆还是栈完全<strong>由编译器确定</strong>。而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了<strong>逃逸</strong>。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫<strong>逃逸分析</strong>。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>栈只允许往线性表的一端放入数据，之后在这一端取出数据,按照<strong>后进先出</strong>(LIFO, Last In First Out )的顺序，如图所示。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516154618013.png?raw=true" alt="image-20240516154618013"></p><p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p><p>从栈中取出元素时，只能从栈顶部取出。取出元素后,栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员(除栈顶外的成员)进行任何查看和修改操作 。</p><p><strong>栈内存由编译器自动分配和释放，开发者无法控制。栈内存一般存储函数中的局部变量、参数等，函数创建的时候，这些内存会被自动创建；函数返回的时候，这些内存会被自动释放。</strong></p><p><strong>栈可用于内存分配，栈的分配和回收速度非常快。</strong>下面代码展示枝在内存分配上的作用，代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br>    c = a * b<br>    <br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>    x = c * <span class="hljs-number">10</span><br>    <br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码在没有任何优化情况下，会进行<code>c</code>和<code>x</code>变量的分配过程 。<code>Go</code>语言默认情况下会将<code>c</code>和<code>x</code>分配在栈上，这两个变量在<code>calc()</code>函数退出时就不再使用，函数结束时，保存<code>c</code>和<code>x</code>的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小。</p><p>分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往空间里摆放家具会存在虽然有足够的空间，但各空间分布在不同的区域，无法有一段连续的空间来摆放家具的问题。此时内存分配器就需要对这些空间进行调整优化，如图所示：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516155637223.png?raw=true" alt="image-20240516155637223"></p><p>堆分配内存和栈分配内存相比，<strong>堆适合不可预知大小的内存分配</strong>。但是为此付出的代价是分配<strong>速度较慢</strong>，而且会形成<strong>内存碎片</strong> 。堆内存的生命周期比栈内存要长，如果函数返回的值还会在其他地方使用，那么这个值就会被编译器自动分配到堆上。堆内存相比栈内存来说，不能自动被编译器释放，只能通过垃圾回收器才能释放，所以栈内存效率会很高。</p><p><strong>逃逸机制</strong></p><p>编译器会根据变量<strong>是否被外部引用</strong>来决定是否逃逸：</p><ol><li>如果函数外部没有引用，则优先放到栈中</li><li>如果函数外部存在引用，则必定放到堆中</li><li>如果栈上放不下，则必定放到堆中</li></ol><p><strong>逃逸分析</strong></p><p>既然栈内存的效率更高，肯定是优先使用栈内存。那么<code>Go</code>语言是如何判断一个变量应该分配到堆上还是栈上的呢？这就需要逃逸分析了。<strong>逃逸分析</strong>也就是编译器决定哪些变量放在栈，哪些放在堆中。下面我通过一个示例来讲解逃逸分析，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    newString()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newString</span><span class="hljs-params">()</span></span> *<span class="hljs-type">string</span>&#123;<br>    s:=<span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)<br>    *s= <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>现在通过编译函数 <strong>-gcflags&#x3D;”-m -l”</strong> 逃逸分析来看下是否发生了逃逸，命令如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516160423235.png?raw=true" alt="image-20240516160423235"></p><ul><li><code>-m</code> 表示打印出逃逸分析信息；</li><li><code>-l</code> 表示禁止内联，可以更好地观察逃逸；</li></ul><p>从以上输出结果可以看到，发生了逃逸，也就是说<strong>指针作为函数返回值的时候，一定会发生逃逸</strong>。逃逸到堆内存的变量不能马上被回收，只能通过垃圾回收标记清除，增加了垃圾回收的压力，所以要尽可能地避免逃逸，让变量分配在栈内存上，这样函数返回时就可以回收资源，提升效率。</p><p>下面我对<code>newString</code>函数进行了避免逃逸的优化，优化后的函数代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newString</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span>&#123;<br>    s:=<span class="hljs-built_in">new</span>(<span class="hljs-type">string</span>)<br>    *s = <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">return</span> *s<br>&#125;<br></code></pre></td></tr></table></figure><p>再次通过命令查看以上代码的逃逸分析，命令如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516161150292.png?raw=true" alt="image-20240516161150292"></p><p>通过分析结果可以看到，虽然还是声明了指针变量 <code>s</code>，但是函数返回的并不是指针，所以没有发生逃逸。逃逸分析是判断变量是分配在堆上还是栈上的一种方法，在实际的项目中要尽可能避免逃逸，这样就不会被 <code>GC</code> 拖慢速度，从而提升效率。</p><blockquote><p>Tips：从逃逸分析来看，<strong>指针虽然可以减少内存的拷贝，但它同样会引起逃逸</strong>，所以要根据实际情况选择是否使用指针。</p></blockquote><p>取地址发生逃逸：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span></span> *Data &#123;<br><span class="hljs-keyword">var</span> d Data<br><span class="hljs-keyword">return</span> &amp;d<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(demo())<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516161542225.png?raw=true" alt="image-20240516161542225"></p><p>moved to heap: d。这句话表示， Go 编译器已经确认如果将 d 变量分配在栈上是无法保证程序最终结果的。如果坚持这样做，demo() 的返回值将是 Data 结构的一个不可预知的内存地址。这种情况一般是 C&#x2F;C++ 语言中容易犯错的地方 ：引用了一个函数局部变量的地址。</p><p>Go 语言最终选择将 d 的 Data 结构分配在堆上。然后由垃圾回收器去回收 d 的内存 。</p><p><strong>变量发生逃逸的情况可以总结如下：</strong></p><ul><li><strong>指针逃逸</strong>：函数返回值为局部变量的指针，虽然函数退出了，但是因为指针的存在，指向的内存不能随着函数结束而回收，因此只能分配在堆上。</li><li><strong>栈空间不足</strong>：一个栈的默认大小是 2K，它会自动扩容，最大值取决于系统的配置。当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。例如：s :&#x3D; make([]int, 10000, 10000)，此时 s 就会因为太大被分配到堆上。</li><li><strong>变量大小不确定</strong>：例如：number &#x3D; 10; s :&#x3D; make([]int, number)，此时由于编译期间无法确定slice大长度，所以会被分配到堆上，如果直接写成: s :&#x3D; make([]int, 10)，则不会发生逃逸。</li><li><strong>动态类型</strong>：就是在编译期间不能确定参数的类型，参数的长度，此时就是发生逃逸。比如空接口interface{}可以表示任意类型，如果函数入参为interface{}，编译期间无法确定其参数的具体类型，就会发生逃逸。例如： fmt.Println() 的参数类型为 interface{}，因此会导致打印的对象逃逸到堆上。</li><li><strong>闭包引用对象</strong>：当闭包函数访问了外部变量 n，变量 n 占用的内存不能随着闭包函数的退出而回收，变量 n 将会一直存在，直到被GC回收。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li></ul><p><strong>优化技巧</strong></p><p>​</p><ul><li>尽可能避免逃逸，因为栈内存效率更高，还不用 GC。比如小对象的传参尽量不使用指针，能用数组就不要用切片。</li><li>如果避免不了逃逸，还是在堆上分配了内存，那么对于频繁的内存申请操作，我们要学会重用内存，比如使用 sync.Pool。</li><li>选用合适的算法，达到高性能的目的，比如空间换时间。</li></ul><blockquote><p><strong>Tips：性能优化的时候，要结合基准测试，来验证自己的优化是否有提升。</strong></p></blockquote><p>以上是基于 Go 语言的内存管理机制总结出的 3 个方向的技巧，基于这 3 个大方向基本上可以优化出你想要的效果。除此之外，还有一些小技巧，比如<strong>要尽可能避免使用锁、并发加锁的范围要尽可能小、使用 StringBuilder 做 string 和 []byte 之间的转换、defer 嵌套不要太多</strong>等等。</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证机制</title>
    <link href="/2024/05/27/go/Session%E3%80%81Cookie%E3%80%81Token%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/05/27/go/Session%E3%80%81Cookie%E3%80%81Token%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Session、Cookie、Token"><a href="#Session、Cookie、Token" class="headerlink" title="Session、Cookie、Token"></a>Session、Cookie、Token</h1><p><strong>Cookie 和 Session</strong></p><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300936290.png" alt="image-20240130093625230"></p><p><strong>Session 是什么</strong></p><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为 <code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p><p><strong>Session 如何判断是否是同一会话</strong></p><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID&#x3D;XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID&#x3D;XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300938228.png" alt="image-20240130093802188"></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p><p><strong>Session 的缺点</strong></p><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><p><strong>Cookies 是什么</strong></p><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p><ul><li>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</li></ul><p>Cookie 主要用于下面三个目的</p><ul><li><code>会话管理</code></li></ul><p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p><ul><li><code>个性化</code></li></ul><p>用户偏好、主题或者其他设置</p><ul><li><code>追踪</code></li></ul><p>记录和分析用户行为</p><p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。</p><p><strong>创建 Cookie</strong></p><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p><p><strong>Set-Cookie 和 Cookie 标头</strong></p><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300939222.png" alt="image-20240130093928179"></p><p>此标头告诉客户端存储 Cookie</p><p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300939966.png" alt="image-20240130093948900"></p><p>有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p><p>还有一种是 <code>Cookie的 Secure 和 HttpOnly 标记</code></p><p><strong>会话 Cookies</strong></p><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定<code>Expires</code>或 <code>Max-Age</code> 指令。</p><p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p><p><strong>永久性 Cookies</strong></p><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: id=a3fWa; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">21</span> <span class="hljs-title class_">Oct</span> <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span>;<br></code></pre></td></tr></table></figure><p><strong>Cookie 的 Secure 和 HttpOnly 标记</strong></p><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p><p><strong>HttpOnly 的作用</strong></p><ul><li>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。 </li><li>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。 </li><li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms <a href="https://cloud.tencent.com/product/mfas?from_column=20065&from=20065">身份验证</a>票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li></ul><h4 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a>Cookie 的作用域</h4><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p><p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(不包含子域名）。如果指定了<code>Domain</code>，则一般包含子域名。</p><p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p><p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p><ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul><p><strong>JWT 和 Session Cookies 的相同之处</strong></p><p>在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。</p><p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p><p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300942289.png" alt="image-20240130094231244"></p><p>因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。</p><p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制。</strong></p><p>也就是说，这两种技术都是用来保存你的登录状态，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p><p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p><h4 id="什么是-Session-Cookies"><a href="#什么是-Session-Cookies" class="headerlink" title="什么是 Session Cookies"></a>什么是 Session Cookies</h4><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p><p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202401300944091.png" alt="image-20240130094404035"></p><p><strong>token</strong> 令牌，是用户身份的验证方式。 最简单的token组成:uid(用户唯一的<a href="https://cloud.tencent.com/solution/tb-digitalid?from_column=20065&from=20065">身份标识</a>)、time（当前时间的时间戳）、sign（签名）。 <strong>对Token认证的五点认识</strong></p><ul><li>一个Token就是一些信息的集合；</li><li>在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</li><li>服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；</li><li>基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；</li><li>因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；</li></ul><p><strong>session</strong></p><ul><li>会话，代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续。</li><li>cookie中存放着一个sessionID，请求时会发送这个ID；</li><li>session因为请求（request对象）而产生；</li><li>session是一个容器，可以存放会话过程中的任何对象；</li><li>session的创建与使用总是在服务端，浏览器从来都没有得到过session对象；</li><li>session是一种http存储机制，目的是为武装的http提供持久机制。</li></ul><p><strong>cookie</strong></p><p>储存在用户本地终端上的数据，服务器生成，发送给浏览器，下次请求统一网站给服务器。</p><p><strong>cookie与session区别</strong> cookie数据存放在客户端上，session数据放在服务器上； cookie不是很安全，且保存数据有限； session一定时间内保存在服务器上,当访问增多，占用服务器性能。</p><p><strong>session与token</strong> 作为身份认证，token安全行比session好； Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。</p><p><strong>token与cookie</strong> Cookie是不允许垮域访问的，但是token是支持的， 前提是传输的用户认证信息通过HTTP头传输；</p><p>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><p>HTTP协议与状态保持：Http是一个无状态协议 </p><ul><li><ol><li>实现状态保持的方案：</li></ol><ul><li>1)修改Http协议，使得它支持状态保持(难做到)</li><li>2)Cookies：通过客户端来保持状态信息</li><li>Cookie是服务器发给客户端的特殊信息</li><li>cookie是以文本的方式保存在客户端，每次请求时都带上它</li><li>3)Session：通过服务器端来保持状态信息</li><li>Session是服务器和客户端之间的一系列的交互动作</li><li>服务器为每个客户端开辟内存空间，从而保持状态信息</li><li>由于需要客户端也要持有一个标识(id)，因此，也要求服务器端和客户端传输该标识，</li><li>标识(id)可以借助Cookie机制或者其他的途径来保存</li></ul><p>2、COOKIE机制 </p><ul><li>Cookie的基本特点</li><li>Cookie保存在客户端</li><li>只能保存字符串对象，不能保存对象类型</li><li>需要客户端浏览器的支持：客户端可以不支持，浏览器用户可能会禁用Cookie</li></ul><h4 id="JWT-和-Session-Cookies-的不同"><a href="#JWT-和-Session-Cookies-的不同" class="headerlink" title="JWT 和 Session Cookies 的不同"></a>JWT 和 Session Cookies 的不同</h4><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p><p><strong>密码签名</strong></p><p>JWT 具有加密签名，而 Session Cookies 则没有。</p><p><strong>JSON 是无状态的</strong></p><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p><p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p><p><strong>可扩展性</strong></p><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p><p><strong>JWT 支持跨域认证</strong></p><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p><p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p><h4 id="JWT-和-Session-Cookies-的选型"><a href="#JWT-和-Session-Cookies-的选型" class="headerlink" title="JWT 和 Session Cookies 的选型"></a>JWT 和 Session Cookies 的选型</h4><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说 </p><p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p><p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2024/05/27/go/%E4%BE%9D%E8%B5%96%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/27/go/%E4%BE%9D%E8%B5%96%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h1><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h2 id="安装-swag"><a href="#安装-swag" class="headerlink" title="安装 swag"></a>安装 swag</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get -u github.com<span class="hljs-regexp">/swaggo/</span>swag<span class="hljs-regexp">/cmd/</span>swag@v1.<span class="hljs-number">6.5</span><br></code></pre></td></tr></table></figure><p><code>swag -v</code> 时提示找不到该命令</p><p>可能是因为 <code>$PATH</code> 环境变量没有包含 Go 安装二进制文件的目录。</p><p>在大多数系统中，Go 会将编译好的可执行文件放在 <code>$GOPATH/bin</code> 或使用 Go modules 后的 <code>$(go env GOPATH)/bin</code> 或 <code>$(go env GOBIN)</code> 目录下。你可以通过运行以下命令找到 <code>swag</code> 的安装位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $(go <span class="hljs-built_in">env</span> GOPATH)/bin<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">echo <span class="hljs-constructor">$(<span class="hljs-params">go</span> <span class="hljs-params">env</span> GOBIN)</span><br></code></pre></td></tr></table></figure><p>找到目录后，确保该路径已经添加到了你的系统 <code>$PATH</code> 环境变量中。如果还没有添加，可以将以下行添加到你的 shell 配置文件中（如 <code>.bashrc</code>、<code>.bash_profile</code> 或 <code>.zshrc</code>），然后重新加载配置文件（通过运行 <code>. ~/.bashrc</code>、<code>source ~/.bash_profile</code> 或 <code>source ~/.zshrc</code>）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$(go env GOPATH)/bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用三方库</title>
    <link href="/2024/05/27/go/%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <url>/2024/05/27/go/%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="常用三方库"><a href="#常用三方库" class="headerlink" title="常用三方库"></a>常用三方库</h1><h2 id="gjson"><a href="#gjson" class="headerlink" title="gjson"></a>gjson</h2><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/tidwall/gjson<br></code></pre></td></tr></table></figure><p>后使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/tidwall/gjson&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  json := <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br>  lastName := gjson.Get(json, <span class="hljs-string">&quot;name.last&quot;</span>)<br>  fmt.Println(<span class="hljs-string">&quot;last name:&quot;</span>, lastName.String())<br><br>  age := gjson.Get(json, <span class="hljs-string">&quot;age&quot;</span>)<br>  fmt.Println(<span class="hljs-string">&quot;age:&quot;</span>, age.Int())<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用很简单，只需要传入 JSON 串和要读取的键路径即可。注意一点细节，因为<code>gjson.Get()</code>函数实际上返回的是<code>gjson.Result</code>类型，我们要调用其相应的方法进行转换对应的类型。如上面的<code>String()</code>和<code>Int()</code>方法。</p><p>如果是直接打印输出，其实可以省略<code>String()</code>，<code>fmt</code>包的大部分函数都可以对实现<code>fmt.Stringer</code>接口的类型调用<code>String()</code>方法。</p><h3 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h3><p>键路径实际上是以<code>.</code>分隔的一系列键。<code>gjson</code>支持在键中包含通配符<code>*</code>和<code>?</code>，<code>*</code>匹配任意多个字符，<code>?</code>匹配单个字符，例如<code>ca*</code>可以匹配<code>cat/cate/cake</code>等以<code>ca</code>开头的键，<code>ca?</code>只能匹配<code>cat/cap</code>等以<code>ca</code>开头且后面只有一个字符的键。</p><p>数组使用<strong>键名 + <code>.</code> + 索引</strong>（索引从 0 开始）的方式读取元素，如果键<code>pets</code>对应的值是一个数组，那么<code>pets.0</code>读取数组的第一个元素，<code>pets.1</code>读取第二个元素。</p><p>数组长度使用<strong>键名 + <code>.</code> + <code>#</code></strong> 获取，例如<code>pets.#</code>返回数组<code>pets</code>的长度。</p><p>如果键名中出现<code>.</code>，那么需要使用<code>\</code>进行转义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&#123;&quot;first&quot;:&quot;Tom&quot;, &quot;last&quot;: &quot;Anderson&quot;&#125;,</span><br><span class="hljs-string">  &quot;age&quot;: 37,</span><br><span class="hljs-string">  &quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;],</span><br><span class="hljs-string">  &quot;fav.movie&quot;: &quot;Dear Hunter&quot;,</span><br><span class="hljs-string">  &quot;friends&quot;: [</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Dale&quot;, &quot;last&quot;:&quot;Murphy&quot;, &quot;age&quot;: 44, &quot;nets&quot;: [&quot;ig&quot;, &quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68, &quot;nets&quot;: [&quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Jane&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 47, &quot;nets&quot;: [&quot;ig&quot;, &quot;tw&quot;]&#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;last name:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;name.last&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;age:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;age&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;children:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;children count:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children.#&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;second child:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;children.1&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;third child*:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;child*.2&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;first c?ild:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;c?ildren.0&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;fav.moive&quot;</span>, gjson.Get(json, <span class="hljs-string">`fav.\moive`</span>))<br>  fmt.Println(<span class="hljs-string">&quot;first name of friends:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;friends.#.first&quot;</span>))<br>  fmt.Println(<span class="hljs-string">&quot;last name of second friend:&quot;</span>, gjson.Get(json, <span class="hljs-string">&quot;friends.1.last&quot;</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>前 3 个比较简单，就不赘述了。看后面几个：</p><ul><li><code>children.#</code>：返回数组<code>children</code>的长度；</li><li><code>children.1</code>：读取数组<code>children</code>的第 2 个元素（注意索引从 0 开始）；</li><li><code>child*.2</code>：首先<code>child*</code>匹配<code>children</code>，<code>.2</code>读取第 3 个元素；</li><li><code>c?ildren.0</code>：<code>c?ildren</code>匹配到<code>children</code>，<code>.0</code>读取第一个元素；</li><li><code>fav.\moive</code>：因为键名中含有<code>.</code>，故需要<code>\</code>转义；</li><li><code>friends.#.first</code>：如果数组后<code>#</code>后还有内容，则以后面的路径读取数组中的每个元素，返回一个新的数组。所以该查询返回的数组所有<code>friends</code>的<code>first</code>字段组成；</li><li><code>friends.1.last</code>：读取<code>friends</code>第 2 个元素的<code>last</code>字段。</li></ul><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">last name: Anderson<br>age: <span class="hljs-number">37</span><br>children: [<span class="hljs-string">&quot;Sara&quot;</span>, <span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>]<br>children count: <span class="hljs-number">3</span><br>second child: Alex<br>third child*: Jack<br>first c?ild: Sara<br>fave.moive <br>first name of friends: [<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Roger&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>]<br>last name of second friend: Craig<br></code></pre></td></tr></table></figure><p>对于数组，<code>gjson</code>还支持按条件查询元素，<code>#(条件)</code>返回第一个满足条件的元素，<code>#(条件)#</code>返回所有满足条件的元素。括号内的条件可以有<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>，还有简单的模式匹配<code>%</code>（符合某个模式），<code>!%</code>（不符合某个模式）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(last=&quot;Murphy&quot;).first`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(last=&quot;Murphy&quot;)#.first`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends.#(age&gt;45)#.last&quot;</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(first%&quot;D*&quot;).last`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(first!%&quot;D*&quot;).last`</span>))<br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends.#(nets.#(==&quot;fb&quot;))#.first`</span>))<br><br></code></pre></td></tr></table></figure><p>还是使用上面的 JSON 串。</p><ul><li><code>friends.#(last=&quot;Murphy&quot;).first</code>：<code>friends.#(last=&quot;Murphy&quot;)</code>返回数组<code>friends</code>中第一个<code>last</code>为<code>Murphy</code>的元素，<code>.first</code>表示取出该元素的<code>first</code>字段返回；</li><li><code>friends.#(last=&quot;Murphy&quot;)#.first</code>：<code>friends.#(last=&quot;Murphy&quot;)#</code>返回数组<code>friends</code>中所有的<code>last</code>为<code>Murphy</code>的元素，然后读取它们的<code>first</code>字段放在一个数组中返回。注意与上面一个的区别；</li><li><code>friends.#(age&gt;45)#.last</code>：<code>friends.#(age&gt;45)#</code>返回数组<code>friends</code>中所有年龄大于 45 的元素，然后读取它们的<code>last</code>字段返回；</li><li><code>friends.#(first%&quot;D*&quot;).last</code>：<code>friends.#(first%&quot;D*&quot;)</code>返回数组<code>friends</code>中第一个<code>first</code>字段满足模式<code>D*</code>的元素，取出其<code>last</code>字段返回；</li><li><code>friends.#(first!%&quot;D*&quot;).last</code>：&#96;&#96;friends.#(first!%”D_”)<code>返回数组</code>friends<code>中第一个</code>first<code>字段**不**满足模式</code>D_<code>的元素，读取其</code>last&#96;字段返回；</li><li><code>friends.#(nets.#(==&quot;fb&quot;))#.first</code>：这是个嵌套条件，<code>friends.#(nets.#(==&quot;fb&quot;))#</code>返回数组<code>friends</code>的元素的<code>nets</code>字段中有<code>fb</code>的所有元素，然后取出<code>first</code>字段返回。</li></ul><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">Dale<br>[<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>]<br>[<span class="hljs-string">&quot;Craig&quot;</span>,<span class="hljs-string">&quot;Murphy&quot;</span>]<br>Murphy<br>Craig<br>[<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;Roger&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><strong>修饰符</strong>是<code>gjson</code>提供的非常强大的功能，和键路径搭配使用。<code>gjson</code>提供了一些内置的修饰符：</p><ul><li><code>@reverse</code>：翻转一个数组；</li><li><code>@ugly</code>：移除 JSON 中的所有空白符；</li><li><code>@pretty</code>：使 JSON 更易用阅读；</li><li><code>@this</code>：返回当前的元素，可以用来返回根元素；</li><li><code>@valid</code>：校验 JSON 的合法性；</li><li><code>@flatten</code>：数组平坦化，即将<code>[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;]]</code>转为<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>；</li><li><code>@join</code>：将多个对象合并到一个对象中。</li></ul><p>修饰符的语法和管道类似，以<code>|</code>分隔键路径和分隔符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&#123;&quot;first&quot;:&quot;Tom&quot;, &quot;last&quot;: &quot;Anderson&quot;&#125;,</span><br><span class="hljs-string">  &quot;age&quot;: 37,</span><br><span class="hljs-string">  &quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;],</span><br><span class="hljs-string">  &quot;fav.movie&quot;: &quot;Dear Hunter&quot;,</span><br><span class="hljs-string">  &quot;friends&quot;: [</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Dale&quot;, &quot;last&quot;:&quot;Murphy&quot;, &quot;age&quot;: 44, &quot;nets&quot;: [&quot;ig&quot;, &quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Roger&quot;, &quot;last&quot;: &quot;Craig&quot;, &quot;age&quot;: 68, &quot;nets&quot;: [&quot;fb&quot;, &quot;tw&quot;]&#125;,</span><br><span class="hljs-string">    &#123;&quot;first&quot;: &quot;Jane&quot;, &quot;last&quot;: &quot;Murphy&quot;, &quot;age&quot;: 47, &quot;nets&quot;: [&quot;ig&quot;, &quot;tw&quot;]&#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@reverse&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@reverse|0&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends|@ugly&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;friends|@pretty&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;@this&quot;</span>))<br><br>  nestedJSON := <span class="hljs-string">`&#123;&quot;nested&quot;: [&quot;one&quot;, &quot;two&quot;, [&quot;three&quot;, &quot;four&quot;]]&#125;`</span><br>  fmt.Println(gjson.Get(nestedJSON, <span class="hljs-string">&quot;nested|@flatten&quot;</span>))<br><br>  userJSON := <span class="hljs-string">`&#123;&quot;info&quot;:[&#123;&quot;name&quot;:&quot;dj&quot;, &quot;age&quot;:18&#125;,&#123;&quot;phone&quot;:&quot;123456789&quot;,&quot;email&quot;:&quot;dj@example.com&quot;&#125;]&#125;`</span><br>  fmt.Println(gjson.Get(userJSON, <span class="hljs-string">&quot;info|@join&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>children|@reverse</code>先读取数组<code>children</code>，然后使用修饰符<code>@reverse</code>翻转之后返回，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-string">&quot;Alex&quot;</span>,<span class="hljs-string">&quot;Sara&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>children|@reverse|0</code>在上面翻转的基础上读取第一个元素，即原数组的最后一个元素，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Jack<br></code></pre></td></tr></table></figure><p><code>friends|@ugly</code>移除<code>friends</code>数组中的所有空白字符，返回一行长长的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Dale&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Murphy&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">44</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;ig&quot;</span>,<span class="hljs-string">&quot;fb&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Roger&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Craig&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">68</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;fb&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;Murphy&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">47</span>,<span class="hljs-string">&quot;nets&quot;</span>:[<span class="hljs-string">&quot;ig&quot;</span>,<span class="hljs-string">&quot;tw&quot;</span>]&#125;]<br></code></pre></td></tr></table></figure><p><code>friends|@pretty</code>格式化<code>friends</code>数组，使之更易读：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dale&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Murphy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">44</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ig&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;fb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Roger&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Craig&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">68</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;fb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jane&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Murphy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">47</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ig&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;tw&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><br></code></pre></td></tr></table></figure><p><code>@this</code>返回原始的 JSON 串。</p><p><code>@flatten</code>将数组<code>nested</code>的内层数组平坦到外层后返回，即将所有内层数组的元素依次添加到外层数组后面并移除内层数组，输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>@join</code>将一个数组中的各个对象合并到一个中，例子中将数组中存放的部分个人信息合并成一个对象返回：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;dj&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<span class="hljs-string">&quot;phone&quot;</span>:<span class="hljs-string">&quot;123456789&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;dj@example.com&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰符参数"><a href="#修饰符参数" class="headerlink" title="修饰符参数"></a>修饰符参数</h3><p>修饰符还可以有参数，通过在修饰符后加<code>:</code>后跟参数。如果我们在格式化 JSON 串时，想要对键进行排序，那么可以使用<code>@pretty</code>修饰符的<code>sortKeys</code>参数。我们还是拿上面的 JSON 数据举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span><br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends|@pretty:&#123;&quot;sortKeys&quot;:true&#125;`</span>))<br></code></pre></td></tr></table></figure><p>最终按键名顺序输出 JSON 串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">[<br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">44</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Dale&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Murphy&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;ig&quot;</span>, <span class="hljs-string">&quot;fb&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">68</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Roger&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Craig&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;fb&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">47</span>,<br>    <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-string">&quot;Jane&quot;</span>,<br>    <span class="hljs-string">&quot;last&quot;</span>: <span class="hljs-string">&quot;Murphy&quot;</span>,<br>    <span class="hljs-string">&quot;nets&quot;</span>: [<span class="hljs-string">&quot;ig&quot;</span>, <span class="hljs-string">&quot;tw&quot;</span>]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>当然还可以指定每行缩进<code>indent</code>（默认两个空格），每行开头字符串<code>prefix</code>（默认为空串）和一行最多显示字符数<code>width</code>（默认 80 字符）。下面在每行前增加两个空格：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span><br><br>fmt.Println(gjson.Get(json, <span class="hljs-string">`friends|@pretty:&#123;&quot;sortKeys&quot;:true,&quot;prefix&quot;:&quot;  &quot;&#125;`</span>))<br></code></pre></td></tr></table></figure><h3 id="自定义修饰符"><a href="#自定义修饰符" class="headerlink" title="自定义修饰符"></a>自定义修饰符</h3><p>如此强大的功当然要支持自定义！<code>gjson</code>使用<code>AddModifier()</code>添加一个修饰符，传入一个名字和类型为<code>func(json arg string) string</code>的处理函数。处理函数接受待处理的 JSON 值和修饰符参数，返回处理后的结果。下面编写一个转换大小写的修饰符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  gjson.AddModifier(<span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(json, arg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> arg == <span class="hljs-string">&quot;upper&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> strings.ToUpper(json)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> arg == <span class="hljs-string">&quot;lower&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> strings.ToLower(json)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> json<br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;children&quot;: [&quot;Sara&quot;, &quot;Alex&quot;, &quot;Jack&quot;]&#125;`</span><br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@case:upper&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;children|@case:lower&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-string">&quot;SARA&quot;</span>, <span class="hljs-string">&quot;ALEX&quot;</span>, <span class="hljs-string">&quot;JACK&quot;</span>]<br>[<span class="hljs-string">&quot;sara&quot;</span>, <span class="hljs-string">&quot;alex&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="JSON-行"><a href="#JSON-行" class="headerlink" title="JSON 行"></a>JSON 行</h3><p><code>gjson</code>提供<code>..</code>语法可以将多行数据看成一个数组，每行数据是一个元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Gilbert&quot;, &quot;age&quot;: 61&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Alexa&quot;, &quot;age&quot;: 34&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;May&quot;, &quot;age&quot;: 57&#125;</span><br><span class="hljs-string">&#123;&quot;name&quot;: &quot;Deloise&quot;, &quot;age&quot;: 44&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..#&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..1&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;..#.name&quot;</span>))<br>  fmt.Println(gjson.Get(json, <span class="hljs-string">`..#(name=&quot;May&quot;).age`</span>))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>..#</code>：返回有多少行 JSON 数据；</li><li><code>..1</code>：返回第一行，即<code>&#123;&quot;name&quot;: &quot;Gilbert&quot;, &quot;age&quot;: 61&#125;</code>；</li><li><code>..#.name</code>：<code>#</code>后再接路径，表示对数组中每个元素读取后面的路径，将读取到的值组成一个新数组返回；<code>..#.name</code>表示读取每一行中的<code>name</code>字段，最终返回<code>[&quot;Gilbert&quot;,&quot;Alexa&quot;,&quot;May&quot;,&quot;Deloise&quot;]</code>；</li><li><code>..#(name=&quot;May&quot;).age</code>：括号中的内容<code>(name=&quot;May&quot;)</code>表示条件，所以该条含义为取<code>name</code>为<code>&quot;May&quot;</code>的行中的<code>age</code>字段。</li></ul><p><code>gjson</code>还提供了遍历 JSON 行的方法：<code>gjson.ForEachLine()</code>，参数为 JSON 串和类型为<code>func(line gjson.Result) bool</code>的回调函数。回调返回<code>false</code>时遍历停止。下面代码读取输出每一行的<code>name</code>字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">gjson.ForEachLine(json, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(line gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;name:&quot;</span>, gjson.Get(line.String(), <span class="hljs-string">&quot;name&quot;</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>上面我们介绍了遍历 JSON 行的方式，实际上<code>gjson</code>还提供了通用的遍历数组和对象的方式。<code>gjson.Get()</code>方法返回一个<code>gjson.Result</code>类型的对象，<code>json.Result</code>提供了<code>ForEach()</code>方法用于遍历。该方法接受一个类型为<code>func (key, value gjson.Result) bool</code>的回调函数。遍历对象时<code>key</code>和<code>value</code>分别为对象的键和值；遍历数组时，<code>value</code>为数组元素，<code>key</code>为空（<strong>不是索引</strong>）。回调返回<code>false</code>时，遍历停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&quot;dj&quot;,</span><br><span class="hljs-string">  &quot;age&quot;:18,</span><br><span class="hljs-string">  &quot;pets&quot;: [&quot;cat&quot;, &quot;dog&quot;],</span><br><span class="hljs-string">  &quot;contact&quot;: &#123;</span><br><span class="hljs-string">    &quot;phone&quot;: &quot;123456789&quot;,</span><br><span class="hljs-string">    &quot;email&quot;: &quot;dj@example.com&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  pets := gjson.Get(json, <span class="hljs-string">&quot;pets&quot;</span>)<br>  pets.ForEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_, pet gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>    fmt.Println(pet)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;)<br><br>  contact := gjson.Get(json, <span class="hljs-string">&quot;contact&quot;</span>)<br>  contact.ForEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value gjson.Result)</span></span> <span class="hljs-type">bool</span> &#123;<br>    fmt.Println(key, value)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="校验-JSON"><a href="#校验-JSON" class="headerlink" title="校验 JSON"></a>校验 JSON</h3><p>调用<code>gjson.Get()</code>时，<code>gjson</code>假设我们传入的 JSON 串是合法的。如果 JSON 非法也不会<code>panic</code>，这时会返回不确定的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;name&quot;:dj,age:18&#125;`</span><br>  fmt.Println(gjson.Get(json, <span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面 JSON 串是非法的，<code>dj</code>和<code>age</code>都没有加上双引号（实际上习惯了 Go 语言<code>map</code>的写法，很容易把 JSON 写成这样😭）。上面代码输出<strong>18</strong>，显然是错误的。我们可以使用<code>gjson.Valid()</code>检测 JSON 串是否合法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> !gjson.Valid(json) &#123;<br>  fmt.Println(<span class="hljs-string">&quot;error&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一次获取多个值"><a href="#一次获取多个值" class="headerlink" title="一次获取多个值"></a>一次获取多个值</h3><p>调用<code>gjson.Get()</code>一次只能读取一个值，多次调用又比较麻烦，<code>gjson</code>提供了<code>GetMany()</code>可以一次读取多个值，返回一个数组<code>[]gjson.Result</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> json = <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;:&quot;dj&quot;,</span><br><span class="hljs-string">  &quot;age&quot;:18,</span><br><span class="hljs-string">  &quot;pets&quot;: [&quot;cat&quot;, &quot;dog&quot;],</span><br><span class="hljs-string">  &quot;contact&quot;: &#123;</span><br><span class="hljs-string">    &quot;phone&quot;: &quot;123456789&quot;,</span><br><span class="hljs-string">    &quot;email&quot;: &quot;dj@example.com&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  results := gjson.GetMany(json, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;pets.#&quot;</span>, <span class="hljs-string">&quot;contact.phone&quot;</span>)<br>  <span class="hljs-keyword">for</span> _, result := <span class="hljs-keyword">range</span> results &#123;<br>    fmt.Println(result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go-如何使用Resty"><a href="#Go-如何使用Resty" class="headerlink" title="Go - 如何使用Resty"></a>Go - 如何使用Resty</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>RESTful API</code>已成为现代<code>Web</code>开发的基石，实现了客户端和服务器之间的无缝通信。在本文中，我们将探索使用<code>Resty</code>这个流行的<code>HTTP</code>客户端库在<code>Go</code>中执行常见操作，如<code>GET</code>、<code>POST</code>、<code>UPDATE</code>和<code>DELETE</code>请求的强大和简单性。我们还将学习如何在请求中传递头部，以便自定义和增强我们的<code>API</code>交互。</p><h3 id="安装Resty"><a href="#安装Resty" class="headerlink" title="安装Resty"></a>安装Resty</h3><p>首先，我们需要在<code>Go</code>环境中安装<code>Resty</code>。我们可以使用以下命令安装<code>Resty</code>包：</p><p>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/go-resty/resty/v2<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h3 id="发起GET请求"><a href="#发起GET请求" class="headerlink" title="发起GET请求"></a>发起GET请求</h3><p>以下代码片段演示了一个简单的<code>GET</code>请求，并将响应绑定到一个结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> users []DevUser<br><br>    response, err := resty.New().R().SetResult(&amp;users).Get(<span class="hljs-string">&quot;https://api.example.com/users&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;GET响应:&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;检索到%d个用户:\n&quot;</span>, <span class="hljs-built_in">len</span>(users))<br>    <span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;用户ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, user.ID, user.Name, user.Email)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起POST请求"><a href="#发起POST请求" class="headerlink" title="发起POST请求"></a>发起POST请求</h3><p>下面的示例演示了如何发送带有<code>JSON</code>负载的<code>POST</code>请求，并将响应绑定到结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> createdUser DevUser<br><br>    payload := DevUser&#123;<br>        Name:  <span class="hljs-string">&quot;John Doe&quot;</span>,<br>        Email: <span class="hljs-string">&quot;johndoe@example.com&quot;</span>,<br>    &#125;<br><br>    response, err := resty.New().R().<br>        SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>        SetBody(&amp;payload).<br>        SetResult(&amp;createdUser).<br>        Post(<span class="hljs-string">&quot;https://api.example.com/users&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;POST响应：&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;创建的用户：ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, createdUser.ID, createdUser.Name, createdUser.Email)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起UPDATE（PUT）请求"><a href="#发起UPDATE（PUT）请求" class="headerlink" title="发起UPDATE（PUT）请求"></a>发起UPDATE（PUT）请求</h3><p>下面的示例演示了如何发送带有<code>JSON</code>负载的<code>PUT</code>请求，并将响应绑定到结构体中：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> updatedUser DevUser<br><br>    payload := DevUser&#123;<br>        Name:  <span class="hljs-string">&quot;Updated Name&quot;</span>,<br>        Email: <span class="hljs-string">&quot;updated@example.com&quot;</span>,<br>    &#125;<br><br>    response, err := resty.New().R().<br>        SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br>        SetBody(&amp;payload).<br>        SetResult(&amp;updatedUser).<br>        Put(<span class="hljs-string">&quot;https://api.example.com/users/123&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;PUT响应：&quot;</span>, response.Status())<br>    fmt.Printf(<span class="hljs-string">&quot;更新的用户：ID：%d，姓名：%s，电子邮件：%s\n&quot;</span>, updatedUser.ID, updatedUser.Name, updatedUser.Email)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起DELETE请求"><a href="#发起DELETE请求" class="headerlink" title="发起DELETE请求"></a>发起DELETE请求</h3><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    response, err := resty.New().R().Delete(<span class="hljs-string">&quot;https://api.example.com/users/123&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;DELETE响应：&quot;</span>, response.Status())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传递头部"><a href="#传递头部" class="headerlink" title="传递头部"></a>传递头部</h3><p><code>Resty v2</code>允许我们在请求中包含自定义头部。下面的代码片段演示了如何使用<code>Resty v2</code>传递头部：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-resty/resty/v2&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>    ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client := resty.New()<br>    client.SetHeader(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer YOUR_TOKEN&quot;</span>)<br><br>    response, err := client.R().Get(<span class="hljs-string">&quot;https://api.example.com/protected-resource&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;带有头部的GET响应：&quot;</span>, response.Status())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个全面的指南中，我们探索了如何利用<code>Resty v2</code>这个易于使用的<code>HTTP</code>客户端库，在<code>Go</code>中执行<code>GET</code>、<code>POST</code>、<code>UPDATE</code>和<code>DELETE</code>请求。我们还学习了如何传递头部以增强我们的<code>API</code>交互，提供更高的定制性和安全性。此外，我们还了解了如何将<code>API</code>响应绑定到<code>Go</code>结构体中，以便轻松处理和操作数据。<code>Resty v2</code>简化了<code>RESTful API</code>的使用，使我们能够专注于构建强大和高效的应用程序。</p><h2 id="sjson"><a href="#sjson" class="headerlink" title="sjson"></a>sjson</h2><h3 id="快速使用-1"><a href="#快速使用-1" class="headerlink" title="快速使用"></a>快速使用</h3><p>先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/tidwall/sjson<br></code></pre></td></tr></table></figure><p>后使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br><br>  <span class="hljs-string">&quot;github.com/tidwall/sjson&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> json = <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  value, _ := sjson.Set(json, <span class="hljs-string">&quot;name.last&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码通过<code>sjson.Set()</code>将 JSON 串中<code>name.last</code>对应的值设置为<code>dajun</code>。与<code>gjson</code>一样，<code>sjson</code>也通过<strong>键路径</strong>指定具体的位置，键路径即为一系列以<code>.</code>分隔的键。<code>sjson</code>支持的键路径语法是<code>gjson</code>的一个子集，sjson.Set()&#96;返回设置之后的 JSON 串。最终程序输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">`<span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;first&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;li&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;last&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;dajun&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span> `<br></code></pre></td></tr></table></figure><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><p><code>sjson</code>支持的类型包括<code>nil/bool/int/float/string</code>等。如果传入<code>sjson</code>不支持的类型，<code>sjson</code>会调用<code>json.Marshal</code>，然后将生成的字符串设置到对应的键路径上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  nilJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-literal">nil</span>)<br>  fmt.Println(nilJSON)<br><br>  boolJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-literal">false</span>)<br>  fmt.Println(boolJSON)<br><br>  intJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>)<br>  fmt.Println(intJSON)<br><br>  floatJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">10.5</span>)<br>  fmt.Println(floatJSON)<br><br>  strJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>  fmt.Println(strJSON)<br><br>  mapJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>&#125;)<br>  fmt.Println(mapJSON)<br><br>  u := User&#123;Name: <span class="hljs-string">&quot;dj&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>  structJSON, _ := sjson.Set(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;key&quot;</span>, u)<br>  fmt.Println(structJSON)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们传入一个空字符串，<code>sjson.Set()</code>会生成一个空对象，然后按照键路径依次设置值。下面分析上述程序输出：</p><ul><li><code>nil</code>：在 JSON 中用<code>null</code>表示，输出<code>&#123;&quot;key&quot;:null&#125;</code>；</li><li><code>false</code>：在 JSON 中布尔值用<code>true/false</code>表示，输出<code>&#123;&quot;key&quot;:false&#125;</code>；</li><li><code>1</code>和<code>10.5</code>：整数和浮点数在 JSON 中都用<code>number</code>表示，分别输出<code>&#123;&quot;key&quot;:1&#125;</code>和<code>&#123;&quot;key&quot;:10.5&#125;</code>；</li><li><code>hello</code>：输出<code>&#123;&quot;key&quot;:&quot;hello&quot;&#125;</code>；</li><li><code>map[string]interface&#123;&#125;</code>：<code>sjson</code>并不原生支持<code>map</code>类型，故通过<code>json.Marshal</code>将其序列化为<code>&#123;&quot;hello&quot;:&quot;world&quot;&#125;</code>再设置到键<code>key</code>上，输出<code>&#123;&quot;key&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;</code>；</li><li><code>User</code>对象：先通过<code>json.Marshal</code>序列化为<code>&#123;&quot;name&quot;:&quot;dj&quot;,&quot;age&quot;:18&#125;</code>再设置；</li></ul><h3 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h3><p>修改数组可以通过在键路径后添加索引，有两种特殊情况：</p><ul><li>使用<code>-1</code>或数组长度为索引表示在数组后添加一个新元素；</li><li>使用的索引超出数组的长度，会在数组中添加很多<code>null</code>值。</li></ul><p>看下面示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fruits := <span class="hljs-string">`&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;`</span><br><br>  <span class="hljs-keyword">var</span> newValue <span class="hljs-type">string</span><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.1&quot;</span>, <span class="hljs-string">&quot;grape&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.3&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.-1&quot;</span>, <span class="hljs-string">&quot;strawberry&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Set(fruits, <span class="hljs-string">&quot;fruits.5&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>)<br>  fmt.Println(newValue)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>fruits.1</code>：设置第二个水果为<code>grape</code>（<strong>索引从 0 开始</strong>），输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;grape&quot;, &quot;banana&quot;]&#125;</code>；</li><li><code>fruits.3</code>：由于数组长度为 3，使用 3 表示在数组后添加一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;,&quot;pear&quot;]&#125;</code>；</li><li><code>fruits.-1</code>：使用<code>-1</code>同样表示在数组后添加一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;,&quot;strawberry&quot;]&#125;</code>;</li><li><code>fruits.5</code>：索引 5 已经大于数组长度 3 了，所以会多出两个<code>null</code>，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;,null,null,&quot;watermelon&quot;]&#125;</code>。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除数组元素需要调用<code>sjson.Delete()</code>方法，键路径语法相同。如果键路径对应的值不存在，则<code>Delete()</code>无效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> newValue <span class="hljs-type">string</span><br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;`</span><br><br>  newValue, _ = sjson.Delete(user, <span class="hljs-string">&quot;name.first&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(user, <span class="hljs-string">&quot;name.full&quot;</span>)<br>  fmt.Println(newValue)<br><br>  fruits := <span class="hljs-string">`&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;`</span><br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.1&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.-1&quot;</span>)<br>  fmt.Println(newValue)<br><br>  newValue, _ = sjson.Delete(fruits, <span class="hljs-string">&quot;fruits.5&quot;</span>)<br>  fmt.Println(newValue)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>name.first</code>：删除字段<code>name.first</code>，输出<code>&#123;&quot;name&quot;:&#123;&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;</code>；</li><li><code>name.full</code>：由于字段<code>name.full</code>不存在，无效果，输出<code>&#123;&quot;name&quot;:&#123;&quot;first&quot;:&quot;li&quot;,&quot;last&quot;:&quot;dj&quot;&#125;,&quot;age&quot;:18&#125;</code>；</li><li><code>fruits.1</code>：删除数组<code>fruits</code>的第二个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;banana&quot;]&#125;</code>；</li><li><code>fruits.-1</code>：删除数组最后一个元素，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;]&#125;</code>；</li><li><code>fruits.5</code>：索引 5 超出数组长度 3，无效果，输出<code>&#123;&quot;fruits&quot;:[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]&#125;</code>。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>使用<code>sjson</code>出现的错误分为两种，一种是传入的 JSON 串不是合法的串，另一种是键路径语法错误。<code>Set()</code>和<code>Delete()</code>方法返回的第二个参数为错误，只有非法的键路径会返回错误，非法 JSON 串不会。</p><h3 id="非法-JSON-串"><a href="#非法-JSON-串" class="headerlink" title="非法 JSON 串"></a>非法 JSON 串</h3><p>同<code>gjson</code>一样，<code>sjson</code>同样不会检查传入的 JSON 串的合法性，它假设传入的是合法的串。如果传入一个非法的 JSON 串，程序输出不确定的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:dj,age:18&#125;`</span><br>  newValue, err := sjson.Set(user, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(err, newValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中，我故意传入一个非法的 JSON 串（<code>dj</code>和<code>age</code>漏掉了双引号）。最终程序输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;<span class="hljs-literal">nil</span>&gt; &#123;<span class="hljs-string">&quot;name&quot;</span>:dj,age:<span class="hljs-string">&quot;dajun&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>将<code>age</code>变为了<code>dajun</code>，显然不正确。然而此时返回的<code>err = nil</code>。</p><h3 id="非法键路径"><a href="#非法键路径" class="headerlink" title="非法键路径"></a>非法键路径</h3><p>与<code>gjson</code>相比，<code>sjson</code>能使用的键路径语法比较有限，不能使用通配符和一些条件语法。如果传入的键路径非法，将返回非空的错误值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  user := <span class="hljs-string">`&#123;&quot;name&quot;:&quot;dj&quot;,&quot;age&quot;:18&#125;`</span><br>  newValue, err := sjson.Set(user, <span class="hljs-string">&quot;na?e&quot;</span>, <span class="hljs-string">&quot;dajun&quot;</span>)<br>  fmt.Println(err, newValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>上次使用通配符<code>?</code>，输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>wildcard characters not allowed in path <br><br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>sjson</code>比较简单易用，性能不俗。我们在确定 JSON 串合法的情况下，可使用它快速设置值。</p><h2 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h2><p>在Go语言中，对slice和map是我们最常用的数据结构。比如，计算两个切片的交集、差集；判断切片中的元素是否都满足某个条件的等。我推荐大家使用这个包：<code>[elliotchance/pie](https://github.com/elliotchance/pie)</code>。</p><p>该包封装了<strong>对切片和map的常用操作,能满足工作中的大部分需求</strong>。比如计算切片的交集、差集；对切片中元素按条件过滤的Filter函数；对切片中元素进行数据转换的Each、Map函数等。</p><p>同时具有<strong>高性能</strong>、<strong>类型安全</strong>的特点。实现中对各函数的参数都做了类型的限制。比如Average函数就只能对整型和浮点型参数有效。</p><h3 id="使用pie包的要求："><a href="#使用pie包的要求：" class="headerlink" title="使用pie包的要求："></a>使用pie包的要求：</h3><p>pie v2版本需要Go 1.18+。Go1.17及以下版本需要使用v1版本。</p><h3 id="pie包的目标："><a href="#pie包的目标：" class="headerlink" title="pie包的目标："></a>pie包的目标：</h3><ul><li><strong>类型安全</strong>：无论是在v1版本还是v2版本的泛型中，都对类型做了限制，所以不会遇到运行时类型错误。</li><li><strong>高性能</strong>：该库需要跟原生的Go实现一样快，否则该库封装就没有意义。</li><li><strong>Nil安全</strong>：该库的所有函数都能接收nil参数，并将其视为空切片，而不会引起panic。</li><li><strong>对原切片无副作用</strong>：所有的函数对传入的切片参数都不会做修改。</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>go 版本在1.18及以上，会使用pie&#x2F;v2包，该包使用的是泛型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/elliotchance/pie/v2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    name := pie.Of([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Sally&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;).<br>    FilterNot(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> strings.HasPrefix(name, <span class="hljs-string">&quot;J&quot;</span>)<br>    &#125;).<br>    Map(strings.ToUpper).<br>    Last()<br><br>    fmt.Println(name) <span class="hljs-comment">// &quot;SALLY&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>go1.17及以下版本需要使用pie&#x2F;v1包。因为在1.17之前go还不支持泛型，所以函数只能针对特定类型的切片。在该v1包中，pie实际上是定义了一组类型切片。比如，代表string切片的pie.Strings类型。代表float64切片的pie.Float64s类型。那么该版本在使用时需要先定义切片的类型。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>复制代码<span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/elliotchance/pie/pie&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> names pie.Strings <span class="hljs-comment">//看pie的源码Strings的底层类型是[]string</span><br>    names = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Sally&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;<br><br>    name := names.FilterNot(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> strings.HasPrefix(name, <span class="hljs-string">&quot;J&quot;</span>)<br>    &#125;).<br>    Map(strings.ToUpper).<br>    Last()<br><br>    fmt.Println(name) <span class="hljs-comment">// &quot;SALLY&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pie包支持的功能："><a href="#pie包支持的功能：" class="headerlink" title="pie包支持的功能："></a>pie包支持的功能：</h3><ul><li>切片中的元素是否全部或任意一个满足指定的条件。</li><li>All函数：判断切片中的元素是否都满足指定的条件。</li><li>Any函数：判断切片中的元素只要有1个满足指定条件即可。</li><li>对切片元素进行排序功能。</li><li>AreSorted函数：判断切片是否是有序的</li><li>Sort函数：对切片元素进行排序。</li><li>SortStableUsing函数：使用指定的条件对切片进行排序，并且具有稳定性。</li><li>SortUsing函数</li><li>对切片中的元素去重。</li><li>判断切片中的元素是否不重复的AreUnique函数、去重函数Unique</li><li>对切片进行前、后截取。</li><li>Bottom函数：取切片后n个元素</li><li>Top函数：取切片前n个元素</li><li>DropTop函数：丢掉切片的前n个元素，并返回剩余的元素切片</li><li>两个或多个切片之间的集合运算</li><li>Diff函数：计算两个切片中的差集</li><li>Intersect函数：计算两个或多个切片的交集</li><li>切片元素进行算数运算功能（只针对Integer和float类型的切片有效）。</li><li>Max函数：返回切片中的最大元素</li><li>Min函数：返回切片中的最小元素</li><li>Product函数：对切片所有元素进行乘积运算</li><li>Sum函数：对切片中所有元素进行求和运算</li><li>Average函数：求所有元素的平均值</li><li>对切片中的元素进行数据转换功能：Each、Map、Filter、Flat、Reducer</li><li>针对map的操作：</li><li>Keys函数：获取map的所有键</li><li>Values函数：获取map的所有值</li></ul><p>更多、更详细的功能请参考pie包的源码。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>pie包几乎把slice经常用到的功能都做了封装，可谓是给开发者节省了大量时间。同时，v2包利用了泛型中的类型限制，保证了类型的安全。在性能方面，该包采用了很多策略：在已知切片长度的情况下尽可能给slice<strong>分配固定长度</strong>的内存，减少在使用append时内存申请的次数；使用<strong>切片截取</strong>的形式，避免内存再次分配。</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java三大特性</title>
    <link href="/2024/05/27/java/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2024/05/27/java/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h1><h2 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h2><h3 id="1、该露的露，该藏的藏"><a href="#1、该露的露，该藏的藏" class="headerlink" title="1、该露的露，该藏的藏"></a>1、该露的露，该藏的藏</h3><h4 id="我们的程序设计要追求“高内聚低耦合”：高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量方法给外部使用"><a href="#我们的程序设计要追求“高内聚低耦合”：高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量方法给外部使用" class="headerlink" title="我们的程序设计要追求“高内聚低耦合”：高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量方法给外部使用"></a>我们的程序设计要追求“<a href="https://so.csdn.net/so/search?q=%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88&spm=1001.2101.3001.7020">高内聚低耦合</a>”：高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量方法给外部使用</h4><h3 id="2、封装——数据的隐藏"><a href="#2、封装——数据的隐藏" class="headerlink" title="2、封装——数据的隐藏"></a>2、封装——数据的隐藏</h3><h4 id="通常，应该禁止直接访问一个对象中数据的实际表示，而应通过接口访问，这称为信息隐藏。"><a href="#通常，应该禁止直接访问一个对象中数据的实际表示，而应通过接口访问，这称为信息隐藏。" class="headerlink" title="通常，应该禁止直接访问一个对象中数据的实际表示，而应通过接口访问，这称为信息隐藏。"></a>通常，应该禁止直接访问一个对象中数据的实际表示，而应通过接口访问，这称为<a href="https://so.csdn.net/so/search?q=%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F&spm=1001.2101.3001.7020">信息隐藏</a>。</h4><h3 id="3、记住一句话：属性私有，get-set"><a href="#3、记住一句话：属性私有，get-set" class="headerlink" title="3、记住一句话：属性私有，get&#x2F;set"></a>3、记住一句话：<strong>属性私有，get&#x2F;set</strong></h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="封装的好处："><a href="#封装的好处：" class="headerlink" title="封装的好处："></a>封装的好处：</h4><ul><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现接口</li><li>统一接口</li><li>增强系统的可维护性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.demo04;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">封装的好处：</span><br><span class="hljs-comment">1. 提高程序的安全性，保护数据</span><br><span class="hljs-comment">2. 隐藏代码的实现接口</span><br><span class="hljs-comment">3. 统一接口</span><br><span class="hljs-comment">4. 增强系统的可维护性</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">//Student 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">if</span>(age &gt;<span class="hljs-number">150</span> || age &lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//this.age = age;</span><br>            System.out.println(<span class="hljs-string">&quot;请输入真实年龄！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br> <br> <br> <br><span class="hljs-comment">//main方法，启动</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">S1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        S1.setAge(-<span class="hljs-number">21</span>);<span class="hljs-comment">//不合法的输入！</span><br>        System.out.println(S1.getAge());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><p>​<strong>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。Java中类只有单继承，没有<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BB%A7%E6%89%BF&spm=1001.2101.3001.7020">多继承</a>！ 继承是类和类之间的一种关系，除此之外，类之间的关系还有依赖、组合、聚合等。</strong></p><p>​<strong>子类（派生类）继承父类（基类），使用关键字extends来表示，extends的意思是“扩展”，子类是父类的扩展。子类和父类之间，从意义上讲应具有“is a”的关系。</strong></p><p><strong>super注意点：</strong></p><ul><li>super调用父类的构造方法，必须写在构造方法的第一个</li><li>super只能出现在子类的方法或构造方法中！</li><li>super和this不能在一个类中都调用相应构造方法！</li></ul><p><strong>super V.S this：</strong></p><p>​代表的对象：</p><p>​super: 代表父类对象的应用</p><p>​this： 本身调用者这个对象</p><p>​前提条件:</p><p>​super：只能在继承条件下使用</p><p>​this：无有继承均可使用</p><p>​构造方法：</p><p>​super：父类的构造</p><p>​this：本类的构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.demo05;<br> <br><span class="hljs-comment">//Student子类，子类继承父类,就会拥有父类的所有方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//隐藏代码：调用了父类的无参构造</span><br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">//调用父类构造器的语句，必须放在子类构造器的第一行</span><br>        System.out.println(<span class="hljs-string">&quot;Student 无参执行了！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;shao&quot;</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(name);<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<span class="hljs-comment">//此类的属性name</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name);<span class="hljs-comment">//此类的父类的属性name</span><br>        System.out.println(<span class="hljs-built_in">super</span>.money);<span class="hljs-comment">//此类的父类的属性money</span><br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-comment">//main方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">//s1.test(&quot;Caleb&quot;) ;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>方法重写Override：</strong></p><p>重写只与非静态方法有关，与静态方法没有任何关系！！</p><p>（重写都是方法的重写，和属性无关）</p><p>Tips：</p><pre><code class="hljs">- 方法的重载：类内部重新定义某方法- 方法的重写：本类和父类之间，子类重写父类的方法</code></pre><p>重写：需要有继承关系，子类的方法和父类必须一致，方法体不同。</p><ul><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大，但是不能缩小！public&gt;Protected&gt;Default&gt;private</li><li>抛出的异常：范围，可以被缩小，但不能扩大！ClassNotOfundException—&gt;Exception(大)</li></ul><p><strong>为什么需要重写：</strong></p><p>因为父类的功能，子类不一定需要，或者不满足特定功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.demo06;<br> <br><span class="hljs-comment">//重写是方法的重写，和属性无关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A=&gt;test!&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//main方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//静态方法和非静态方法有很大不同！</span><br>        <span class="hljs-comment">//static方法的调用只和最左边定义的数据类型有关</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.test();<br> <br>        <span class="hljs-comment">//父类的引用指向了子类！！</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<span class="hljs-comment">//子类重写了父类方法</span><br>        a.test();<span class="hljs-comment">//A</span><br> <br>    &#125;<br> <br><span class="hljs-keyword">package</span> com.oop.demo06;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//父类方法重写</span><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//有功能的注释！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B=&gt;test!&quot;</span>);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h2><p>​多态——即同一方法可以根据发送对象的不同而采用多种不同的行为方式。一个对象的实际类型是确定的，但可以指向对象的<strong>引用类型</strong>是不确定的，可以有多种，如：父类、有关系的类。（根源：动态编译！！）</p><p>多态存在的条件：</p><pre><code class="hljs">- 有继承关系- 子类重写父类的方法- 父类引用指向子类对象</code></pre><p>多态的注意事项：</p><ul><li><p>多态是方法的多态，属性没有多态</p></li><li><p>父类和子类，有联系 类型转换异常！ ClassCastException！</p></li><li><p>存在条件： 继承关系，方法<strong>需要重写</strong>，父类引用指向子类对象！ Father f1 &#x3D; new Son();</p><p>所以下面三种<strong>不能被重写</strong>的方法没有多态性：</p><pre><code class="hljs">    1. static 方法，它属于类，不属于实例    1. final 常量，在常量池中    1. private 方法 ，不能被重写</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//一个对象的实际类型是确定的</span><br>        <span class="hljs-comment">//new Student()</span><br>        <span class="hljs-comment">//new Person()</span><br> <br>        <span class="hljs-comment">//可以指向的引用类型就不一定了：父类的引用指向子类</span><br> <br>        <span class="hljs-comment">//student能调用的方法，都是自己的，或是继承父类的</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-comment">//Person 父类型，可以指向子类型，但不能调用子类独有的方法</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br> <br> <br>        <span class="hljs-comment">//对象能执行哪些方法主要看左边的类型，和右边关系不大</span><br>        <span class="hljs-comment">//子类重写了父类的方法，执行子类的方法</span><br>        s1.chat();<br>        s2.chat();<br> <br>        s1.eat();<br>        ((Student) s2).eat();<span class="hljs-comment">//会要求强制类型转换</span><br> <br>    &#125;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">chat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hi!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Eat!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在Java中有两种形式可以实现多态：继承和接口</strong></p><ul><li><p><strong>基于继承实现的多态</strong></p><p>​对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</p></li><li><p><strong>基于接口实现的多态</strong></p><p>​继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。</p><p>​在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。</p><p>​继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语法笔记</title>
    <link href="/2024/05/27/go/%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/27/go/%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="记不住系列"><a href="#记不住系列" class="headerlink" title="记不住系列"></a>记不住系列</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong><code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>    IdOrName any   <span class="hljs-string">`json:&quot;idOrName&quot;`</span><br>    M        MyInt <span class="hljs-string">`json:&quot;m&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str := <span class="hljs-string">&quot;nihao&quot;</span><br>    u := User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// u 是 User1 类型的变量</span><br><br>    <span class="hljs-comment">// 若要声明一个 User1 类型的指针，应如下所示：</span><br>    uPtr := &amp;User1&#123;IdOrName: str, M: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// uPtr 是 *User1 类型的指针变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>u</code> 是 <code>User1</code> 结构体的一个实例，直接存储结构体的值；而如果声明一个指针变量，应该使用取址运算符 <code>&amp;</code>，如 <code>uPtr</code> 示例所示。指针变量存储的是结构体实例的内存地址，而不是结构体的值本身。</p><p>在 Go 语言中，当你修改一个指针类型地址指向的值时，实际上是在修改指针所指向的内存区域中的值；而当你直接修改一个变量的值时，是在修改该变量所在内存区域的值。下面是两者的区别：</p><ol><li><p><strong>修改指针类型地址指向的值：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> ptrToM *MyInt = &amp;m <span class="hljs-comment">// 创建一个指向 m 的指针</span><br><br><span class="hljs-comment">// 修改指针指向的值</span><br>*ptrToM = <span class="hljs-number">20</span> <span class="hljs-comment">// 此时，m 的值变为 20，因为 ptrToM 指向 m 的内存地址</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure><p>在这里，<code>ptrToM</code> 是一个指向 <code>MyInt</code> 类型变量 <code>m</code> 的指针。通过 <code>*ptrToM = 20</code>，我们改变了 <code>ptrToM</code> 所指向内存区域的值，也就是变量 <code>m</code> 的值。</p></li><li><p><strong>直接修改变量的值</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> m MyInt = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 直接修改变量的值</span><br>m = <span class="hljs-number">20</span> <span class="hljs-comment">// 直接将 m 的值改为 20</span><br>fmt.Println(m) <span class="hljs-comment">// 输出：20</span><br></code></pre></td></tr></table></figure><p>在这里，我们直接操作变量 <code>m</code>，将其值设为 20，这是对变量自身内存区域的修改。</p></li></ol><p>简而言之，指针修改的是它指向的内存位置的值，而直接修改变量则是修改变量自身的内存位置的值。使用指针可以在不复制大量数据的情况下修改大型数据结构，还可以实现对函数内部局部变量的修改（通过传递指针作为参数），从而达到引用传递的效果。</p><ol><li><strong>内存地址</strong>：内存地址是计算机内存中每个存储位置的编号，用来唯一标识内存中的一个存储单元。程序运行时，变量、数据结构、指令等都会被加载到内存中，并且每个都有对应的内存地址。</li><li><strong>指针（Pointer）</strong>：在编程语言中，指针是一种数据类型，它存储的就是这样一个内存地址。通过指针，程序能够直接访问和修改内存中的数据。例如，在go中，声明一个整型指针变量 <code>int *p;</code>，通过赋值 <code>p = &amp;x;</code>（其中x为一个整型变量），指针p就存储了x变量的内存地址，进而可以使用 <code>*</code>p &#x3D; 10;&#96; 来改变x的值。</li></ol><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在Go语言中，<code>map</code> 类型相当于Python中的 <code>dict</code>（字典）类型。两者都是关联数组或哈希表的实现，提供了通过键（key）来访问和存储值（value）的能力</p><ul><li><p>在 Go 语言中声明一个 map：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// 创建一个键为string类型，值为int类型的map</span><br><span class="hljs-comment">// 插入或更新元素</span><br>myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">// 如果&quot;apple&quot;这个键不存在，则插入；如果存在，则更新其值为5</span><br><span class="hljs-comment">// 删除键为&quot;apple&quot;的元素</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;apple&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>在 Python 中声明一个 dict：</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>两者都可以通过键来添加、修改、删除和查找元素，并且它们都不保证元素的迭代顺序是固定的（在Go 1.18版本之前）。此外，Go 的 map 和 Python 的 dict 都要求键必须是可比较的类型。在Go中，键通常是整数、浮点数、字符串或指针等；在Python中，键可以是不可变类型，如整数、浮点数、字符串、元组等。</p><h2 id="切片（Slices）"><a href="#切片（Slices）" class="headerlink" title="切片（Slices）"></a>切片（Slices）</h2><p><strong>Go语言中的切片（Slices）</strong>： 对应于Python中的<strong>列表（List）</strong>。两者都是可变长度的序列，可以动态添加、删除或修改元素。Go语言中的切片虽然基于数组实现，但提供了更灵活的接口，无需预先指定固定长度，可以自由扩展。在Python中，列表支持索引访问、切片操作以及其他丰富的内置方法，如append、extend、pop等，这些功能与Go语言切片相似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指定长度为0 </span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//或者给定预期长度</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>切片会自动扩容</p><p>扩容策略一般为:</p><ul><li>若原容量小于1024,新容量为原容量的2倍</li><li>若原容量大于或等于1024,新容量增长1.25倍</li></ul><p>影响性能不报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// len=5, cap=10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// len=8, cap还是10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">4</span>) <span class="hljs-comment">// 超过cap,cap增加到20,重新分配内存</span><br></code></pre></td></tr></table></figure><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个长度为 n 的数组，元素类型为 T</span><br><span class="hljs-keyword">var</span> arr [n]T<br><br><span class="hljs-comment">// 示例：声明一个长度为 5 的整数数组</span><br><span class="hljs-keyword">var</span> numbers [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 或者同时初始化</span><br>numbers := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>在某些方面类似于Python中的<strong>元组（Tuples）</strong>，特别是当它们用来表示固定长度且不可变的数据序列时。然而，Go语言中的数组与Python中的元组有几个关键区别：</p><ul><li><p>Go语言的数组是固定长度的，一旦创建后不能改变长度；</p></li><li><p>Python的元组虽然是不可变序列，但一般不强调其内部元素必须是同一类型，而Go语言的数组要求所有元素必须是同一类型；</p></li><li><p>Python中没有与Go语言数组完全一一对应的结构，因为Python的列表和元组都可以包含多种类型的元素，而且元组虽然不可变，但长度可以变化（通过组合多个元组形成新元组）。</p></li><li><p>数组长度固定，创建后不可变；切片长度可变。</p></li><li><p>数组是值类型；切片是引用类型（类似于指针）。</p></li><li><p>数组通过索引访问；切片除了索引访问外，还可以通过切片表达式创建新的切片视图。</p></li><li><p>切片是对数组的部分引用，更灵活，适用于动态变化的序列数据处理场景。</p></li></ul><h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><p>在Go语言中，结构体（struct）相当于Python中的类实例或命名元组（namedtuple）。结构体是用来封装多个字段的复合数据类型，每个字段都有一个名称和对应的类型</p><p>在Go语言中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br>p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p>在Python中，使用类定义类似的数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>或者使用命名元组（collections.namedtuple）实现更轻量级的、不可变的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])<br>p = Person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>两者都可以用来表示具有固定属性的数据对象。不过，需要注意的是，Go语言中的结构体默认不包含方法，如果需要添加行为（如函数），可以为结构体定义方法；而Python类则通常包含了数据属性和方法，更加面向对象。</p><p>在Go语言中，为结构体定义方法的案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个结构体Person</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 为Person结构体定义一个SayHello方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SayHello() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hello, my name is %s and I am %d years old.\n&quot;</span>, p.Name, p.Age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个Person实例</span><br>    alice := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">25</span>&#125;<br><br>    <span class="hljs-comment">// 调用Person实例的方法</span><br>    alice.SayHello() <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 25 years old.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口类型（interface）"><a href="#接口类型（interface）" class="headerlink" title="接口类型（interface）"></a>接口类型（interface）</h2><p>在 Go 语言中，<code>interface&#123;&#125;</code> 类型被称为“空接口”，它不包含任何方法签名。由于任何类型都至少实现了零个方法（即不实现任何方法），所以任何 Go 语言中的类型都能赋值给 <code>interface&#123;&#125;</code> 类型的变量。这使得 <code>interface&#123;&#125;</code> 成为了一个通用的类型容器，能够在不知道具体类型的情况下存储任意类型的值，从而起到解耦类型的作用，增强了代码的灵活性和扩展性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br>any = <span class="hljs-string">&quot;Hello, World!&quot;</span>  <span class="hljs-comment">// 字符串类型</span><br>any = <span class="hljs-number">42</span>               <span class="hljs-comment">// 整数类型</span><br>any = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;       <span class="hljs-comment">// 空结构体类型</span><br>any = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;        <span class="hljs-comment">// 函数类型</span><br><br><span class="hljs-comment">// 在运行时，可通过类型断言或类型 switches 来确定并操作 any 中的实际类型</span><br>value, ok := any.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然 <code>interface&#123;&#125;</code> 可以存储任何类型的值，但在取出值后，如果不做类型断言还原成具体的类型，就无法访问该类型的任何方法或字段。此外，Go 语言直到 Go 1.18 版本才引入了真正的泛型支持，而在此之前，<code>interface&#123;&#125;</code> 一直是 Go 语言实现泛型编程能力的一种有限方式。</p><h2 id="Go语言中的init作用"><a href="#Go语言中的init作用" class="headerlink" title="Go语言中的init作用"></a>Go语言中的init作用</h2><p>在 Go 语言中，<code>init</code> 函数是一个特殊的函数，它主要用于在包被加载时自动执行初始化动作。<code>init</code> 函数有以下特性：</p><ol><li><strong>自动调用</strong>：<code>init</code> 函数没有返回值，也不需要显式调用。当一个 Go 包被导入时，该包中的所有顶级（非内嵌）<code>init</code> 函数（若有多个的话）会按照它们在源代码中出现的顺序依次执行。</li><li><strong>隐式执行</strong>：<code>init</code> 函数不能被其他函数调用，也无法被外部引用。</li><li><strong>用于初始化</strong>：通常在 <code>init</code> 函数中执行那些需要在程序运行初期完成的准备工作，例如初始化全局变量、连接数据库、设置日志系统、注册系统组件等。</li><li><strong>优先级</strong>：<code>init</code> 函数在 main 函数之前执行，如果一个包被导入，那么该包的 <code>init</code> 函数将在 main 包的 <code>init</code> 函数之前运行。</li></ol><p>举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;Initialized by init&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Executing init function in example package&quot;</span>)<br>    <span class="hljs-comment">// 可以在这里进行初始化操作</span><br>    <span class="hljs-comment">// 例如，设置全局变量、初始化连接、注册函数等</span><br>    globalVar = <span class="hljs-string">&quot;Updated during init&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当导入 <code>example</code> 包时，<code>init</code> 函数会被自动执行，并输出一条消息，同时更新全局变量 <code>globalVar</code> 的值。</p><p><code>setup</code> 函数和 <code>init</code> 函数在 Go 语言中都用于初始化，但它们之间有明显的区别：</p><ol><li><strong>init 函数</strong>：<ul><li>是 Go 语言内置的特殊函数，每个包都可以有多个 <code>init</code> 函数，它们没有返回值，也没有接收者。</li><li><code>init</code> 函数在包被导入时自动调用，并按照它们在源码中的定义顺序执行。</li><li><code>init</code> 函数主要用于包内部的一些必要初始化工作，例如初始化全局变量、设置日志系统、初始化数据库连接等。</li><li>用户不能直接调用 <code>init</code> 函数，由 Go 语言运行时自动执行。</li></ul></li><li><strong>setup 函数</strong>：<ul><li>是用户自定义的普通函数，通常用于整个应用程序或模块的一次性初始化工作。</li><li><code>setup</code> 函数可以有返回值和接收者，具体取决于其实现。</li><li>用户需要在合适的地方主动调用 <code>setup</code> 函数来完成初始化。</li><li>由于 <code>setup</code> 是自定义函数，它的功能和用途更为灵活多样，可以根据应用场景自行设计。</li></ul></li></ol><p>总结：</p><ul><li><code>init</code> 函数是 Go 语言规范的一部分，用于在包加载时进行初始化，执行时机不由用户控制。</li><li><code>setup</code> 函数是程序员自定义的初始化逻辑，执行时机和内容完全由开发者决定，通常用于较为复杂的初始化流程或跨包的全局初始化操作。</li></ul><h2 id="单双引号"><a href="#单双引号" class="headerlink" title="单双引号"></a>单双引号</h2><ul><li><strong>单引号 <code>&#39;</code></strong> 用于表示单个 <code>rune</code> 类型的字符，常用于处理单个Unicode码点，不支持转义字符。</li><li><strong>双引号 <code>&quot;</code></strong> 用于表示 <code>string</code> 类型的字符串，可以包含多个字符及转义序列，适合处理多字符文本和需要转义的场景。</li></ul><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>在Go语言中，&#96;&#96; 符号（通常被称为反引号或背引号）用于创建一个<strong>原生字符串字面量（raw string literal）</strong>。原生字符串字面量具有以下特点：</p><ol><li><strong>包围字符串</strong>：使用一对反引号（&#96;&#96;）来包围字符串内容，与双引号（””）或单引号（’’）包围的字符串不同。</li><li><strong>不支持转义字符</strong>：原生字符串内部的任何字符都不会被解析为转义序列。也就是说，即使你写了类似 <code>\n</code>、<code>\t</code> 或 <code>\&quot;</code> 这样的序列，它们也会被当作普通字符对待，不会转换成换行符、制表符或双引号。</li><li><strong>保留换行和空格</strong>：原生字符串中包含的所有换行符、制表符和空格都将原样保留。当你需要编写多行文本或者包含大量特殊空白字符的字符串时，原生字符串特别有用，因为无需使用转义序列来插入这些字符。</li><li><strong>包含特殊字符无障碍</strong>：由于不解析转义字符，原生字符串尤其适合包含需要原样输出的特殊字符、正则表达式模式、HTML代码、JSON或XML片段等，避免了因转义导致的混淆或错误。</li></ol><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-comment">// 原生字符串字面量</span><br><span class="hljs-number">2</span>sqlQuery := <span class="hljs-string">`</span><br><span class="hljs-string">3    SELECT id, name, email</span><br><span class="hljs-string">4    FROM users</span><br><span class="hljs-string">5    WHERE active = true</span><br><span class="hljs-string">6`</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span>regexPattern := <span class="hljs-string">`^https?://[a-zA-Z0-9._-]+(\.[a-zA-Z]&#123;2,&#125;)+/`</span><br></code></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li><code>sqlQuery</code> 是一个多行SQL查询语句，原生字符串确保了换行符被正确地包含在字符串中，使得查询语句格式清晰且无需手动添加 <code>\n</code> 转义序列。</li><li><code>regexPattern</code> 是一个正则表达式，其中的斜线（<code>/</code>）和特殊字符无需转义，直接写入原生字符串即可。</li></ul><p>总之，在Go语言中，&#96;&#96; 符号用于创建原生字符串字面量，提供了一种方便的方式来编写包含复杂或特殊字符的字符串，且无需考虑转义问题。这对于需要保留原始文本格式或包含特殊字符的场景尤为有用。</p><h2 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h2><ul><li>函数（Function）：在包级别定义，不依赖于特定的接收者（receiver），可以在任何地方调用。</li><li>方法（Method）：与一个具体类型相关联，定义在类型内部，并有一个接收者（receiver）参数，通常用来扩展类型的行为。</li></ul><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DevUser <span class="hljs-keyword">struct</span> &#123;<br>ID    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>var createUser DevUser声明了一个未初始化的<code>DevUser</code>变量<code>createUser</code>，其内部所有字段的值均为各自类型的零值。</li><li>createUser :&#x3D; DevUser{}    使用了简短变量声明（short variable declaration）<code>:=</code>，同时完成了变量声明和初始化。这里<code>createUser</code>变量被赋予了一个<code>DevUser</code>类型的零值实例，即一个所有字段均为零值的新<code>DevUser</code>对象。<code>DevUser&#123;&#125;</code>是创建一个空结构体实例的写法，相当于调用了<code>DevUser</code>类型的零值构造函数。</li></ol><p><strong>总结</strong></p><ul><li><strong>情况一</strong>中，<code>createUser</code>变量未被初始化，其内部字段值为各自的零值。</li><li><strong>情况二</strong>中，<code>createUser</code>变量被初始化为一个所有字段均为零值的<code>DevUser</code>实例。</li></ul><p><strong>Channel 接收操作 <code>&lt;-</code></strong></p><p><code>&lt;-</code> 是Go语言中用于从channel接收数据的操作符。当你看到 <code>message := &lt;-claim.Messages()</code>，这意味着代码正在从 <code>claim.Messages()</code> 返回的channel中接收一个消息。这个channel是由Sarama库提供的，用于向消费者推送来自Kafka的新消息。每次有新消息到达时，<code>claim.Messages()</code> channel就会发送一个消息对象。</p><p><strong>简短声明 <code>:=</code></strong></p><p><code>= &lt;-</code> 后面紧跟的 <code>:=</code> 是Go中的简短声明操作符。简短声明允许你在声明并初始化一个变量时省略类型。例如，<code>message := &quot;Hello&quot;</code> 会声明一个string类型的变量<code>message</code>并将其初始化为<code>&quot;Hello&quot;</code>。在我们的例子中，<code>message := &lt;-claim.Messages()</code> 声明了一个名为<code>message</code>的变量，并将其初始化为从channel接收到的值。Go编译器会根据接收到的数据自动推断变量的类型，这里是<code>sarama.ConsumerMessage</code>类型（假设你已经正确导入了<code>sarama</code>包并使用了它的类型）。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化和没有初始化的区别主要体现在变量或对象的状态以及其在程序中的可用性方面。下面是详细的对比：</p><p><strong>未初始化：</strong></p><ol><li><strong>状态未知</strong>：当一个变量没有经过初始化时，它的值是不确定的。在很多编程语言中（如C、C++、Java、Go等），未初始化的变量会持有其类型的默认值（通常称为零值），如整型为0、浮点型为0.0、布尔型为false、字符串为””（空字符串）、指针为nil等。尽管这些默认值有一定的规律，但对于用户自定义类型（如结构体、类等）或特定情况下的内置类型，未初始化的值可能并不符合预期，甚至可能导致程序逻辑错误或运行时异常。</li><li><strong>不可靠使用</strong>：未初始化的变量值是不确定的，直接使用这样的变量会导致程序行为不可预测。例如，对未初始化的字符串进行拼接、对未初始化的数值进行计算，或者对未初始化的指针进行解引用等，都可能导致错误的结果或程序崩溃。</li><li><strong>资源管理问题</strong>：对于一些需要分配和管理资源（如内存、文件句柄、网络连接等）的变量（如动态分配的数组、打开的文件、创建的数据库连接等），未初始化可能导致资源泄露，因为没有明确的初始化过程来确保资源的合理分配和释放。</li><li><strong>编程规范与调试难度</strong>：未初始化的变量违反了良好的编程实践，使得代码难以阅读、理解和维护。未初始化的变量在调试时也更难追踪其状态变化，增加了定位问题的复杂度。</li></ol><p><strong>初始化：</strong></p><ol><li><strong>确定状态</strong>：初始化后的变量具有明确的初始值，这个值由程序员在声明变量时显式指定或通过构造函数、初始化器等机制赋予。初始化确保了变量在使用前已经有了一个预期的、有意义的值。</li><li><strong>可靠使用</strong>：初始化后的变量可以直接在程序中安全使用，因为它们的值是已知且符合预期的。这有助于保证程序逻辑的正确性和稳定性。</li><li><strong>资源有效管理</strong>：对于需要管理资源的变量，初始化过程通常会伴随着资源的正确分配和设置初始状态。这样可以避免资源泄露，确保程序资源的有效利用和正确清理。</li><li><strong>遵循编程规范与易于调试</strong>：初始化变量遵循了良好的编程习惯，使得代码更具可读性、可维护性。初始化的变量在调试时，其状态变化更为清晰，有助于快速识别和解决问题。</li></ol><p>总之，初始化与未初始化的主要区别在于变量是否具有明确、预期的初始值，以及由此带来的对程序行为的可预测性、资源管理的正确性、代码质量的提升以及调试难度的降低。在实际编程中，应始终确保变量在使用前得到适当的初始化。</p><h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><ul><li>range循环每个元素都会拷贝一份到变量中</li><li>修改变量内部值不影响原结构体</li><li>应使用索引直接操作原始结构体对应元素</li><li>这样才能实现更新原始数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, field := <span class="hljs-keyword">range</span> schemaMeta.Fields &#123;<br><span class="hljs-keyword">if</span> field.FieldPath == <span class="hljs-string">&quot;CSZ10&quot;</span> &#123;<br><span class="hljs-keyword">var</span> newTerms []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">for</span> _, term := <span class="hljs-keyword">range</span> field.GlossaryTerms.Terms &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;urn:li:glossaryTerm:网络身份标识&quot;</span> != term[<span class="hljs-string">&quot;urn&quot;</span>] &#123;<br>newTerms = <span class="hljs-built_in">append</span>(newTerms, term)<br>&#125;<br>&#125;<br>fmt.Println(newTerms)<br>schemaMeta.Fields[i].GlossaryTerms.Terms = newTerms<br><span class="hljs-comment">//field.GlossaryTerms.Terms = newTerms</span><br>fmt.Println(schemaMeta.Fields[i].GlossaryTerms.Terms)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="strconv包转换类型"><a href="#strconv包转换类型" class="headerlink" title="strconv包转换类型"></a>strconv包转换类型</h2><p><strong>字符串转整数：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转整数</span><br>str := <span class="hljs-string">&quot;123&quot;</span><br>i, err := strconv.Atoi(str)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为整数：&quot;</span>, i)<br>&#125;<br><br><span class="hljs-comment">// 大整数转换</span><br>bigStr := <span class="hljs-string">&quot;12345678901234567890&quot;</span><br>bigInt, err := strconv.ParseInt(bigStr, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;大整数转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;大字符串转换为 int64 整数：&quot;</span>, bigInt)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>整数转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 整数转字符串</span><br>num := <span class="hljs-number">456</span><br>str := strconv.Itoa(num)<br>fmt.Println(<span class="hljs-string">&quot;整数转换为字符串：&quot;</span>, str)<br><br><span class="hljs-comment">// int64 转字符串</span><br>bigNum := <span class="hljs-type">int64</span>(<span class="hljs-number">12345678901234567890</span>)<br>bigStr := strconv.FormatInt(bigNum, <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;int64 整数转换为字符串：&quot;</span>, bigStr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串转浮点数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转浮点数</span><br>floatStr := <span class="hljs-string">&quot;3.14&quot;</span><br>f, err := strconv.ParseFloat(floatStr, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为浮点数：&quot;</span>, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浮点数转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 浮点数转字符串</span><br>pi := <span class="hljs-number">3.141592653589793238</span><br>formatStr := strconv.FormatFloat(pi, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">64</span>) <span class="hljs-comment">// &#x27;f&#x27; 表示固定精度模式，-1 表示使用默认精度</span><br>fmt.Println(<span class="hljs-string">&quot;浮点数转换为字符串：&quot;</span>, formatStr)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字符串转布尔值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 字符串转布尔值</span><br>boolStr := <span class="hljs-string">&quot;true&quot;</span><br>b, err := strconv.ParseBool(boolStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转换失败：&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;字符串转换为布尔值：&quot;</span>, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>布尔值转字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 布尔值转字符串</span><br>flag := <span class="hljs-literal">true</span><br>str := strconv.FormatBool(flag)<br>fmt.Println(<span class="hljs-string">&quot;布尔值转换为字符串：&quot;</span>, str)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reflect打印变量类型"><a href="#reflect打印变量类型" class="headerlink" title="reflect打印变量类型"></a>reflect打印变量类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 打印变量 a、b 和 c 的类型</span><br>fmt.Printf(<span class="hljs-string">&quot;a 的类型是: %s\n&quot;</span>, reflect.TypeOf(a).Name())<br>fmt.Printf(<span class="hljs-string">&quot;b 的类型是: %s\n&quot;</span>, reflect.TypeOf(b).Name())<br>fmt.Printf(<span class="hljs-string">&quot;c 的类型是: %s\n&quot;</span>, reflect.TypeOf(c).Name())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在Go语言中，断言（Assertion）主要用于类型转换和接口值类型的判断。主要有以下两种形式的断言：</p><ol><li><p><strong>类型断言</strong>： 类型断言应用于接口类型变量，用于检测接口值是否具有特定类型，并可选择地将其转换为该类型。基本语法如下：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span>value, ok := interfaceVariable.(typeName)<br></code></pre></td></tr></table></figure><p>其中，<code>interfaceVariable</code> 是一个接口类型的变量，<code>typeName</code> 是你希望它实际具有的类型。如果接口变量的动态类型确实与<code>typeName</code>一致，那么<code>value</code>将得到接口值对应的底层值，<code>ok</code>将被设为<code>true</code>；如果不匹配，<code>ok</code>将为<code>false</code>，且<code>value</code>的值将是相应类型的零值。</p><p>例如：</p><p>Go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-number">2</span>s, ok := i.(<span class="hljs-type">string</span>)<br><span class="hljs-number">3</span><span class="hljs-comment">// s == &quot;Hello, world!&quot;, ok == true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>类型断言在接口间转换</strong>： 类型断言也可用于将一个接口类型转换为另一个接口类型，只要它们的底层类型能够满足转换要求。</p></li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>简单讲：反射就是在程序运行时，可以访问自身结构并且做出修改的一种能力（审视自身）。</p><p>在golang中，反射是通过<code>reflect</code>包来实现</p><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><p>要打印变量的类型，你可以使用<code>reflect.TypeOf()</code>函数结合<code>fmt.Println()</code>。<code>reflect.TypeOf()</code>会返回一个代表类型信息的<code>reflect.Type</code>对象，然后通过它的<code>String()</code>方法得到类型名字符串。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> myInt <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br><span class="hljs-keyword">var</span> myString <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span><br><br>fmt.Println(<span class="hljs-string">&quot;myInt的类型是:&quot;</span>, reflect.TypeOf(myInt).String())<br>fmt.Println(<span class="hljs-string">&quot;myString的类型是:&quot;</span>, reflect.TypeOf(myString).String())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><ol><li><p><strong>使用<code>+</code>操作符</strong>: 这是最直接的方式，但当拼接大量字符串时可能导致性能问题，因为它会产生许多临时字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span>name := <span class="hljs-string">&quot;Alice&quot;</span><br><span class="hljs-number">2</span>age := <span class="hljs-number">30</span><br><span class="hljs-number">3</span>result := <span class="hljs-string">&quot;My name is &quot;</span> + name + <span class="hljs-string">&quot;, and I am &quot;</span> + strconv.Itoa(age) + <span class="hljs-string">&quot; years old.&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>fmt.Sprintf</code></strong>: 更灵活，适合格式化输出，性能优于连续的<code>+</code>操作符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span>result := fmt.Sprintf(<span class="hljs-string">&quot;My name is %s, and I am %d years old.&quot;</span>, name, age)<br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>strings.Builder</code></strong>: 对于大量字符串拼接操作，<code>strings.Builder</code>提供了更好的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-keyword">var</span> builder strings.Builder<br><span class="hljs-number">2</span>builder.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br><span class="hljs-number">3</span>builder.WriteString(name)<br><span class="hljs-number">4</span>builder.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br><span class="hljs-number">5</span>builder.WriteString(strconv.Itoa(age))<br><span class="hljs-number">6</span>builder.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br><span class="hljs-number">7</span>result := builder.String()<br></code></pre></td></tr></table></figure></li><li><p><strong>使用<code>bytes.Buffer</code></strong>: 类似于<code>strings.Builder</code>，但在处理字节层面，适用于二进制数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-keyword">var</span> buffer bytes.Buffer<br><span class="hljs-number">2</span>buffer.WriteString(<span class="hljs-string">&quot;My name is &quot;</span>)<br><span class="hljs-number">3</span>buffer.WriteString(name)<br><span class="hljs-number">4</span>buffer.WriteString(<span class="hljs-string">&quot;, and I am &quot;</span>)<br><span class="hljs-number">5</span>buffer.WriteString(strconv.Itoa(age))<br><span class="hljs-number">6</span>buffer.WriteString(<span class="hljs-string">&quot; years old.&quot;</span>)<br><span class="hljs-number">7</span>result := buffer.String()<br></code></pre></td></tr></table></figure></li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ul><li><code>%s</code>: 字符串（string）</li><li><code>%d</code>: 十进制整数（int）</li><li><code>%f</code>: 浮点数，默认保留小数点后6位</li><li><code>%e</code> 或 <code>%E</code>: 科学记数法表示的浮点数</li><li><code>%T</code>: 任何值的类型信息</li><li><code>%g</code> 或 <code>%G</code>: 简化的科学记数法或浮点数，自动根据值的大小选择</li><li><code>%x</code>: 十六进制表示的整数，小写字母</li><li><code>%X</code>: 十六进制表示的整数，大写字母</li><li><code>%o</code>: 八进制表示的整数</li><li><code>%p</code>: 指针地址，以十六进制表示并前缀<code>0x</code></li><li><code>%q</code>: 引号包围的字符串，任何特殊字符都会被转义</li><li><code>%v</code>: 默认格式，根据值的具体类型选择合适的格式化方式</li><li><code>%%</code>: 输出百分号自身（而非作为占位符）</li><li><code>%[width]</code>: 指定输出的最小宽度，不足则左补空格</li><li><code>%-[width]</code>: 左对齐（默认是右对齐）</li><li><code>%.[precision]f</code>: 对浮点数指定小数点后的位数</li><li><code>%[flags][width][.precision]specifier</code>: 组合使用，如<code>%05d</code>表示至少5位宽，不足前导零填充的十进制整数。</li></ul><h2 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h2><p><strong>进程（process）</strong></p><ul><li>进程是资源分配的最小单位</li><li>进程间不共享内存，每个进程拥有自己独立的内存</li><li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li><li>新开进程开销大，并且 CPU 切换进程成本也大</li><li>进程由操作系统调度</li><li>多进程方式比多线程更加稳定</li></ul><p><strong>线程（thread）</strong></p><ul><li>线程是程序执行流的最小单位</li><li>线程是来自于进程的，一个进程下面可以开多个线程</li><li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li><li>线程因为是在同一个进程内的，可以共享内存</li><li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li><li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li><li>某个线程发生致命错误会导致整个进程崩溃</li><li>线程间读写变量存在锁的问题处理起来相对麻烦</li></ul><p><strong>协程（coroutine）</strong></p><ul><li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li><li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li><li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li><li>协程比线程更轻量级</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>判断一个字符串是否包含另一个特定的子字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>originalString := <span class="hljs-string">&quot;Hello, welcome to the Go world!&quot;</span><br>substringToCheck := <span class="hljs-string">&quot;welcome&quot;</span><br><br><span class="hljs-comment">// 使用strings.Contains检查originalString是否包含substringToCheck</span><br><span class="hljs-keyword">if</span> strings.Contains(originalString, substringToCheck) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The string &#x27;%s&#x27; contains the substring &#x27;%s&#x27;.\n&quot;</span>, originalString, substringToCheck)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The string &#x27;%s&#x27; does not contain the substring &#x27;%s&#x27;.\n&quot;</span>, originalString, substringToCheck)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分割字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 使用逗号作为分隔符</span><br>s := <span class="hljs-string">&quot;one,two,three&quot;</span><br>parts := strings.Split(s, <span class="hljs-string">&quot;,&quot;</span>)<br>fmt.Println(parts) <span class="hljs-comment">// 输出: [one two three]</span><br><br><span class="hljs-comment">// 使用空格作为分隔符</span><br>s = <span class="hljs-string">&quot;The quick brown fox&quot;</span><br>words := strings.Fields(s) <span class="hljs-comment">// 使用strings.Fields等同于Split(s, &quot; &quot;)</span><br>fmt.Println(words) <span class="hljs-comment">// 输出: [The quick brown fox]</span><br><br><span class="hljs-comment">// 按照空格分割并去除空字符串</span><br>s = <span class="hljs-string">&quot;   hello   world  &quot;</span><br>trimmedWords := strings.Fields(strings.TrimSpace(s)) <span class="hljs-comment">// 先去除首尾空格，再分割</span><br>fmt.Println(trimmedWords) <span class="hljs-comment">// 输出: [hello world]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx集成keycloak</title>
    <link href="/2024/05/27/linux/nginx%20%E6%8E%A5%E5%85%A5keycloak%20sso%E5%B9%B3%E5%8F%B0/"/>
    <url>/2024/05/27/linux/nginx%20%E6%8E%A5%E5%85%A5keycloak%20sso%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx-接入keycloak-sso平台"><a href="#nginx-接入keycloak-sso平台" class="headerlink" title="nginx 接入keycloak sso平台"></a>nginx 接入keycloak sso平台</h1><blockquote><p>背景</p></blockquote><p>有许多用于验证 API 调用的选项，但是，OAuth 2.0 身份验证机制是主要使用的一种。在这里，OAuth 2.0 访问令牌是从客户端传递到 API 服务器的身份验证凭据，通常作为 HTTP 标头携带。</p><p>Keycloak支持OIDC（OAuth 2.0的扩展），并在对客户端进行身份验证时充当IdP。</p><p>使用 IdP 验证访问令牌的标准方法称为<em>令牌自检</em>。Nginx 充当 OAuth 2.0 <a href="https://en.wikipedia.org/wiki/Relying_party">信赖方</a>，将访问令牌发送到 IdP 进行验证，即令牌自检，并且仅代理通过验证过程的请求 。</p><h2 id="为什么要在Nginx执行令牌验证"><a href="#为什么要在Nginx执行令牌验证" class="headerlink" title="为什么要在Nginx执行令牌验证"></a>为什么要在Nginx执行令牌验证</h2><p>在每个后端服务或应用程序上执行验证会导致大量重复代码和不必要的处理。需要考虑各种错误条件和边缘情况，在每个后端服务中这样做会导致实现不一致，从而导致不可预测的用户体验。</p><p>为了避免代码重复和由此产生的问题，我们可以使用 Nginx 代表后端服务验证访问令牌。</p><h2 id="自定义Nginx"><a href="#自定义Nginx" class="headerlink" title="自定义Nginx"></a>自定义Nginx</h2><p>要将 Nginx 与 Keycloak 集成，我们需要 Lua 依赖。我们没有向Nginx添加依赖项，而是使用Openresty，这是一个建立在Nginx之上的Web服务器。</p><p>以下是用于构建 Nginx 映像所需的内容。<code>Dockerfile</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM openresty/openresty:alpine-fat<br> <br>RUN <span class="hljs-built_in">mkdir</span> /var/log/nginx<br> <br>RUN apk add --no-cache openssl-dev<br>RUN apk add --no-cache git<br>RUN apk add --no-cache gcc<br>RUN luarocks install lua-resty-openidc<br> <br>ENTRYPOINT [<span class="hljs-string">&quot;/usr/local/openresty/nginx/sbin/nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]<br>EXPOSE 80<br></code></pre></td></tr></table></figure><p>在下面的配置文件中，我们保护了两个后端应用程序。<code>nginx.conf</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs json">  server <span class="hljs-punctuation">&#123;</span><br>       listen   <span class="hljs-number">8888</span> ssl;<br>       root     /opt/nginx/html;<br>       #ssl on;<br>       ssl_certificate /etc/nginx/certs/cert.pem;<br>       ssl_certificate_key /etc/nginx/certs/key.pem;<br>       access_by_lua &#x27;<br>         local opts = <span class="hljs-punctuation">&#123;</span><br>           redirect_uri_path = <span class="hljs-string">&quot;/redirect_uri&quot;</span><span class="hljs-punctuation">,</span><br>           accept_none_alg = <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>           discovery = <span class="hljs-string">&quot;http://192.168.0.179:3333/auth/realms/test/.well-known/openid-configuration&quot;</span><span class="hljs-punctuation">,</span><br>           client_id = <span class="hljs-string">&quot;nginx&quot;</span><span class="hljs-punctuation">,</span><br>           client_secret = <span class="hljs-string">&quot;j6KPHwwNW5l5wGVrMFeIEkyZzj6Fh56I&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_uri_scheme = <span class="hljs-string">&quot;https&quot;</span><span class="hljs-punctuation">,</span>  #重定向协议<br>           logout_path = <span class="hljs-string">&quot;/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_uri = <span class="hljs-string">&quot;http://192.168.0.135:3333/auth/realms/test/protocol/openid-connect/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_with_id_token_hint = <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>           session_contents = <span class="hljs-punctuation">&#123;</span>id_token=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><br>         -- call introspect for OAuth <span class="hljs-number">2.0</span> Bearer Access Token validation<br>         local res<span class="hljs-punctuation">,</span> err = require(<span class="hljs-string">&quot;resty.openidc&quot;</span>).authenticate(opts)<br>         if err then<br>           ngx.status = <span class="hljs-number">403</span><br>           ngx.say(err)<br>           ngx.exit(ngx.HTTP_FORBIDDEN)<br>         end<br>      &#x27;;<br> <br>      # I disabled caching so the browser won&#x27;t cache the site.<br>      expires           <span class="hljs-number">0</span>;<br>      add_header        Cache-Control private;<br>      <br>      location / <span class="hljs-punctuation">&#123;</span><br>          proxy_pass    https<span class="hljs-punctuation">:</span><span class="hljs-comment">//nginx-proxy;# nginx转发的地址</span><br>          proxy_set_header    X-Forwarded-For         $remote_addr;<br>          proxy_set_header Host arkime.malcolm.local;<br>          #proxy_set_header http_auth_http_user $authenticated_user;<br>          proxy_set_header Authorization <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-punctuation">&#125;</span><br>      <br>      # redirect server error pages to the static page /<span class="hljs-number">40</span>x.html<br>      #<br>      error_page <span class="hljs-number">404</span> /<span class="hljs-number">404.</span>html;<br>          location = /<span class="hljs-number">40</span>x.html <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-punctuation">&#125;</span><br> <br>      # redirect server error pages to the static page /<span class="hljs-number">50</span>x.html<br>      #<br>      error_page <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /<span class="hljs-number">50</span>x.html;<br>          location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>            root /usr/share/nginx/html;<br>      <span class="hljs-punctuation">&#125;</span><br><br>      <br><span class="hljs-punctuation">&#125;</span><br><br>server <span class="hljs-punctuation">&#123;</span><br>       listen   <span class="hljs-number">8889</span> ;<br>       root     /opt/nginx/html;<br>       #ssl on;<br>       ssl_certificate /etc/nginx/certs/cert.pem;<br>       ssl_certificate_key /etc/nginx/certs/key.pem;<br>       access_by_lua &#x27;<br>         local opts = <span class="hljs-punctuation">&#123;</span><br>           redirect_uri_path = <span class="hljs-string">&quot;/redirect_uri&quot;</span><span class="hljs-punctuation">,</span><br>           accept_none_alg = <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>           discovery = <span class="hljs-string">&quot;http://192.168.0.179:3333/auth/realms/test/.well-known/openid-configuration&quot;</span><span class="hljs-punctuation">,</span><br>           client_id = <span class="hljs-string">&quot;nginx&quot;</span><span class="hljs-punctuation">,</span><br>           client_secret = <span class="hljs-string">&quot;j6KPHwwNW5l5wGVrMFeIEkyZzj6Fh56I&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_uri_scheme = <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>           logout_path = <span class="hljs-string">&quot;/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_uri = <span class="hljs-string">&quot;http://192.168.0.135:3333/auth/realms/test/protocol/openid-connect/logout&quot;</span><span class="hljs-punctuation">,</span><br>           redirect_after_logout_with_id_token_hint = <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>           session_contents = <span class="hljs-punctuation">&#123;</span>id_token=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><br>         -- call introspect for OAuth <span class="hljs-number">2.0</span> Bearer Access Token validation<br>         local res<span class="hljs-punctuation">,</span> err = require(<span class="hljs-string">&quot;resty.openidc&quot;</span>).authenticate(opts)<br>         if err then<br>           ngx.status = <span class="hljs-number">403</span><br>           ngx.say(err)<br>           ngx.exit(ngx.HTTP_FORBIDDEN)<br>         end<br>      &#x27;;<br> <br>      # I disabled caching so the browser won&#x27;t cache the site.<br>      expires           <span class="hljs-number">0</span>;<br>      add_header        Cache-Control private;<br>      <br>      location / <span class="hljs-punctuation">&#123;</span><br>          proxy_pass    https<span class="hljs-punctuation">:</span><span class="hljs-comment">//nginx-proxy;    # nginx转发的地址</span><br>          proxy_set_header    X-Forwarded-For         $remote_addr;<br>          proxy_set_header Host arkime.malcolm.local;<br>          #proxy_set_header http_auth_http_user $authenticated_user;<br>          proxy_set_header Authorization <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-punctuation">&#125;</span><br>      <br>      # redirect server error pages to the static page /<span class="hljs-number">40</span>x.html<br>      #<br>      error_page <span class="hljs-number">404</span> /<span class="hljs-number">404.</span>html;<br>          location = /<span class="hljs-number">40</span>x.html <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-punctuation">&#125;</span><br> <br>      # redirect server error pages to the static page /<span class="hljs-number">50</span>x.html<br>      #<br>      error_page <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /<span class="hljs-number">50</span>x.html;<br>          location = /<span class="hljs-number">50</span>x.html <span class="hljs-punctuation">&#123;</span><br>            root /usr/share/nginx/html;<br>      <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>在启动 Docker 容器时，我们可以访问 Keycloak 管理门户，网址为 。登录后，我们创建一个新领域以添加客户端。<code>http://localhost:3333``myrealm</code></p><p>创建客户端 <code>nginx</code>  我们需要将选项卡中的密钥添加到 Nginx 配置文件中。<code>Credentials</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Access Type :</span> <span class="hljs-string">confidential</span><br><span class="hljs-attr">Valid Redirect URIs:</span> <span class="hljs-string">*</span> <span class="hljs-comment"># 重定向匹配所有</span><br><span class="hljs-string">Web</span> <span class="hljs-string">Origins：*</span> <span class="hljs-comment"># 重定向匹配所有</span><br></code></pre></td></tr></table></figure><p>创建客户端用户密码（用户密码跟随领域）</p><p>设置密码</p><h2 id="使用docker-compose部署环境"><a href="#使用docker-compose部署环境" class="headerlink" title="使用docker-compose部署环境"></a>使用docker-compose部署环境</h2><p>我们使用 Postgres 作为 keycloak 的后端数据库来存储客户端设置。Nginx 容器用于表示演示应用程序，以及 .<code>app_1``app_2</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml">version: &#x27;3.7&#x27;<br>x-tz-variables: &amp;tz-variables<br>  TZ : &#x27;Asia/Shanghai&#x27;<br>networks:<br>    mynetwork:<br>        name: mynetwork<br> <br>volumes:<br>    postgres_data:<br>    <br>services:<br>  postgres:<br>    image: postgres<br>    container_name: postgres<br>    volumes:<br>      - postgres_data:/var/lib/postgresql/data<br>      - ./keycloak_nginx/keycloak.sql:/docker-entrypoint-initdb.d/keycloak.sql:rw<br>    environment: <br>      POSTGRES_DB: keycloak<br>      POSTGRES_USER: keycloak<br>      POSTGRES_PASSWORD: keycloak<br>    ports:<br>      - 5433:5432<br>    networks: <br>      - default<br>  keycloak:<br>    image: super/keycloak:16.1.1<br>    container_name: keycloak<br>    environment:<br>      DB_VENDOR: POSTGRES<br>      DB_ADDR: postgres<br>      DB_DATABSE: keycloak<br>      DB_USER: keycloak<br>      DB_SCHEMA: public<br>      DB_PASSWORD: keycloak<br>      KEYCLOAK_USER: admin<br>      KEYCLOAK_PASSWORD: keycloak            <br>    ports:<br>      - 3333:8080<br>    depends_on:<br>      - postgres<br>    networks:<br>      - default<br>  keycloak_nginx:<br>    build:<br>      context: ./keycloak_nginx<br>      dockerfile: nginx.dockerfile<br>    image: nginx:keycloak<br>    container_name: keycloak_nginx<br>    #environment:<br>    #  KEYCLOAK_IP: 192.168.0.71<br>    ports:<br>      - 8888:8888 <br>      - 8889:8889           <br>    networks:<br>      - default<br>    volumes: <br>      - ./keycloak_nginx/nginx.conf:/etc/nginx/conf.d/default.conf<br>      - ./keycloak_nginx/certs:/etc/nginx/certs<br></code></pre></td></tr></table></figure><p>一旦一切启动并运行，任何访问端口上的应用程序的尝试都应该受到保护，用户将被Keycloak重定向到登录页面。成功登录后，用户将能够访问请求的资源</p><blockquote><p>此处nginx配置了http\https 模式，因iframe 内嵌网页无法验证信任ssl证书 ，使用nginx充当http反向代理</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo blog</title>
    <link href="/2024/05/27/tools/Hexo%E7%BB%93%E5%90%88Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/05/27/tools/Hexo%E7%BB%93%E5%90%88Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo结合Github搭建博客"><a href="#Hexo结合Github搭建博客" class="headerlink" title="Hexo结合Github搭建博客"></a>Hexo结合Github搭建博客</h1><h2 id="1、配置hexo、github环境"><a href="#1、配置hexo、github环境" class="headerlink" title="1、配置hexo、github环境"></a>1、配置hexo、github环境</h2><p><a href="https://zhuanlan.zhihu.com/p/60578464">参考地址</a></p><h2 id="2、hexo常用命令"><a href="#2、hexo常用命令" class="headerlink" title="2、hexo常用命令"></a>2、hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;name&quot;</span>     <span class="hljs-comment"># 新建文章</span><br>hexo new page <span class="hljs-string">&quot;name&quot;</span>  <span class="hljs-comment"># 新建页面</span><br>hexo g                <span class="hljs-comment"># 生成页面</span><br>hexo d                <span class="hljs-comment"># 部署</span><br>hexo g &amp;&amp; hexo d            <span class="hljs-comment"># 生成页面并部署</span><br>hexo s                <span class="hljs-comment"># 本地预览</span><br>hexo clean            <span class="hljs-comment"># 清除缓存和已生成的静态文件</span><br>hexo <span class="hljs-built_in">help</span>             <span class="hljs-comment"># 帮助</span><br></code></pre></td></tr></table></figure><h2 id="3、文章配置"><a href="#3、文章配置" class="headerlink" title="3、文章配置"></a>3、文章配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">参数配置</span><br><span class="hljs-string">文章最开始Front-Matter</span> <span class="hljs-string">使用---</span> <span class="hljs-string">回车配置</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">java三大特性</span> <span class="hljs-comment"># 配置显示文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Java</span>]    <span class="hljs-comment"># 配置标签</span><br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java笔记</span>]  <span class="hljs-comment"># 配置分类</span><br><span class="hljs-attr">published:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 配置是否所有可读</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">hello</span><span class="hljs-comment"># 文章摘要。如果提供，这个字段的文本将作为文章列表页面上的简介</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KafKa 实战1</title>
    <link href="/2024/05/27/tools/Kafka%E5%AE%9E%E6%88%981/"/>
    <url>/2024/05/27/tools/Kafka%E5%AE%9E%E6%88%981/</url>
    
    <content type="html"><![CDATA[<h2 id="1-部署kafka"><a href="#1-部署kafka" class="headerlink" title="1 部署kafka"></a>1 部署kafka</h2><ul><li>docker</li><li>docker-compose</li></ul><h3 id="docker-部署"><a href="#docker-部署" class="headerlink" title="docker  部署"></a>docker  部署</h3><p>docker部署kafka非常简单，只需要两条命令即可完成kafka服务器的部署。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name zookeeper \<br>  -v zookeeper-data:/bitnami \<br>  -e ALLOW_ANONYMOUS_LOGIN=yes \<br>  bitnami/zookeeper<br>  <br>docker run -d --name broker \<br>  -p 9092:9092 \<br>  -v kafka-data:/bitnami \<br>  -e KAFKA_ENABLE_KRAFT=no \<br>  -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 \<br>  -e KAFKA_LISTENERS=PLAINTEXT://:9092 \<br>  -e KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181 \<br>  -e ALLOW_PLAINTEXT_LISTENER=yes \<br>  --link zookeeper:zookeeper \<br>  bitnami/kafka<br></code></pre></td></tr></table></figure><h3 id="docker-compose部署"><a href="#docker-compose部署" class="headerlink" title="docker-compose部署"></a>docker-compose部署</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zookeeper:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/zookeeper</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;zookeeper:/bitnami&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ALLOW_ANONYMOUS_LOGIN:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/kafka</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">broker</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">broker</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;kafka:/bitnami&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ENABLE_KRAFT:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://kafka:9092</span><br>      <span class="hljs-attr">KAFKA_LISTENERS:</span> <span class="hljs-string">PLAINTEXT://:9092</span><br>      <span class="hljs-attr">KAFKA_CFG_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">zookeeper:2181</span><br>      <span class="hljs-attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="hljs-literal">yes</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">kafka:</span><br>  <span class="hljs-attr">zookeeper:</span><br></code></pre></td></tr></table></figure><p><strong><code>kafka-map</code>可视化工具</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">kafka-map:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">dushixiang/kafka-map:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka-map</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;38080:8080&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/kafka-map/data:/usr/local/kafka-map/data</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DEFAULT_USERNAME=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DEFAULT_PASSWORD=admin</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>部署起来很简单,在docker-compose.yml文件的目录下执行docker-compose up -d就可以了。<br>这个docker-compose做的东西比上面docker方式部署的东西要多一些</p><ol><li><p>数据持久化，在当前目录下挂在了两个目录分别存储zookeeper和kafka的数据,当然在docker run 命令中添加 -v 选项也是可以做到这样的效果的</p><p>2.kafka在启动后会初始化一个有分区的topic,同样的,docker run的时候添加 -e KAFKA<em>CREATE</em>TOPICS&#x3D;kafeidou:2:0 也是可以做到的。</p></li></ol><blockquote><p>总结:优先推荐docker-compose方式部署,便于自定义调整</p></blockquote><h3 id="通过kafka自带工具生产消费消息测试"><a href="#通过kafka自带工具生产消费消息测试" class="headerlink" title="通过kafka自带工具生产消费消息测试"></a>通过kafka自带工具生产消费消息测试</h3><p>首先,进入到kafka的docker容器中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose <span class="hljs-built_in">exec</span> -it kafka bash<br></code></pre></td></tr></table></figure><p>运行消费者,进行消息的监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kafka-console-consumer.sh --bootstrap-server 192.168.0.185:9092 --topic test1 --from-beginning   <span class="hljs-comment"># ip为机器i片拼接暴露端口</span><br></code></pre></td></tr></table></figure><p>打开一个新的ssh窗口,同样进入kafka的容器中,执行下面这条命令生产消息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kafka-console-producer.sh --broker-list 192.168.0.185:9092 --topic test1<span class="hljs-comment"># ip为机器i片拼接暴露端口</span><br></code></pre></td></tr></table></figure><p>输入完这条命令后会进入到控制台，可以输入任何想发送的消息,这里发送一个hello</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span><br>&gt;hello<br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到,在生产者的控制台中输入消息后,消费者的控制台立刻看到了消息</p><p>到目前为止,一个kafka完整的hello world就完成了.kafka的部署加上生产者消费者测试.</p><p>工具命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、使用以下命令查看当前 Kafka 主题：<br>kafka-topics.sh --list --bootstrap-server localhost:9092<br>2、刪除主題<br>kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic your_topic_name<br>3、创建主题<br>kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic my-topic<br><br>    --create：创建一个新主题。<br>    --bootstrap-server：指定要用于连接到 Kafka 集群的引导服务器地址。这应该是 Kafka 消息代理的主机名和端口号，例如 localhost:9092。<br>    --replication-factor：指定要为每个分区保留多少个副本。在生产环境中，通常将副本因子设置为 2 或更高，以确保数据冗余性和高可用性。单一副本的主题只有在测试或开发环境中才有意义。<br>    --partitions：指定要为主题创建的分区数。如果没有特殊需求，请在生产中创建多个分区以支持更好的伸缩性和吞吐量。<br>    --topic：指定要创建的主题名称。<br>4、查看主题数据<br>kafka-console-consumer.sh \<br>  --bootstrap-server localhost:9092 \<br>  --topic sarama \<br>  [--from-beginning] \#参数是可选的，如果加上这个参数，消费者会从主题的起始处开始读取消息；默认从最新的消息开始消费。<br>  [--property print.key=true] \#参数用于指定消息的反序列化方式，通常字符串是最常用的，但也可以根据实际情况调整为其他序列化类<br>  [--property print.value=true] \<br>  [--property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer] \<br>  [--property value.deserializer=org.apache.kafka.common.serialization.StringDeserializer]<br><br></code></pre></td></tr></table></figure><h2 id="2-kafka-client"><a href="#2-kafka-client" class="headerlink" title="2 kafka client"></a>2 kafka client</h2><blockquote><p>关于 go 的 kafka client 有很多开源项目，例如</p><ol><li><a href="https://github.com/Shopify/sarama">sarama</a>: 具有完整协议支持的纯 Go 实现。包括消费者和生产者实施，支持 GZIP 和 Snappy 压缩。</li><li><a href="https://github.com/confluentinc/confluent-kafka-go">confluent-kafka-go</a>: Confluent 的 Golang Kafka 客户端包装了 librdkafka C 库，提供完整的 Kafka 协议支持，具有出色的性能和可靠性。提供了高级生产者和消费者，支持 Apache Kafka 0.9 及更高版本的平衡消费者组。</li><li><a href="https://github.com/twmb/franz-go">franz-go</a>: 纯 Go 实现提供完整的协议支持、出色的性能以及对所有面向客户端的 KI P 的支持。</li></ol></blockquote><p>本文使用 sarama 作为 kafka client</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/Shopify/sarama<br></code></pre></td></tr></table></figure><p>本地运行需要将hosts kafka主机名重定向到宿主机上,否则写入的时候出现无法写入,可能是Sarama在内部可能因为某些原因（比如自动发现机制或错误的配置传播）尝试连接到 <code>kafka:9092</code>，这个主机名未能正确解析，引发了错误。</p><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>sarama 提供两种 producer 的实现：<code>AsyncProducer</code>和<code>SyncProducer</code>，即同步和异步的生产者，本文只介绍<code>AsyncProducer</code>的使用，通过<code>sarama.NewAsyncProducer</code>获取生产者实例，其中要求传入两个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewAsyncProducer</span><span class="hljs-params">(addrs []<span class="hljs-type">string</span>, conf *Config)</span></span> (AsyncProducer, <span class="hljs-type">error</span>) &#123;<br>client, err := NewClient(addrs, conf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> newAsyncProducer(client)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>addrs: 即为 kafka broker 地址，对于 kafka 集群可以全部都填，也可以只填一个，保证有一个地址可用即可</li><li>conf: 为 sarama 封装的生产者、消费者、客户端、网络与一体的配置，通过<code>sarama.NewConfig</code>快速获取默认值的配置文件</li></ul><p>对于生产者我们通常修改的配置就是 ack 了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br></code></pre></td></tr></table></figure><p><code>config.Producer.RequiredAcks</code>的类型本质上是 int16，所以习惯<code>0,1,-1</code>这种配置也可以直接赋值，但为了消除魔数的影响，建议使用 sarama 封装的常数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>NoResponse RequiredAcks = <span class="hljs-number">0</span><br>  <br>WaitForLocal RequiredAcks = <span class="hljs-number">1</span><br>  <br>WaitForAll RequiredAcks = <span class="hljs-number">-1</span><br>)<br>acks=<span class="hljs-number">0</span>:<br>生产者在将消息发送给Kafka broker后，不等待任何确认就继续处理下一条消息。这意味着生产者无法知道消息是否到达broker，提供了最低的延迟但不保证消息的可靠性。<br>acks=<span class="hljs-number">1</span>:<br>生产者在至少一个副本（通常是leader副本）确认接收到消息后，认为消息发送成功。这种方式提供了基本的可靠性保障，因为至少消息被一个副本接收了，但如果这个副本在确认后立即失败且没有同步到其他副本，消息可能会丢失。<br>acks=all 或 acks=<span class="hljs-number">-1</span>:<br>生产者在所有同步副本（in-sync replicas，ISR列表中的副本）都确认接收到消息后，才认为消息发送成功。这是最安全但也最慢的模式，因为它确保即使leader副本失败，消息也不会丢失，因为至少还有一个同步副本拥有这条消息。<br></code></pre></td></tr></table></figure><p>如果需要开启开启异步回调，则需要开启<code>config.Producer.Return.Successes</code>和<code>config.Producer.Return.Errors</code>，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>生产者内部对 Successes 和 Errors 分别维护两个 channel，下面是<code>AsyncProducer</code>需要实现的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AsyncProducer <span class="hljs-keyword">interface</span> &#123;<br><br>AsyncClose()<br><br>Close() <span class="hljs-type">error</span><br><br>Input() <span class="hljs-keyword">chan</span>&lt;- *ProducerMessage<br><br>Successes() &lt;-<span class="hljs-keyword">chan</span> *ProducerMessage<br><br>Errors() &lt;-<span class="hljs-keyword">chan</span> *ProducerError<br><br>IsTransactional() <span class="hljs-type">bool</span><br><br>TxnStatus() ProducerTxnStatusFlag<br><br>BeginTxn() <span class="hljs-type">error</span><br><br>CommitTxn() <span class="hljs-type">error</span><br><br>AbortTxn() <span class="hljs-type">error</span><br><br>AddOffsetsToTxn(offsets <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*PartitionOffsetMetadata, groupId <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br><br>AddMessageToTxn(msg *ConsumerMessage, groupId <span class="hljs-type">string</span>, metadata *<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当生产者发送消息的正常回调信息会投递到<code>Successes</code>的 channel 中，错误回调信息会投递到<code>Errors</code>的 channel 中。需要注意的是如果开启了异步回调则一定要去消费这两个 channel 的数据否则会阻塞 producer，同时下面是<code>AsyncProducer</code>实现者的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">p := &amp;asyncProducer&#123;<br>  client:          client,<br>  conf:            client.Config(),<br>  errors:          <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerError),<br>  input:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  successes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  retries:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ProducerMessage),<br>  brokers:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Broker]*brokerProducer),<br>  brokerRefs:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*brokerProducer]<span class="hljs-type">int</span>),<br>  txnmgr:          txnmgr,<br>  metricsRegistry: newCleanupRegistry(client.Config().MetricRegistry),<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>Successes</code>和<code>Errors</code>是一个同步队列，因此对这两个 channel 的回调一定不要有过重的逻辑，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搞一个上下文用于退出异步回调</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancelFunc()<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>EXITED:<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> message := &lt;-producer.Successes():<br>      logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br>    <span class="hljs-keyword">case</span> err := &lt;-producer.Errors():<br>      logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>      logger.Println(<span class="hljs-string">&quot;exited:&quot;</span>, ctx.Err())<br>      <span class="hljs-keyword">break</span> EXITED<br>    &#125;<br>  &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><blockquote><p>Tips: 如何想要查看 sarama 内部日志，可以通过下面方式将其输入到控制台，默认是<code>io.Discard</code>相当于&#x2F;dev&#x2F;null</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sarama.Logger = log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br></code></pre></td></tr></table></figure></blockquote><p>而发送消息则是向<code>Input</code>的 channel 发送数据即可，我们只需要构建特定的消息结构体即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ProducerMessage <span class="hljs-keyword">struct</span> &#123;<br>Topic <span class="hljs-type">string</span><br><br>Key Encoder<br><br>Value Encoder<br><br>Headers []RecordHeader<br><br>Metadata <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-comment">// Below this point are filled in by the producer as the message is processed</span><br>Offset <span class="hljs-type">int64</span><br><br>Partition <span class="hljs-type">int32</span><br>  <br>Timestamp time.Time<br><br>retries        <span class="hljs-type">int</span><br>flags          flagSet<br>expectation    <span class="hljs-keyword">chan</span> *ProducerError<br>sequenceNumber <span class="hljs-type">int32</span><br>producerEpoch  <span class="hljs-type">int16</span><br>hasSequence    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用户只需要构建该结构体导出字段中的<code>Topic</code>、<code>Key</code>、<code>Value</code>、<code>Headers</code>以及<code>Metadata</code>，对于<code>Metadata</code>是 sarama 内部维护的一个字段，在发送数据时会被忽略用作在回调时进行填充，也就是说它不是 kafka 所需要的字段只在客户端内部扭转。而<code>Offset</code>、<code>Partition</code>和<code>Timestamp</code>则是在处理消息时 sarama 自动进行填充。</p><p>因此发送消息伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>  producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>    Topic: topic,<br>    Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> maxRecordNum = <span class="hljs-number">1000</span><br><span class="hljs-keyword">var</span> topic = <span class="hljs-string">&quot;sarama&quot;</span><br><br><span class="hljs-comment">// SimpleProducer 简单生产生</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleProducer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br>config.ClientID = <span class="hljs-string">&quot;demo-producer&quot;</span><br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>producer, err := sarama.NewAsyncProducer(brokers, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = producer.Close() &#125;()<br><span class="hljs-comment">// 搞一个上下文用于退出异步回调</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">defer</span> cancelFunc()<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>EXITED:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-producer.Successes():<br>logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br><span class="hljs-keyword">case</span> err := &lt;-producer.Errors():<br>logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>logger.Println(<span class="hljs-string">&quot;exited:&quot;</span>, ctx.Err())<br><span class="hljs-keyword">break</span> EXITED<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>Topic: topic,<br>Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>&#125;<br>&#125;<br><span class="hljs-comment">// 等 5 s</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的等待是为了将回调信息全部打印完毕，经过研究发现当调用<code>producer.Close()</code>时会将内部维护的 channel 都关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *asyncProducer)</span></span> shutdown() &#123;<br>Logger.Println(<span class="hljs-string">&quot;Producer shutting down.&quot;</span>)<br>p.inFlight.Add(<span class="hljs-number">1</span>)<br>p.input &lt;- &amp;ProducerMessage&#123;flags: shutdown&#125;<br><br>p.inFlight.Wait()<br><br>err := p.client.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Logger.Println(<span class="hljs-string">&quot;producer/shutdown failed to close the embedded client:&quot;</span>, err)<br>&#125;<br><br><span class="hljs-built_in">close</span>(p.input)<br><span class="hljs-built_in">close</span>(p.retries)<br><span class="hljs-built_in">close</span>(p.errors)<br><span class="hljs-built_in">close</span>(p.successes)<br><br>p.metricsRegistry.UnregisterAll()<br>&#125;<br></code></pre></td></tr></table></figure><p>因此可以使用<code>sync.WaitGroup</code>进行改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> maxRecordNum = <span class="hljs-number">1000</span><br><span class="hljs-keyword">var</span> topic = <span class="hljs-string">&quot;sarama&quot;</span><br><br><span class="hljs-comment">// SimpleProducer 简单生产生</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleProducer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 生产者默认配置</span><br>config := sarama.NewConfig()<br>config.ClientID = <span class="hljs-string">&quot;demo-producer&quot;</span><br><span class="hljs-comment">// 配置 ack</span><br>config.Producer.RequiredAcks = sarama.WaitForAll<br><span class="hljs-comment">// 开启异步回调</span><br>config.Producer.Return.Successes = <span class="hljs-literal">true</span><br>config.Producer.Return.Errors = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>producer, err := sarama.NewAsyncProducer(brokers, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 异步回调</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> message := <span class="hljs-keyword">range</span> producer.Successes() &#123;<br>logger.Println(<span class="hljs-string">&quot;success: &quot;</span>, message.Value, message.Partition, message.Offset)<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> err := <span class="hljs-keyword">range</span> producer.Errors() &#123;<br>logger.Println(<span class="hljs-string">&quot;errors: &quot;</span>, err.Err.Error())<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxRecordNum; i++ &#123;<br>producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>Topic: topic,<br>Value: sarama.StringEncoder(fmt.Sprintf(<span class="hljs-string">&quot;srama-%v&quot;</span>, i)),<br>&#125;<br>&#125;<br><span class="hljs-comment">// 关闭生产者</span><br>_ = producer.Close()<br><span class="hljs-comment">// 等待处理完所有的回调信息</span><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>sarama 的 consumer 将会变得复杂一点，需要我们去实现它的消费 handler 接口，同时提供<code>Consumer</code>和<code>ConsumerGroup</code>两种，不在赘述消费者和消费者组的概念，这里使用<code>ConsumerGroup</code>来演示。创建方式和 producer 基本一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> groupID = <span class="hljs-string">&quot;sarama-consumer&quot;</span><br><span class="hljs-keyword">var</span> brokers = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-keyword">var</span> config = sarama.NewConfig()<br>sarama.NewConsumerGroup(brokers, groupID, config)<br></code></pre></td></tr></table></figure><p>对于 consumer 来说通常的配置就是关闭自动提交和偏移量初始化策略(oldest或latest)，配置如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关闭自动提交</span><br>config.Consumer.Offsets.AutoCommit.Enable = <span class="hljs-literal">false</span><br>config.Consumer.Offsets.Initial = sarama.OffsetOldest<br><br></code></pre></td></tr></table></figure><p><code>config.Consumer.Offsets.Initial</code>和 ack 一致，本质上是 int64，这里同样是为了消除魔数</p><p>下面开始消费数据，其方法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Consume(ctx context.Context, topics []<span class="hljs-type">string</span>, handler ConsumerGroupHandler) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><ul><li>ctx: 上下文对象，因为消费逻辑在 goroutine 中进行，需要使用 context 来控制</li><li>topics: 需要消费的 topic</li><li>handler: 封装消费逻辑</li></ul><p>对于 ctx 为了让 consumer 优雅退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 搞一个上下文用于终止消费者</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-comment">// 监听终止信号</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>  signal.Notify(quit, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)<br>  &lt;-quit<br>  cancelFunc()<br>&#125;()<br></code></pre></td></tr></table></figure><p>当监听到系统终止等信号时执行<code>cancelFunc</code>停止<code>handler</code>的消费逻辑，我们需要实现<code>ConsumerGroupHandler</code>的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ConsumerGroupHandler <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Setup is run at the beginning of a new session, before ConsumeClaim.</span><br>Setup(ConsumerGroupSession) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// Cleanup is run at the end of a session, once all ConsumeClaim goroutines have exited</span><br><span class="hljs-comment">// but before the offsets are committed for the very last time.</span><br>Cleanup(ConsumerGroupSession) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// ConsumeClaim must start a consumer loop of ConsumerGroupClaim&#x27;s Messages().</span><br><span class="hljs-comment">// Once the Messages() channel is closed, the Handler must finish its processing</span><br><span class="hljs-comment">// loop and exit.</span><br>ConsumeClaim(ConsumerGroupSession, ConsumerGroupClaim) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个空结构体去实现这个接口，暂时先不关注<code>Setup</code>和<code>Cleanup</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 同步提交</span><br>      session.Commit()<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips: <code>session.MarkMessage(message, &quot;&quot;)</code>是很重要的操作，标记当前消息已经处理完成并在内部记录当前分区的偏移量，但并不是提交偏移量，Mark 的作用相当于 flink 的状态，当调用<code>session.Commit()</code>时才会将内部保存的 offset 提交到 kafka 中。为了确保消息不丢失一定是先处理数据再标记消息</p></blockquote><p>为了提高效率需要将<code>session.Commit()</code>进行异步处理，因此在<code>Setup</code>中启动一个 goroutine 专门用于异步提交，当消息处理完告知这个 goroutine 进行一次 Commit，因此需要维护一个 channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> asyncOffset <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// 后面再解释</span><br><span class="hljs-keyword">const</span> defaultOffsetChannelSize = math.MaxInt<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Setup(session sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 初始化异步提交的channel</span><br>asyncOffset = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, defaultOffsetChannelSize)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 异步提交偏移量</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> asyncOffset &#123;<br>session.Commit()<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Cleanup</code>用于关闭通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Cleanup(_ sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 关闭通道</span><br><span class="hljs-built_in">close</span>(asyncOffset)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConsumeClaim</code>则触发提交偏移量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 异步提交</span><br>asyncOffset &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> Tips: 空 struct{} 在 go 中是不占用内存空间的</p></blockquote><p>为了当客户端停止消费时所有的偏移量都能提交则使用<code>sync.WaitGroup</code>，最终完整代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> example<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/Shopify/sarama&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> groupID = <span class="hljs-string">&quot;sarama-consumer&quot;</span><br><span class="hljs-keyword">var</span> asyncOffset <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-keyword">const</span> defaultOffsetChannelSize = math.MaxInt<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleConsumer</span><span class="hljs-params">()</span></span> &#123;<br>brokers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>&#125;<br><span class="hljs-comment">// 消费者配置</span><br>config := sarama.NewConfig()<br><span class="hljs-comment">// 关闭自动提交</span><br>config.Consumer.Offsets.AutoCommit.Enable = <span class="hljs-literal">false</span><br>config.Consumer.Offsets.Initial = sarama.OffsetOldest<br><span class="hljs-comment">// 开启日志</span><br>logger := log.New(os.Stdout, <span class="hljs-string">&quot;[Sarama] &quot;</span>, log.LstdFlags)<br>sarama.Logger = logger<br>consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; _ = consumer.Close() &#125;()<br><span class="hljs-comment">// 搞一个上下文用于终止消费者</span><br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-comment">// 监听终止信号</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>logger.Println(<span class="hljs-string">&quot;monitor signal&quot;</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(quit, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)<br>&lt;-quit<br>logger.Println(<span class="hljs-string">&quot;stop consumer&quot;</span>)<br>cancelFunc()<br>&#125;()<br><span class="hljs-comment">// 消费数据</span><br>err = consumer.Consume(ctx, []<span class="hljs-type">string</span>&#123;topic&#125;, &amp;Consumer&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">// 等待所有偏移量都提交完毕再退出</span><br>logger.Println(<span class="hljs-string">&quot;当前存在未提交的偏移量&quot;</span>)<br>wg.Wait()<br>&#125;<br><br><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Setup(session sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 初始化异步提交的channel</span><br>asyncOffset = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, defaultOffsetChannelSize)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 异步提交偏移量</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> asyncOffset &#123;<br>session.Commit()<br>&#125;<br>wg.Done()<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Cleanup(_ sarama.ConsumerGroupSession) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 关闭通道</span><br><span class="hljs-built_in">close</span>(asyncOffset)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) <span class="hljs-type">error</span> &#123;<br>EXIT:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-claim.Messages():<br>log.Printf(<span class="hljs-string">&quot;Message claimed: value = %s, timestamp = %v, topic = %s&quot;</span>, <span class="hljs-type">string</span>(message.Value), message.Timestamp, message.Topic)<br><span class="hljs-comment">// 标记消息，并不是提交偏移量</span><br>session.MarkMessage(message, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 异步提交</span><br>asyncOffset &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">case</span> &lt;-session.Context().Done():<br>log.Println(<span class="hljs-string">&quot;cancel consumer&quot;</span>)<br><span class="hljs-keyword">break</span> EXIT<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用linux笔记</title>
    <link href="/2024/05/27/linux/linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/05/27/linux/linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Linux系统命令"><a href="#1、Linux系统命令" class="headerlink" title="1、Linux系统命令"></a>1、Linux系统命令</h1><h2 id="linux离线安装net-tools"><a href="#linux离线安装net-tools" class="headerlink" title="linux离线安装net-tools"></a>linux离线安装net-tools</h2><p>需镜像站下载工具离线包</p><p>rpm -Uvh net-tools-2.0-0.25.20131004git.el7.x86_64.rpm     #输入此命令进行安装</p><p>centos修改host文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">修改hosts文件<br><br>vim /etc/hosts<br>如：<br><br>127.0.0.1 http://www.baidu.com<br><br>修改完成后生效命令<br><br>/etc/init.d/network restart<br><br>nano /etc/ssh/sshd_config<br>ctl O<br>ctl X<br></code></pre></td></tr></table></figure><h2 id="查看机器是否虚拟化"><a href="#查看机器是否虚拟化" class="headerlink" title="查看机器是否虚拟化"></a>查看机器是否虚拟化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/cpuinfo |grep vmx<br><span class="hljs-comment"># 有输出为支持虚拟化</span><br></code></pre></td></tr></table></figure><h2 id="echo命令写入文件"><a href="#echo命令写入文件" class="headerlink" title="echo命令写入文件"></a>echo命令写入文件</h2><ul><li><p>echo内容 &gt;&gt; 文件 等价于末尾追加</p></li><li><p>echo内容 &gt; 文件 等价于清空原内容并重写</p></li><li><p>添加\n换行符可以实现多行写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;内容1\n内容2&quot; &gt;&gt; 文件<br></code></pre></td></tr></table></figure></li></ul><h2 id="sed命令写入"><a href="#sed命令写入" class="headerlink" title="sed命令写入"></a>sed命令写入</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle">向文件添加行:<br>sed -i <span class="hljs-string">&#x27;行号a 添加的内容&#x27;</span> 文件<br><br>例如在第一行添加:<br>sed -i <span class="hljs-string">&#x27;1a 添加的第一行&#x27;</span> <span class="hljs-keyword">file</span><br><br>替换文件内容:<br>sed -i <span class="hljs-string">&#x27;s/old/new/g&#x27;</span> <span class="hljs-keyword">file</span><br><br>删除文件某一行:<br>sed -i <span class="hljs-string">&#x27;行号d&#x27;</span> <span class="hljs-keyword">file</span><br><br>将命令输出写入文件:<br>command | sed <span class="hljs-string">&#x27;脚本&#x27;</span> &gt; <span class="hljs-keyword">file</span><br><br>将文件内容输出到其他文件:<br>sed <span class="hljs-string">&#x27;脚本&#x27;</span> <span class="hljs-keyword">file</span> &gt; new_file<br><br>直接写入文件不读入:<br>sed -i <span class="hljs-string">&#x27;写入指令&#x27;</span> <span class="hljs-keyword">file</span><br><br>例如在文件最后一行添加内容:<br><br>sed -i <span class="hljs-string">&#x27;$a 新内容&#x27;</span> <span class="hljs-keyword">file</span><br>例如<br>sed -i <span class="hljs-string">&#x27;s/192.168.0.102/192.168.0.195/g&#x27;</span> <span class="hljs-regexp">/home/</span><span class="hljs-keyword">super</span><span class="hljs-regexp">/superdraw-v23.11.0/</span>datahub<span class="hljs-regexp">/tools/</span>setup_superdraw.sh<br><br>创建新文件并写入内容<br>如果文件不存在就新建:<br><br>sed -i <span class="hljs-string">&#x27;1i\content&#x27;</span> new_file<br><br>替换/修改指定行内容<br>例如替换第<span class="hljs-number">5</span>行内容:<br><br>sed -i <span class="hljs-string">&#x27;5c\replaced line&#x27;</span> <span class="hljs-keyword">file</span># replaced line 为要替换的内容<br></code></pre></td></tr></table></figure><h2 id="修改ip"><a href="#修改ip" class="headerlink" title="修改ip"></a>修改ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim /etc/sysconfig/network-scripts/ifcfg-网卡名</span><br>我们需要修改BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span>也就是将dhcp改为static，<br><br>修改ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> 意思是将网卡设置 为开机启用，<br><br>同时在文字下方添加<br><br>IPADDR=192.168.0.230 <span class="hljs-comment">#</span><br>静态IP  <br><br>GATEWAY=192.168.0.1 <span class="hljs-comment">#默认网关  </span><br><br>NETMASK=255.255.255.0 <span class="hljs-comment">#子网掩码  </span><br><br>DNS1=192.168.0.1 <span class="hljs-comment">#DNS 配置  </span><br><br>DNS2=8.8.8.8        <span class="hljs-comment">#谷歌地址</span><br>重启网卡<br>systemctl restart NetworkManager.service<br></code></pre></td></tr></table></figure><h2 id="获取公网ip"><a href="#获取公网ip" class="headerlink" title="获取公网ip"></a>获取公网ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux 命令：curl cip.cc<br></code></pre></td></tr></table></figure><h2 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown [选项] 时间 [警告信息]<br>选项:<br>-c：取消已经执行的 shutdown 命令；<br>-h：关机；<br>-r：重启；<br></code></pre></td></tr></table></figure><h2 id="查看目录文件大小"><a href="#查看目录文件大小" class="headerlink" title="查看目录文件大小"></a>查看目录文件大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看当前文件目录各个文件夹大小<br><span class="hljs-built_in">du</span> -h --max-depth=1<br><span class="hljs-comment">#查看指定目录  du -h --max-depth=1 /path</span><br>2、查看当前目录下所有目录及子目录大小<br><span class="hljs-built_in">du</span> -h - .<br>“.”代表当前目录下。也可以换成一个明确的路径<br><br>-h表示用K、M、G的人性化形式显示<br>Filesystem：文件系统<br>Size： 分区大小<br>Used： 已使用容量<br>Avail： 还可以使用的容量<br>Use%： 已用百分比<br>Mounted on： 挂载点　<br>相关命令：<br><br><span class="hljs-built_in">df</span> -hl：查看磁盘剩余空间<br><span class="hljs-built_in">df</span> -h：查看每个根路径的分区大小<br><span class="hljs-built_in">du</span> -sh [目录名]：返回该目录的大小<br><span class="hljs-built_in">du</span> -sm [文件夹]：返回该文件夹总M数<br><span class="hljs-built_in">du</span> -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）<br><br>查看系统日志配置文件<br><span class="hljs-built_in">cat</span> /etc/rsyslog.conf<br></code></pre></td></tr></table></figure><h2 id="查找文件或者目录"><a href="#查找文件或者目录" class="headerlink" title="查找文件或者目录"></a>查找文件或者目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找目录下是否包含某个目录</span><br>find /path/to/directory -type d -name &quot;directory_name&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查找目录下是否包含某个文件</span><br>find /path/to/directory -type f -name &quot;file_name&quot;<br><br></code></pre></td></tr></table></figure><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">启动防火墙： systemctl start firewalld<br>查看防火墙状态： systemctl status firewalld<br>停止防火墙： systemctl stop firewalld<br>禁用防火墙： systemctl <span class="hljs-built_in">disable</span> firewalld<br>查看已经开放的端口 firewall-cmd --list-ports<br><br>开启指定端口（需 systemctl reload firewalld）<br>firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent<br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br><br>--zone=&lt;zone&gt; <span class="hljs-comment"># 指定 zone</span><br>--add-port=&lt;portid&gt;]/&lt;protocol&gt; <span class="hljs-comment"># 端口id / 协议</span><br>--permanent <span class="hljs-comment"># 永久开启，不添加则重启失效</span><br><br>关闭指定端口（需 systemctl reload firewalld）<br>firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent<br>firewall-cmd --zone=public –remove-port=80/tcp --permanent<br></code></pre></td></tr></table></figure><p>centos scp传输命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ./code.tar.gz root@192.168.5.16:/root/laozhao/<br>SA V3.1.1.0323-Release<br></code></pre></td></tr></table></figure><h2 id="tar使用命令"><a href="#tar使用命令" class="headerlink" title="tar使用命令"></a>tar使用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar x[z|J]f SMC-V1.0.0-2021xxxxxx-linux-x86_64-singleton.tar.[gz|xz]<br>不同格式压缩包使用不同命令参数解压，gz 格式使用 xzf 参数解压，xz 格式使用 xJf 参数解压<br></code></pre></td></tr></table></figure><h2 id="Centos7性能查看"><a href="#Centos7性能查看" class="headerlink" title="Centos7性能查看"></a>Centos7性能查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux CPU大小<br><span class="hljs-built_in">cat</span> /proc/cpuinfo |grep <span class="hljs-string">&quot;model name&quot;</span> &amp;&amp; <span class="hljs-built_in">cat</span> /proc/cpuinfo |grep <span class="hljs-string">&quot;physical id&quot;</span><br>或者 lscpu<br>内存大小<br><span class="hljs-built_in">cat</span> /proc/meminfo |grep MemTotal或者（free -m  total显示总内存 ）<br>硬盘大小<br>fdisk -l |grep Disk<br></code></pre></td></tr></table></figure><h2 id="centos7查看系统版本"><a href="#centos7查看系统版本" class="headerlink" title="centos7查看系统版本"></a>centos7查看系统版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/redhat-release<br></code></pre></td></tr></table></figure><h2 id="centos7查看进程占用端口"><a href="#centos7查看进程占用端口" class="headerlink" title="centos7查看进程占用端口"></a>centos7查看进程占用端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"> netstat -tunlp | grep 端口号<br> <span class="hljs-comment">#t：表示查看tcp</span><br> <span class="hljs-comment">#u：表示查看udp</span><br> <span class="hljs-comment">#p：表示占用端口的进程</span><br> <span class="hljs-comment">#n：表示端口以数字形式表示，没有n直接显示服务名</span><br> <span class="hljs-comment">#l：表示显示所监听的端口</span><br><br>查看所有tcp连接包括LISTEN状态<br><span class="hljs-comment"># netstat -an |grep tcp</span><br></code></pre></td></tr></table></figure><h2 id="yum安装卡住"><a href="#yum安装卡住" class="headerlink" title="yum安装卡住"></a>yum安装卡住</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br>yum makecache  <span class="hljs-comment">#卡住等待运行完</span><br>yum update<br></code></pre></td></tr></table></figure><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 安装tcpdump工具<br>rpm -ql tcpdump　　　　　　　　　　<span class="hljs-comment">#查看tcpdump是否安装</span><br>yum install tcpdump -y<br>2.  tcpdump抓包<br>根据协议和端口抓包<br>tcpdump -i eth0 udp port 694 -n　　　　　　　　　　　　　 <span class="hljs-comment">#-i指定网卡信息  udp协议</span><br>tcpdump -i eth0 tcp  port 8088 -n　　  　　　　　　　　　　 <span class="hljs-comment">#port 8088端口   tcp协议</span><br>tcpdump -i eth0 port 8088 -c 3 -t -w /tmp/tcpdump.pcap　　　<span class="hljs-comment">#-c指定抓包数量   -t不显示时间戳  -w指定存放路径　</span><br>根据主机抓包<br>tcpdump host 192.168.0.204 and 192.168.0.205　　　　　　<span class="hljs-comment">#两台主机之间通信抓包</span><br></code></pre></td></tr></table></figure><h2 id="linux-下查看网卡流量"><a href="#linux-下查看网卡流量" class="headerlink" title="linux 下查看网卡流量"></a>linux 下查看网卡流量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#yum install -y iftop </span><br>iftop -i 网卡名<br></code></pre></td></tr></table></figure><p>centos7配置清华源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">备份原文件<br>sudo sed -e <span class="hljs-string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \<br>         -e <span class="hljs-string">&#x27;s|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g&#x27;</span> \<br>         -i.bak \<br>         /etc/yum.repos.d/CentOS-*.repo<br>sudo yum clean all<br>sudo yum makecache<br>yum update<br></code></pre></td></tr></table></figure><h2 id="Debian12配置清华源"><a href="#Debian12配置清华源" class="headerlink" title="Debian12配置清华源"></a>Debian12配置清华源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.back<span class="hljs-comment"># 备份文件</span><br><br><span class="hljs-built_in">cat</span> &gt; /etc/apt/sources.list &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware </span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware</span><br><span class="hljs-string">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h2 id="清理所有相关进程"><a href="#清理所有相关进程" class="headerlink" title="清理所有相关进程"></a>清理所有相关进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep benthos* | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span> -9   <span class="hljs-comment"># benthos* 进程名</span><br></code></pre></td></tr></table></figure><h2 id="Debian12系统打包软件离线包"><a href="#Debian12系统打包软件离线包" class="headerlink" title="Debian12系统打包软件离线包"></a>Debian12系统打包软件离线包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打包</span><br>mkdir packages &amp;&amp; cd packages<br>apt download vim iftop sudo telnet -d   # 会在packages目录下生成deb离线包，拷贝到别的服务器<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>dpkg -i *.deb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现实情况 需要将某台安装好的服务器上的软件包全部打包</span><br>cd /var/cache/apt/archives<br>tar -czvf archives.tar.gz archives/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">上传安装</span><br>dpkg -i *.deb<br></code></pre></td></tr></table></figure><h2 id="ubuntu-资源监视器"><a href="#ubuntu-资源监视器" class="headerlink" title="ubuntu 资源监视器"></a>ubuntu 资源监视器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gnome-system-monitor<br></code></pre></td></tr></table></figure><h2 id="linux建立软连接"><a href="#linux建立软连接" class="headerlink" title="linux建立软连接"></a>linux建立软连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s 源文件 目标连接<br></code></pre></td></tr></table></figure><h1 id="2、centos下安装mysql数据库"><a href="#2、centos下安装mysql数据库" class="headerlink" title="2、centos下安装mysql数据库"></a>2、centos下安装mysql数据库</h1><h2 id="1、添加MariaDB的repo源："><a href="#1、添加MariaDB的repo源：" class="headerlink" title="1、添加MariaDB的repo源："></a>1、添加MariaDB的repo源：</h2><p>进入&#x2F;etc&#x2F;yum.repos.d下，添加CentOS-MariaDB.repo文件，其中添加内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># MariaDB 10.3 CentOS repository list - created 2018-05-26 07:55 UTC</span><br><span class="hljs-comment"># http://downloads.mariadb.org/mariadb/repositories/</span><br>[mariadb]<br>name = MariaDB<br>baseurl = http://yum.mariadb.org/10.3/centos7-amd64<br>gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB<br>gpgcheck=1<br><span class="hljs-comment"># 卸载mariadb仓库</span><br>rpm -qa | grep mariadb<br>rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64<br></code></pre></td></tr></table></figure><h2 id="2、清除Yum的缓存并重新建立"><a href="#2、清除Yum的缓存并重新建立" class="headerlink" title="2、清除Yum的缓存并重新建立"></a>2、清除Yum的缓存并重新建立</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure><h2 id="3、打印MariaDB源中的软件包："><a href="#3、打印MariaDB源中的软件包：" class="headerlink" title="3、打印MariaDB源中的软件包："></a>3、打印MariaDB源中的软件包：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list --disablerepo=\* --enablerepo=mariadb<br><br><span class="hljs-built_in">test</span>为测试工具，backup为备份工具<br></code></pre></td></tr></table></figure><h2 id="4、安装MariaDB数据库："><a href="#4、安装MariaDB数据库：" class="headerlink" title="4、安装MariaDB数据库："></a>4、安装MariaDB数据库：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install MariaDB-client MariaDB-server MariaDB-devel -y<br></code></pre></td></tr></table></figure><h2 id="5、启动数据库并设置为开机自启"><a href="#5、启动数据库并设置为开机自启" class="headerlink" title="5、启动数据库并设置为开机自启"></a>5、启动数据库并设置为开机自启</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、启动maria DB服务:<br><span class="hljs-comment"># systemctl start mariadb.service</span><br>2、添加至开机自启动：<br><span class="hljs-comment"># systemctl enable mariadb.service</span><br>3、查看数据库状态<br><span class="hljs-comment"># systemctl status mariadb</span><br></code></pre></td></tr></table></figure><h2 id="6、初始化数据库，并删除测试数据库及更改权限和设置密码"><a href="#6、初始化数据库，并删除测试数据库及更改权限和设置密码" class="headerlink" title="6、初始化数据库，并删除测试数据库及更改权限和设置密码"></a>6、初始化数据库，并删除测试数据库及更改权限和设置密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">初始化数据库配置<br><br>mysql_secure_installation<br><br>首先是设置密码，会提示先输入密码：<br><br>设置密码<br><br>Enter current password <span class="hljs-keyword">for</span> root (enter <span class="hljs-keyword">for</span> none):&lt;–直接回车<br><br>Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车<br>New password: &lt;– 设置root用户的密码<br>Re-enter new password: &lt;– 再输入一次你设置的密码<br>其他配置<br><br>Remove anonymous <span class="hljs-built_in">users</span>? [Y/n] &lt;– 是否删除匿名用户，Y回车<br><br>Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录, N回车,<br><br>Remove <span class="hljs-built_in">test</span> database and access to it? [Y/n] &lt;– 是否删除<span class="hljs-built_in">test</span>数据库，Y回车<br><br>Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，Y回车<br><br>初始化MariaDB完成，接下来测试本地登录。<br><br></code></pre></td></tr></table></figure><h3 id="7-检查是否启动成功"><a href="#7-检查是否启动成功" class="headerlink" title="7.检查是否启动成功"></a>7.检查是否启动成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysqld.service<br></code></pre></td></tr></table></figure><h3 id="8-通过密码登录，进行修改密码操作-可不操作"><a href="#8-通过密码登录，进行修改密码操作-可不操作" class="headerlink" title="8.通过密码登录，进行修改密码操作(可不操作)"></a>8.通过密码登录，进行修改密码操作(可不操作)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;super000&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="9-授权其他机器远程登录"><a href="#9-授权其他机器远程登录" class="headerlink" title="9.授权其他机器远程登录"></a>9.授权其他机器远程登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRANT ALL PRIVILEGES ON *.* TO <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;super000&#x27;</span> WITH GRANT OPTION;<br> <br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="10、连接数据库，并查询版本"><a href="#10、连接数据库，并查询版本" class="headerlink" title="10、连接数据库，并查询版本"></a>10、连接数据库，并查询版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p -A<br><br>其中-u制定用户，-p使用密码，-A为不预先读取数据库。<br><br>MariaDB [(none)]&gt; <span class="hljs-keyword">select</span> version();<br>+-----------------+<br>| version()       |<br>+-----------------+<br>| 10.3.32-MariaDB |<br>+-----------------+<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.000 sec)<br><br>show full processlist;<br>可查看当前用户，及登陆地址，选择的数据库，数据库引擎。<br><br></code></pre></td></tr></table></figure><h3 id="11-设置Mariadb的字符集为UTF-8，令其支持中文"><a href="#11-设置Mariadb的字符集为UTF-8，令其支持中文" class="headerlink" title="11.设置Mariadb的字符集为UTF-8，令其支持中文"></a>11.设置Mariadb的字符集为UTF-8，令其支持中文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.查看当前编码：<br>show variables like <span class="hljs-string">&#x27;character%&#x27;</span>; <br>show variables like <span class="hljs-string">&#x27;collation%&#x27;</span>;<br>2.退出数据库（<span class="hljs-built_in">exit</span>），<br>3.修改配置文件 vim /etc/my.cnf.d/server.cnf<br>在mysqld下添加 character-set-server = utf8<br>              collation-server = utf8_general_ci<br>              skip-character-set-client-handshake<br>              注意去掉前面的<span class="hljs-comment">#号</span><br>4.重启 数据库 systemctl restart mariadb<br>5.进入数据库 mysql -uroot -p<br>6.查看字符集编码<br></code></pre></td></tr></table></figure><h3 id="12-防火墙开放3306端口"><a href="#12-防火墙开放3306端口" class="headerlink" title="12.防火墙开放3306端口"></a>12.防火墙开放3306端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --state<br>firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>firewall-cmd --zone=public --add-port=80-90/tcp --permanent   <span class="hljs-comment">#作用域是public，批量开放tcp协议的80-90端口，一直有效</span><br>firewall-cmd --zone=public --add-port=80/tcp --add-port=90/tcp --permanent  <span class="hljs-comment">#作用域是public，批量开放tcp协议的80、90端口，一直有效</span><br>firewall-cmd --zone=public --add-service=http --permanent <span class="hljs-comment">#开放的服务是http协议，一直有效</span><br>firewall-cmd --reload<br><br>停止防火墙： systemctl stop firewalld<br>禁用防火墙： systemctl <span class="hljs-built_in">disable</span> firewalld<br></code></pre></td></tr></table></figure><h3 id="13-数据库的操作"><a href="#13-数据库的操作" class="headerlink" title="13.数据库的操作"></a>13.<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>的操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）查看mysql是否启动：service mariadb status<br><br>启动mysql：systemctl start mariadb<br><br>停止mysql：systemctl stop mariadb<br><br>重启mysql：systemctl restart mariadb<br><br>（2）查看数据库版本 mysql -V<br></code></pre></td></tr></table></figure><h2 id="7-JDK配置"><a href="#7-JDK配置" class="headerlink" title="7 JDK配置"></a>7 JDK配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看服务器上是否有Java安装包</span><br>rpm -qa | grep java<br><br><span class="hljs-comment"># 查看Linux系统是否有自带的jdk</span><br>java -version<br><br><span class="hljs-comment"># 上传安装包 解压，配置/etc/profile</span><br>tar -xzvf jdk-11.0.1_linux-x64_bin.tar.gz<br>[root@ecs-dc44 data]<span class="hljs-comment"># cd jdk-11.0.1</span><br>[root@ecs-dc44 jdk-11.0.1]<span class="hljs-comment"># pwd</span><br>/data/jdk-11.0.1<br><br><span class="hljs-comment"># 配置文件路径</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/data/jdk-11.0.1<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib/dt.jar:<span class="hljs-variable">$JAVA_HOME</span>/lib/tools.jar<br><br><span class="hljs-comment"># 刷新</span><br><span class="hljs-built_in">source</span> /etc/profile<br><br></code></pre></td></tr></table></figure><h1 id="3、Linux下安装python3"><a href="#3、Linux下安装python3" class="headerlink" title="3、Linux下安装python3"></a>3、Linux下安装python3</h1><h3 id="1、依赖安装"><a href="#1、依赖安装" class="headerlink" title="1、依赖安装"></a>1、依赖安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc是一个用于linux系统下编程的编译器，由于python3需要编译安装，因此，需要首先安装gcc。先查看一下系统中，是否安装了gcc。<br><span class="hljs-comment"># gcc -version</span><br>未安装需要安装<br><span class="hljs-comment"># yum -y install gcc</span><br>编译安装python3过程中，根据系统本身的依赖，可能出现的不同的报错信息。提前按照好依赖包<br>yum -y install zlib* libffi-devel openssl-devel wget<br></code></pre></td></tr></table></figure><h3 id="2-python3-下载"><a href="#2-python3-下载" class="headerlink" title="2 python3 下载"></a>2 python3 下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cd ~ </span><br><span class="hljs-comment"># wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="hljs-comment"># wget https://www.python.org/ftp/python/3.9.9/Python-3.9.9.tgz</span><br></code></pre></td></tr></table></figure><h3 id="3-python3编译安装"><a href="#3-python3编译安装" class="headerlink" title="3 python3编译安装"></a>3 python3编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压下载的python3压缩包<br><span class="hljs-comment"># tar -zxvf Python-3.7.0.tgz</span><br>新建一个python3的安装目录(位置可自定义)<br><span class="hljs-comment"># mkdir /usr/lib/python3.7</span><br>进入Python-3.7.0目录下，「指定安装目录，设置启用ssl功能<br><span class="hljs-comment"># cd Python-3.7.0</span><br>./configure --prefix=/usr/lib/python3.7 --with-ssl<br>编译安装<br><span class="hljs-comment"># make &amp;&amp; make install</span><br></code></pre></td></tr></table></figure><h3 id="4创建软连接"><a href="#4创建软连接" class="headerlink" title="4创建软连接"></a>4创建软连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">上述步骤完成后，其实python3已经安装完毕，但是为了方便使用，一般会创建python3和pip3的软连接。创建后可直接在终端通过python命令进入python和pip3命令安装python包<br><br>创建python3和pip3软连接：<br><span class="hljs-comment"># ln -s /usr/lib/python3.7/bin/python3.7 /usr/bin/python3</span><br><span class="hljs-comment"># ln -s /usr/lib/python3.7/bin/pip3.7 /usr/bin/pip3</span><br><span class="hljs-comment"># ln -s /usr/bin/pip3 /usr/bin/pip</span><br><br>系统默认的python软连接指向的是python2，如果我们需要更方便使用，可以删除原有的python软连接，并建立新的python软连接指向python3<br><br><span class="hljs-comment"># rm -f /usr/bin/python</span><br><span class="hljs-comment"># ln -s /usr/bin/python3 /usr/bin/python</span><br><br>查看最新的有python的软连接<br><span class="hljs-comment"># python --version</span><br></code></pre></td></tr></table></figure><h3 id="5修改yum配置"><a href="#5修改yum配置" class="headerlink" title="5修改yum配置"></a>5修改yum配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">修改yum配置文件，下面两个文件都要修改<br><span class="hljs-comment"># vi /usr/bin/yum</span><br><span class="hljs-comment"># vi /usr/libexec/urlgrabber-ext-down</span><br>按i进入编辑模式，在第一行<span class="hljs-comment">#!/usr/bin/python把修改为#!/usr/bin/python2.7</span><br></code></pre></td></tr></table></figure><h3 id="6联网快速安装方法"><a href="#6联网快速安装方法" class="headerlink" title="6联网快速安装方法"></a>6联网快速安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">3、安装Python3：（此方法默认为3.6，无法安装3.7）<br>yum install python3 -y<br>yum -y install epel-release<br>yum -y install python-pip<br><br>备份旧的Python的默认执行程序　　<br><span class="hljs-built_in">mv</span> /usr/bin/python /usr/bin/python.bak.$(<span class="hljs-built_in">date</span> +%F).$(<span class="hljs-built_in">date</span> +%R)<br>使用Python3软链接替代Python默认执行程序　　<br><span class="hljs-built_in">ln</span> -s /usr/bin/python3 /usr/bin/python<br><br>修改以下文件的开头第一行内容，把python改成python2.7(不修改yum命令无法使用)<br><br>/usr/bin/yum<br>/usr/libexec/urlgrabber-ext-down<br>/usr/bin/yum-config-manager<br>查看Python替换正常，且yum可用　　<br>yum --version<br>python --version<br><br>卸载python3.6.x<br><br>rpm -qa|grep python3|xargs rpm -ev --allmatches --nodeps<br>whereis python3 |xargs <span class="hljs-built_in">rm</span> -frv<br></code></pre></td></tr></table></figure><h1 id="4、linux-自带python-搭建http服务"><a href="#4、linux-自带python-搭建http服务" class="headerlink" title="4、linux 自带python 搭建http服务"></a>4、linux 自带python 搭建http服务</h1><h2 id="1、版本说明（内置库）"><a href="#1、版本说明（内置库）" class="headerlink" title="1、版本说明（内置库）"></a>1、版本说明（内置库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">如果python版本为2.x，输入命令：<br><br>python -m SimpleHTTPServer 8000<br><br>（8000为端口号，如果不指定则默认8000端口）<br><br><span class="hljs-comment">######################################</span><br><br>如果python版本为3.x，输入命令：<br><br>python -m http.server 8000<br><br>（8000为端口号，如果不指定则默认8000端口）<br><br>默认位当前目录<br></code></pre></td></tr></table></figure><h2 id="2、配置后台关闭bash窗口运行"><a href="#2、配置后台关闭bash窗口运行" class="headerlink" title="2、配置后台关闭bash窗口运行"></a>2、配置后台关闭bash窗口运行</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nohup python -m SimpleHTTPServer 8000 &amp;    #python2.0<br><br>nohup python -m http.server 8000 &amp;# python3.0<br><br>在命令的开头加一个nohup，忽略所有的挂断信号，如果当前bash关闭，则当前进程会挂载到init进程下，成为其子进程，这样即使退出当前用户，其8000端口也可以使用<br>在上述命令的最后加一个 &amp; ，则该命令产生的进程在后台运行，不会影响当前终端的使用（我们在只有一个bash的环境下）<br><br>配置sh脚本<br>nohup python -m SimpleHTTPServer 8080 &gt;/home/httplog/http.log 2&gt;&amp;1 &amp;  # /home/httplog/http.log为输出文件日志路径<br></code></pre></td></tr></table></figure><h1 id="5、xshell代理服务器连接"><a href="#5、xshell代理服务器连接" class="headerlink" title="5、xshell代理服务器连接"></a>5、xshell代理服务器连接</h1><h2 id="5、1-window设置"><a href="#5、1-window设置" class="headerlink" title="5、1 window设置"></a>5、1 window设置</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">1、本地下載openSSH，根据代理服务器的环境下载<br>下载地址：https://github.com/PowerShell/Win32-OpenSSH/releases<br>2、下载完毕解压安装<br>以管理员身份cmd进入解压目录下，执行<br>powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1<br>3、防火墙高级设置里面添加22端口的tcp入站规则<br>4、系统服务里面启动openSSH相关服务<br></code></pre></td></tr></table></figure><h2 id="5-2-xshell隧道代理设置"><a href="#5-2-xshell隧道代理设置" class="headerlink" title="5.2  xshell隧道代理设置"></a>5.2  xshell隧道代理设置</h2><h3 id="5-2-1-建立跳板机连接"><a href="#5-2-1-建立跳板机连接" class="headerlink" title="5.2.1 建立跳板机连接"></a>5.2.1 建立跳板机连接</h3><p>首先建立跳板机的连接，并配置隧道。打开<a href="https://so.csdn.net/so/search?q=XShell&spm=1001.2101.3001.7020">XShell</a>点击文件菜单再点击新建弹出新建会话属性窗口，名称就取为跳板机，端口是22，主机填写前面假设的ip地址。如下图所示：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071154535.png" alt="image-20220630163450501"></p><h3 id="5-2-2-填写跳板机用户名密码"><a href="#5-2-2-填写跳板机用户名密码" class="headerlink" title="5.2.2 填写跳板机用户名密码"></a>5.2.2 填写跳板机用户名密码</h3><p>点击用户身份验证，填写登录跳板机的<a href="https://so.csdn.net/so/search?q=SSH&spm=1001.2101.3001.7020">SSH</a>用户名和密码如下图所示：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071155281.png" alt="image-20220630163646503"></p><h3 id="5-2-3-防止跳板机连接过久自动断开"><a href="#5-2-3-防止跳板机连接过久自动断开" class="headerlink" title="5.2.3 防止跳板机连接过久自动断开"></a>5.2.3 防止跳板机连接过久自动断开</h3><p>为防止跳板机连接过久自动断开，所以这里添加登录脚本直接发送top命令。点击登录脚本，勾选上执行以下等待并发送规则，点击添加弹出等待发送规则添加窗口，在发送框填写top。具体配置看图：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071155510.png" alt="image-20220630163747497"></p><h3 id="5-2-4-配置内网隧道"><a href="#5-2-4-配置内网隧道" class="headerlink" title="5.2.4 配置内网隧道"></a>5.2.4 <strong>配置内网隧道</strong></h3><p>接下来继续配置连接内网服务器的隧道，点击隧道再点击添加按钮进入隧道添加页面，源主机为本机localhost，侦听端口可以在有效范围内随便填写，这里为了区分连接内网哪台服务器，所以用内网服务器ip最后一位加22即522作为侦听端口。目标主机就是我们要通过跳板机访问的内网主机，端口是22。同样的操作再配置一个连接192.168.100.6的隧道，端口不能与522冲突，按刚才的规则可以用622端口。具体配置如下图：</p><p><img src="https://typrao-mhd.oss-cn-hangzhou.aliyuncs.com/picture/202306071157969.png" alt="image-20220630163839280"></p><h3 id="5-2-5-登录跳板机并连接内网服务器"><a href="#5-2-5-登录跳板机并连接内网服务器" class="headerlink" title="5.2.5 登录跳板机并连接内网服务器"></a>5.2.5 <strong>登录跳板机并连接内网服务器</strong></h3><p>到此跳板机的配置已经完成了，下面来建立通过跳板机登录内网服务器的连接会话，首先还是进入新建会话属性窗口，注意一下这次的配置，主机为localhost，侦听端口为刚才的522，即这个配置连接之后是访问内网的192.168.100.5服务器</p><h1 id="6、允许以root用户登录操作系统"><a href="#6、允许以root用户登录操作系统" class="headerlink" title="6、允许以root用户登录操作系统"></a>6、<strong>允许以root用户登录操作系统</strong></h1><h3 id="6-1-修改-etc-gdm3-daemon-conf文件"><a href="#6-1-修改-etc-gdm3-daemon-conf文件" class="headerlink" title="6.1 修改&#x2F;etc&#x2F;gdm3&#x2F;daemon.conf文件"></a>6.1 修改&#x2F;etc&#x2F;gdm3&#x2F;daemon.conf文件</h3><p>新增下面一行AllowRoot &#x3D; true</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">[security]<br> <br>AllowRoot = true<br></code></pre></td></tr></table></figure><h4 id="6-2修改-etc-pam-d-gdm-password"><a href="#6-2修改-etc-pam-d-gdm-password" class="headerlink" title="6.2修改&#x2F;etc&#x2F;pam.d&#x2F;gdm-password"></a>6.2修改&#x2F;etc&#x2F;pam.d&#x2F;gdm-password</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">注释掉下面内容<br><br><span class="hljs-params">#</span>auth required pam<span class="hljs-built_in">_</span>succeed<span class="hljs-built_in">_</span>if.so user != root quiet<span class="hljs-built_in">_</span>success<br></code></pre></td></tr></table></figure><h3 id="6-3修改-etc-ssh-sshd-config"><a href="#6-3修改-etc-ssh-sshd-config" class="headerlink" title="6.3修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config"></a>6.3修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config</h3><p>将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin prohibit-password<br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h1 id="7、linux格式化硬盘-挂载"><a href="#7、linux格式化硬盘-挂载" class="headerlink" title="7、linux格式化硬盘 挂载"></a>7、linux格式化硬盘 挂载</h1><h2 id="1、查看硬盘信息"><a href="#1、查看硬盘信息" class="headerlink" title="1、查看硬盘信息"></a>1、查看硬盘信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># fdisk -l</span><br><br>Disk /dev/sda: 146.1 GB, 146163105792 bytes<br><br>255 heads, 63 sectors/track, 17769 cylinders<br><br>Units = cylinders of 16065 * 512 = 8225280 bytes<br><br>    Device Boot       Start          End       Blocks    Id   System<br><br>/dev/sda1    *            1           13       104391    83   Linux<br><br>/dev/sda2               14         5112     40957717+   83   Linux<br><br>/dev/sda3             5113         5243      1052257+   82   Linux swap /<br><br>Solaris<br><br>/dev/sda4             5244        17769    100615095     5   Extended<br><br>/dev/sda5             5244        17769    100615063+   83   Linux<br><br>Disk /dev/sdb: 291.3 GB, 291331192320 bytes<br><br>255 heads, 63 sectors/track, 17769 cylinders<br><br>Units = cylinders of 16065 * 512 = 8225280 bytes<br><br>Disk /dev/sdb1: 291.3 GB, 291331192320 bytes<br></code></pre></td></tr></table></figure><h2 id="2、创建新硬盘分区"><a href="#2、创建新硬盘分区" class="headerlink" title="2、创建新硬盘分区"></a>2、创建新硬盘分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk可以用m命令来看fdisk命令的内部命令；<br><br>a：命令指定启动分区；<br><br>d：命令删除一个存在的分区；<br><br>l：命令显示分区ID号的列表；<br><br>m：查看fdisk命令帮助；<br><br>n：命令创建一个新分区；<br><br>p：命令显示分区列表；<br><br>t：命令修改分区的类型ID号；<br><br>w：命令是将对分区表的修改存盘让它发生作用。<br><br> <span class="hljs-comment">#fdisk /dev/sdb</span><br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):n<br><br>Command action<br><br>　　   e    extended    //输入e为创建扩展分区<br><br>　　   p    primary partition (1-4)<br><br>Partion number(1-4)：1<br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w<br><br>输入n回车，再输入p回车，再输出1回车，一路回车，最后输入w回车保存。<br><br>查看一下：<br><br>fdisk -l<br><br>可以看到/dev/sdb1分区<br></code></pre></td></tr></table></figure><h2 id="3、格式化分区"><a href="#3、格式化分区" class="headerlink" title="3、格式化分区"></a>3、格式化分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext3 /dev/sdb1<br></code></pre></td></tr></table></figure><h2 id="4、创建-data1目录："><a href="#4、创建-data1目录：" class="headerlink" title="4、创建&#x2F;data1目录："></a>4、创建&#x2F;data1目录：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /data1<br></code></pre></td></tr></table></figure><h2 id="5、挂载分区"><a href="#5、挂载分区" class="headerlink" title="5、挂载分区"></a>5、挂载分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/sdb1 /data1<br></code></pre></td></tr></table></figure><h2 id="6、配置开机自动挂载"><a href="#6、配置开机自动挂载" class="headerlink" title="6、配置开机自动挂载"></a>6、配置开机自动挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为mount挂载在重启服务器后会失效，所以需要将分区信息写到/etc/fstab文件中让它永久挂载：<br><br>vi /etc/fstab<br><br>加入：<br><br>LABEL=/data1             /data1                   ext3     defaults         1 2<br><br>查看<span class="hljs-built_in">cat</span> /etc/fstab<br><br>LABEL=/                  /                        ext3     defaults         1 1<br><br>LABEL=/data              /data                    ext3     defaults         1 2<br><br>LABEL=/data1             /data1                   ext3     defaults         1 2<br><br>LABEL=/boot              /boot                    ext3     defaults         1 2<br><br>tmpfs                    /dev/shm                 tmpfs    defaults         0 0<br><br>devpts                   /dev/pts                 devpts   gid=5,mode=620   0 0<br><br>sysfs                    /sys                     sysfs    defaults         0 0<br><br>proc                     /proc                    proc     defaults         0 0<br><br>LABEL=SWAP-hda3          swap                     swap     defaults         0 0<br><br>重启系统<br></code></pre></td></tr></table></figure><h1 id="8-openssl生成证书文件"><a href="#8-openssl生成证书文件" class="headerlink" title="8 openssl生成证书文件"></a>8 openssl生成证书文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">签署证书时不能直接绑定 IP 地址，因为证书是用于确认域名的身份，而不是特定的 IP 地址。<br><br>但是，您可以通过使用证书中的 SAN（Subject Alternative Name）扩展来绑定多个域名和 IP 地址。例如，您可以在生成 CSR 文件时使用以下命令：<br><br>openssl req -newkey rsa:2048 -nodes -keyout mykey.key -out mycsr.csr -subj <span class="hljs-string">&quot;/C=US/ST=California/L=San Francisco/O=Example Inc./CN=example.com/subjectAltName=DNS:example.com,IP:0.0.0.0&quot;</span><br><br>以上命令会生成一个包含以下内容的 CSR 文件：<br><br>    主域名：example.com<br>    IP 地址：0.0.0.0<br><br>颁发机构将使用该 CSR 签署证书，并在证书中包括主域名和 IP 地址的信息。<br><br>使用 OpenSSL 生成 p12 格式证书并配置的详细示例：<br><br>    首先，生成一对私钥和证书请求文件：<br><br>openssl req -newkey rsa:2048 -nodes -keyout mykey.key -out mycsr.csr<br><br>    您需要输入一些信息，如国家、省份、城市、组织名称等，证书请求文件 mycsr.csr 将使用这些信息生成。<br><br>    使用私钥和证书请求文件生成证书：<br><br>openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> mycsr.csr -signkey mykey.key -out mycert.crt<br><br>    最后，使用证书和私钥生成 p12 格式证书：<br><br>openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> mycert.crt -inkey mykey.key -out mycert.p12<br><br>    您需要输入一个密码，该密码将用于保护 p12 证书的安全。请记住您输入的密码，因为您将需要在使用证书时输入该密码。<br>    <br> <br></code></pre></td></tr></table></figure><h1 id="9、conda使用"><a href="#9、conda使用" class="headerlink" title="9、conda使用"></a>9、conda使用</h1><h2 id="conda是一款软件管理工具"><a href="#conda是一款软件管理工具" class="headerlink" title="conda是一款软件管理工具"></a>conda是一款软件管理工具</h2><ul><li>miniconda 只包含了conda、python、和一些必备的软件工具</li><li>anaconda 包含了数据科学和机器学习要用到的很多软件</li></ul><p>常见开发使用miniconda即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh --no-check-certificate<br><span class="hljs-comment"># 下载minicoda -c参数提供端点续传</span><br>bash Miniconda3-latest-Linux-x86_64.sh <span class="hljs-comment">#执行脚本安装</span><br>conda init<span class="hljs-comment">#conda 初始化</span><br>conda create -n your_env_name python=3.9<span class="hljs-comment">#conda 创建虚拟环境</span><br>conda activate your_env_name<span class="hljs-comment">#conda激活虚拟环境</span><br>conda config --add envs_dirs newdir <span class="hljs-comment">#增加环境路径newdir</span><br>conda <span class="hljs-built_in">env</span> list<span class="hljs-comment">#查看有哪些虚拟路径以及它们的存储路径，* 号表示当前所处的环境</span><br>conda <span class="hljs-built_in">env</span> remove --name PySanic<span class="hljs-comment">#删除虚拟环境</span><br>deactivate<span class="hljs-comment"># 退出虚拟环境</span><br>conda update conda<span class="hljs-comment"># conda升级</span><br>conda config --show<span class="hljs-comment"># 显示配置信息</span><br><span class="hljs-comment">## 设置清华镜像源</span><br>sudo vim ~/.condarc<br><br>将以下内容覆盖’.codnarc’文件里面所有内容<br>channels:<br>  - defaults<br>show_channel_urls: <span class="hljs-literal">true</span><br>default_channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2<br>custom_channels:<br>  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/<br>  <br> <span class="hljs-comment"># 配置完清除索引缓存</span><br> conda clean -i<br><br><span class="hljs-comment"># 卸载Anaconda</span><br><span class="hljs-built_in">rm</span> -rf ~/anaconda3<br></code></pre></td></tr></table></figure><p><strong>关闭初始化conda</strong></p><p>查看配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">conda <span class="hljs-built_in">config</span> <span class="hljs-comment">--show | grep auto_activate_base</span><br></code></pre></td></tr></table></figure><p>关闭初始化</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">conda<span class="hljs-built_in"> config </span>--<span class="hljs-built_in">set</span> auto_activate_base <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="10-git使用"><a href="#10-git使用" class="headerlink" title="10 git使用"></a>10 git使用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch [branch name]#创建本地分支<br>git checkout [branch name]#切换到新分支<br>git checkout -b [branch name]#创建分支同时也切换分支<br>git stash # 暂存文件<br>git stash list # 查看stash了哪些存储<br>git stash apply stash@&#123;$num&#125;# 应用某个储存<br>git stash pop# 恢复缓存之前<br>git stash drop stash@&#123;$num&#125;# 丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储<br>git stash clear# 删除所有缓存的stash<br>git branch -d [branch-name]# 删除分支<br></code></pre></td></tr></table></figure><h1 id="11-安装docker"><a href="#11-安装docker" class="headerlink" title="11 安装docker"></a>11 安装docker</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安裝docker</span><br>yum install -y yum-utils device-mapper-persistent-data net-tools telnet<br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>yum -y install docker-ce.x86_64 <br>systemctl start docker <br>systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安裝docker-compose(上传docker-compose,移动到/usr/local/bin目录下，并授权)</span><br>mv docker-compose /usr/local/bin/<br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装docker-compose</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载最新docker-compose 保存到/usr/local/bin/docker-compose</span><br>sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">授权</span><br>sudo chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>sudo rm /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否有docker用户组</span><br>cat /etc/group ｜ grep docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有的话添加</span><br>sudo groupadd docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前用户到docker组</span><br>sudo usermod -aG docker $USER<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新用户组</span><br>newgrp docker                      <br></code></pre></td></tr></table></figure><h3 id="docker配置镜像加速方案"><a href="#docker配置镜像加速方案" class="headerlink" title="&#x3D;&#x3D;docker配置镜像加速方案&#x3D;&#x3D;"></a>&#x3D;&#x3D;docker配置镜像加速方案&#x3D;&#x3D;</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    &quot;registry-mirrors&quot;:[</span><br><span class="hljs-string">        &quot;https://docker.m.daocloud.io/&quot;,</span><br><span class="hljs-string">        &quot;https://dockerproxy.com/&quot;,</span><br><span class="hljs-string">        &quot;https://docker.mirrors.ustc.edu.cn/&quot;,</span><br><span class="hljs-string">        &quot;https://docker.nju.edu.cn/&quot;</span><br><span class="hljs-string">    ],</span><br><span class="hljs-string">    &quot;data-root&quot;:&quot;/home/dockerdate&quot;,</span><br><span class="hljs-string">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="hljs-string">    &quot;log-opts&quot;:&#123;</span><br><span class="hljs-string">        &quot;max-size&quot;:&quot;512m&quot;,&quot;max-file&quot;:&quot;3&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;&#x27;</span> | sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json<br><br></code></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart docker<br></code></pre></td></tr></table></figure><h1 id="12、Debian安装Wireshark"><a href="#12、Debian安装Wireshark" class="headerlink" title="12、Debian安装Wireshark"></a>12、Debian安装Wireshark</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.打开终端并以root用户身份登录。<br><br>2. 运行以下命令以添加Wireshark的软件源： <br>echo &quot;deb http://deb.debian.org/debian buster main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb-src http://deb.debian.org/debian buster main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb http://security.debian.org/debian-security buster/updates main&quot; &gt;&gt; /etc/apt/sources.list<br>echo &quot;deb-src http://security.debian.org/debian-security buster/updates main&quot; &gt;&gt; /etc/apt/sources.list <br><br>3. 更新软件包列表： apt-get update <br>4. 现在，您应该可以安装Wireshark了：  apt-get install wireshark tshark -y<br></code></pre></td></tr></table></figure><h1 id="13-Kafka命令"><a href="#13-Kafka命令" class="headerlink" title="13 Kafka命令"></a>13 Kafka命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、使用以下命令查看当前 Kafka 主题：<br>kafka-topics.sh --list --bootstrap-server localhost:9092<br>2、刪除主題<br>kafka-topics.sh --delete --bootstrap-server localhost:9092 --topic your_topic_name<br>3、创建主题<br>kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic my-topic<br><br>    --create：创建一个新主题。<br>    --bootstrap-server：指定要用于连接到 Kafka 集群的引导服务器地址。这应该是 Kafka 消息代理的主机名和端口号，例如 localhost:9092。<br>    --replication-factor：指定要为每个分区保留多少个副本。在生产环境中，通常将副本因子设置为 2 或更高，以确保数据冗余性和高可用性。单一副本的主题只有在测试或开发环境中才有意义。<br>    --partitions：指定要为主题创建的分区数。如果没有特殊需求，请在生产中创建多个分区以支持更好的伸缩性和吞吐量。<br>    --topic：指定要创建的主题名称。<br></code></pre></td></tr></table></figure><h1 id="14-k8s相关命令"><a href="#14-k8s相关命令" class="headerlink" title="14 k8s相关命令"></a>14 k8s相关命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">1、 查看节点<br>kubectl get nodes<br>2、查看Pod<br> kubectl get pods<br>3、删除Pods<br>kubectl delete pod &lt;pod-name&gt;<br>4、k8s查看所有命名空间<br>kubectl get namespaces<br>5、切换进入命名空间<br>kubectl config set-context --current --namespace=&lt;namespace&gt;<br>6、查看services<br>kubectl get services<br>7、刪除命名空间<br>kubectl delete namespace &lt;namespace-name&gt;<br>8、创建命令空间<br>kubectl create namespace &lt;namespace-name&gt;<br></code></pre></td></tr></table></figure><h1 id="15-ES相关命令"><a href="#15-ES相关命令" class="headerlink" title="15 ES相关命令"></a>15 ES相关命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs apl">1、创建索引：（指定索引最大字段数）<br>PUT /benthos<br>&#123;<br>  &quot;settings&quot;: &#123;<br>    &quot;index.mapping.total_fields.limit&quot;: 10000<br>  &#125;<br>  &#125;<br><br>2、查看索引列表：<br>curl -X GET &quot;localhost:9200/_cat/indices?v&quot;<br><br>3、向索引中添加文档：<br>curl -X POST &quot;localhost:9200/your_index/_doc&quot; -H &#x27;Content-Type: application/json&#x27; -d &#x27;&#123;<br>  &quot;field1&quot;: &quot;value1&quot;,<br>  &quot;field2&quot;: &quot;value2&quot;<br>&#125;&#x27;<br><br>4、获取单个文档：<br>curl -X GET &quot;localhost:9200/your_index/_doc/your_document_id?pretty&quot;<br><br>5、更新文档：<br>curl -X POST &quot;localhost:9200/your_index/_doc/your_document_id/_update&quot; -H &#x27;Content-Type: application/json&#x27; -d &#x27;&#123;<br>  &quot;doc&quot;: &#123;<br>    &quot;new_field&quot;: &quot;new_value&quot;<br>  &#125;<br>&#125;&#x27;<br><br>6、删除索引：<br><br>7、查看索引内容：<br>http://192.168.0.71:9200/benthos/_search?q=*<br><br>8、修改索引字段数<br>PUT /索引名/_settings<br>&#123;<br>  &quot;index.mapping.total_fields.limit&quot;: 新的最大字段数<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="16-Tshark分包命令"><a href="#16-Tshark分包命令" class="headerlink" title="16 Tshark分包命令"></a>16 Tshark分包命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">安装<br>sudo apt install -y tshark<br><br>1 使用tshark分割包<br>tshark -r input.pcap -w output -C 1 -b filesize:1024<br><span class="hljs-comment"># tshark 同步发送</span><br>tshark -i eth0 -w capture.pcap &amp;&amp; $ rsync -avz capture.pcap user@remote.server:/path/to/remote/dir<br><span class="hljs-comment"># tshark 生成ek josn清除 索引行</span><br>tshark -r test2.pcap -T ek -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt; testek.json<br><span class="hljs-comment"># tshark过滤字段</span><br> 选项用于过滤要显示或处理的数据包。您可以使用 Wireshark Display Filters 语法来定义过滤条件，以限制结果集中的数据包。例如，您可以使用 -Y <span class="hljs-string">&quot;ip.src == 192.168.0.1&quot;</span> 来仅显示源IP地址为 192.168.0.1 的数据包。<br><br>-e 选项用于指定在输出中显示的字段。您可以使用 tshark 的字段名称或编码来提取感兴趣的特定字段。例如，您可以使用 -e frame.number -e ip.src -e tcp.dstport 来获取每个数据包的帧编号、源IP地址和目标TCP端口号。<br>tshark -r <span class="hljs-string">&quot;<span class="hljs-variable">$pcap_file</span>&quot;</span> -Y <span class="hljs-string">&quot;<span class="hljs-variable">$filter</span>&quot;</span> -T ek -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt;  <span class="hljs-string">&quot;<span class="hljs-variable">$output_file</span>&quot;</span> <br><br>tshark -r test2.pcap -T ek -e -E header=y -E separator=, -E occurrence=f | sed <span class="hljs-string">&#x27;/&#123;&quot;index&quot;:&#123;.*&#125;&#125;/d&#x27;</span> &gt; testek.json<br><br><span class="hljs-built_in">nohup</span> bash tshark_benthos.sh &gt; output.log 2&gt;&amp;1 &amp;<br><br><br></code></pre></td></tr></table></figure><h1 id="17-linux环境变量等级"><a href="#17-linux环境变量等级" class="headerlink" title="17 linux环境变量等级"></a>17 linux环境变量等级</h1><h2 id="在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级"><a href="#在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级" class="headerlink" title="在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级"></a>在Linux环境中，存在不同的环境变量等级，它们决定了变量的作用范围和优先级</h2><ol><li>全局系统级别（Global System Level）：<br>这是最高级别的环境变量，适用于整个系统的所有用户和进程。这些环境变量通常定义在系统范围的配置文件中，例如<code>/etc/profile</code>、<code>/etc/environment</code>和<code>/etc/profile.d/</code>目录下的文件。修改这些文件需要root权限。</li><li>用户级别（User Level）：<br>用户级别的环境变量仅适用于特定用户。每个用户都有自己的环境变量配置，通常保存在用户的主目录中的文件中。最常见的是<code>~/.bashrc</code>和<code>~/.bash_profile</code>文件，它们在用户登录时会被加载。修改这些文件只会影响到相应用户。</li><li>会话级别（Session Level）：<br>会话级别的环境变量仅适用于当前会话。当用户登录后，会话级别的环境变量会被创建，并在用户退出登录后被销毁。这些环境变量可以通过在终端中直接设置变量来定义，例如使用<code>export</code>命令。</li><li>会话级别（Session Level）：<br>会话级别的环境变量仅适用于当前会话。当用户登录后，会话级别的环境变量会被创建，并在用户退出登录后被销毁。这些环境变量可以通过在终端中直接设置变量来定义，例如使用<code>export</code>命令。</li></ol><h1 id="18-Ubuntu-安装第三方包（deb）"><a href="#18-Ubuntu-安装第三方包（deb）" class="headerlink" title="18 Ubuntu 安装第三方包（deb）"></a>18 Ubuntu 安装第三方包（deb）</h1><p><strong>安装实例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">下载好对应的deb包<br>sudo dpkg -<span class="hljs-selector-tag">i</span> com<span class="hljs-selector-class">.alibabainc</span><span class="hljs-selector-class">.dingtalk_7</span>.<span class="hljs-number">1.0</span>.<span class="hljs-number">31120</span>_amd64<span class="hljs-selector-class">.deb</span> <br></code></pre></td></tr></table></figure><p><strong>查看安装的包</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">sudo dpkg -l <span class="hljs-string">| grep dingtalk</span><br></code></pre></td></tr></table></figure><p><strong>卸载已安装的包</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo dpkg-r dingtalk</span><br></code></pre></td></tr></table></figure><p><strong>deb包默认暂存路径</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archives/<br></code></pre></td></tr></table></figure><h1 id="19-谷歌浏览器截图"><a href="#19-谷歌浏览器截图" class="headerlink" title="19 谷歌浏览器截图"></a>19 谷歌浏览器截图</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 按F12<br>2. Ctrl + Shift + P<br>3. 输入命令 `Capture full size screenshot`<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KafKa 介绍</title>
    <link href="/2024/05/27/tools/Kafka%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2024/05/27/tools/Kafka%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p><strong>你是一个程序员，假设你维护了两个服务 A 和 B。B 服务每秒只能处理 100 个消息，但 A 服务却每秒发出 200 个消息，B 服务哪里顶得住，分分钟被压垮。那么问题就来了，有没有办法让 B 在不被压垮的同时，还能处理掉 A 的消息？当然有，没有什么是加一层中间层不能解决的，如果有，那就再加一层。这次我们要加的中间层是 消息队列 Kafka。</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514092819890.png?raw=true" alt="image-20240514092819890"></p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>为了保护 B 服务，我们很容易想到可以在 B 服务的内存中加入一个<strong>队列</strong>。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514092948006.png?raw=true" alt="image-20240514092948006"></p><p>说白了，它其实是个链表，链表的每个节点就是一个消息。每个节点有一个序号，我们叫它 <code>Offset(相当一个书签)</code>，记录消息的位置。B 服务依据自己的处理能力，消费链表里的消息。能处理多少是多少，不断更新已处理 Offset 的值。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514093303221.png?raw=true" alt="image-20240514093303221"></p><p>但这有个问题，来不及处理的消息会堆积在内存里，如果 B 服务更新<strong>重启</strong>，这些消息就都丢了。这个好解决，将队列挪出来，变成一个<strong>单独的进程</strong>。就算 B 服务重启，也不会影响到了队列里的消息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514093434298.png?raw=true" alt="image-20240514093434298"></p><p>这样一个简陋的队列进程，其实就是所谓的<strong>消息队列</strong>。而像 A 服务这样负责发数据到消息队列的角色，就是<strong>生产者</strong>，像 B 服务这样处理消息的角色，就是<strong>消费者</strong>。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514094020978.png?raw=true" alt="image-20240514094020978"></p><p>但这个消息队列属实过于简陋，像什么高性能，高扩展性，高可用，它是一个都不沾。我们来看下怎么优化它。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>B 服务由于性能较差，消息队列里会不断堆积数据，为了提升性能，我们可以扩展更多的消费者, 这样消费速度就上去了，相对的我们就可以增加更多生产者，提升消息队列的吞吐量。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514094125035.png?raw=true" alt="image-20240514094125035"></p><p>随着生产者和消费者都变多，我们会发现它们会同时争抢同一个消息队列，抢不到的一方就得等待，这不纯纯浪费时间吗！有解决方案吗？有！首先是对消息进行分类，每一类是一个 <strong>topic</strong>，然后根据 topic 新增队列的数量，生产者将数据按 topic 投递到不同的队列中，消费者则根据需要订阅不同的 topic。这就大大降低了 topic 队列的压力。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514100259038.png?raw=true" alt="image-20240514100259038"></p><p>但单个 topic 的消息还是可能过多，我们可以将单个队列，拆成好几段，每段就是一个 <strong>partition分区</strong>，每个消费者负责一个 partition。这就大大降低了争抢，提升了消息队列的性能。</p><ul><li>Partition是Topic内部的物理分片，每个Topic可以被分为一个或多个Partition。这样做不仅允许数据并行处理，还为数据的规模扩展提供了基础。</li><li>每个Partition都是一个有序的、不可变的消息队列，消息在Partition内部是严格有序的，但不同Partition间的消息顺序不保证。</li><li>Partition的数量可以在创建Topic时指定，也可以后续调整（尽管这通常需要重新分配数据，可能影响到实时消息处理）。</li><li>Partition的数据分布在不同的Broker上，以实现负载均衡和故障隔离。每个Partition都有一个Leader和零个或多个Follower，Leader负责读写操作，Follower负责数据复制以确保数据安全。</li></ul><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104614344.png?raw=true" alt="image-20240514104614344"></p><blockquote><p>Broker 是Kafka集群中的一个节点，负责消息的接收、存储、分发以及相关的管理工作。</p></blockquote><h2 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h2><p>随着 partition 变多，如果 partition 都在同一台机器上的话，就会导致单机 cpu 和内存过高，影响整体系统性能。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104741761.png?raw=true" alt="image-20240514104741761"></p><p>于是我们可以申请更多的机器，将 partition 分散部署在多台机器上，这每一台机器，就代表一个 <strong>broker</strong>。我们可以通过增加 broker 缓解机器 cpu 过高带来的性能问题。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514104846414.png?raw=true" alt="image-20240514104846414"></p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>到这里，其实还有个问题，如果其中一个 partition 所在的 broker 挂了，那 broker 里所有 partition 的消息就都没了。这高可用还从何谈起？有解决方案吗？有，连你喜欢的女生都知道手机里多聊几个沸羊羊，你却不知道要给 partition 加备胎吗？我们可以给 partition 多加几个副本，也就是 replicas，将它们分为 Leader 和 Follower。Leader 负责应付生产者和消费者的读写请求，而 Follower 只管同步 Leader 的消息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105013986.png?raw=true" alt="image-20240514105013986"></p><p>将 Leader 和 Follower 分散到不同的 broker 上，这样 Leader 所在的 broker 挂了，也不会影响到 Follower 所在的 broker, 并且还能从 Follower 中选举出一个新的 Leader partition 顶上。这样就保证了消息队列的高可用。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105052593.png?raw=true" alt="image-20240514105052593"></p><h2 id="持久化和过期策略"><a href="#持久化和过期策略" class="headerlink" title="持久化和过期策略"></a>持久化和过期策略</h2><p>刚刚提到的是几个 broker 挂掉的情况，那搞大点，假设所有 broker 都挂了，那岂不是数据全丢了？为了解决这个问题，我们不能光把数据放内存里，还要持久化到磁盘中，这样哪怕全部 broker 都挂了，数据也不会全丢，重启服务后，也能从磁盘里读出数据，继续工作。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514105125764.png?raw=true" alt="image-20240514105125764"></p><p>但问题又来了，磁盘总是有限的，这一直往里写数据迟早有一天得炸。所以我们还可以给数据加上保留策略，也就是所谓的 <code>retention policy</code>，比如磁盘数据超过一定大小或消息放置超过一定时间就会被清理掉。</p><h2 id="consumer-group"><a href="#consumer-group" class="headerlink" title="consumer group"></a>consumer group</h2><p>到这里，这个消息队列好像就挺完美了。但其实还有个问题，按现在的消费方式，每次新增的消费者只能跟着<strong>最新的</strong>消费 Offset 接着消费。如果我想让新增的消费者从某个 Offset 开始消费呢？听起来这个需求很刁钻？我举个例子你就明白了。</p><p>哪怕 B 服务有多个实例，但本质上，它只有一个消费业务方，新增实例一般也是接着之前的 offset 继续消费。假设现在来了个新的业务方，C 服务，它想从头开始消费消息队列里的数据，这时候就不能跟在 B 服务的 offset 后边继续消费了。</p><p>所以我们还可以给消息队列加入消费者组（consumer group）的概念，B 和 C 服务各自是一个独立的消费者组，不同消费者组维护自己的消费进度，互不打搅。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110710406.png?raw=true" alt="image-20240514110710406"></p><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>相信你也发现了，组件太多了，而且每个组件都有自己的数据和状态，所以还需要有个组件去统一维护这些组件的状态信息，于是我们引入 <strong>ZooKeeper</strong> 组件。它会定期和 broker 通信，获取 整个 kafka 集群的状态，以此判断 某些 broker 是不是跪了，某些消费组消费到哪了。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110818882.png?raw=true" alt="image-20240514110818882"></p><h2 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h2><p>好了，到这里，当初那个简陋的消息队列，就成了一个高性能，高扩展性，高可用，支持持久化的超强消息队列，没错，它就是我们常说的消息队列 <strong>Kafka</strong>，上面涉及到各种概念，比如 partition 和 broker 什么的，都出自它。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240514110952706.png?raw=true" alt="image-20240514110952706"></p><h2 id="kafka-的应用场景"><a href="#kafka-的应用场景" class="headerlink" title="kafka 的应用场景"></a>kafka 的应用场景</h2><p>消息队列是架构中最常见的中间件之一，使用场景之多，堪称万金油！比如上游流量忽高忽低，想要<strong>削峰填谷</strong>，提升 cpu&#x2F;gpu 利用率，用它。又比如系统过大，消息流向盘根错节，想要拆解组件，<strong>降低系统耦合</strong>，还是用它。再比如秒杀活动，请求激增，想要<strong>保护服务</strong>的同时又尽量不影响用户，还得用它。当然，凡事无绝对，方案还得根据实际情况来定，做架构做到最后，都是在做<strong>折中</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>• kafka 是消息队列，像消息队列投递消息的是生产者，消费消息的是消费者。增加生产者和消费者的实例个数可以提升系统吞吐。多个消费者可以组成一个消费者组，不同消费者组维护自己的消费进度，互不打搅。</li><li>• kafka 将消息分为多个 topic，每个 topic 内部拆分为多个 partition，每个 partition 又有自己的副本，不同的 partition 会分布在不同的 broker 上，提升性能的同时，还增加了系统可用性和可扩展性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql使用</title>
    <link href="/2024/05/27/tools/Mysql%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/05/27/tools/Mysql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql用法"><a href="#Mysql用法" class="headerlink" title="Mysql用法"></a>Mysql用法</h1><h2 id="1、查询相关"><a href="#1、查询相关" class="headerlink" title="1、查询相关"></a>1、<code>查询相关</code></h2><hr><p><strong>使用like关键字进行模糊匹配:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27; %pattern%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>使用正则表达式进行查询:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">column</span> regexp <span class="hljs-string">&#x27;pattern&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>子查询（Nested Queries）</strong></p><p>子查询允许你将一个查询的结果作为另一个查询的条件。例如，查找订单金额大于平均订单金额的订单：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Orders<br><span class="hljs-keyword">WHERE</span> OrderAmount <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(OrderAmount) <span class="hljs-keyword">FROM</span> Orders);<br></code></pre></td></tr></table></figure><p><strong>联接查询（JOINs）</strong></p><p>​联接多个表以获取相关数据。有多种类型的联接，如：</p><ul><li><p>内联接（INNER JOIN）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Orders.OrderID, Customers.CustomerName<br><span class="hljs-keyword">FROM</span> Orders<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Customers <span class="hljs-keyword">ON</span> Orders.CustomerID <span class="hljs-operator">=</span> Customers.CustomerID;<br></code></pre></td></tr></table></figure></li><li><p>左联接（LEFT JOIN）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Customers.CustomerName, Orders.OrderID<br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> Orders <span class="hljs-keyword">ON</span> Customers.CustomerID <span class="hljs-operator">=</span> Orders.CustomerID;<br></code></pre></td></tr></table></figure></li></ul><p><strong>可选查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;# 查询全部<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> [<span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> &quot;zhangsan&quot;]# 通过判断name变量是否存在 进行代码<span class="hljs-keyword">sql</span>拼接<br></code></pre></td></tr></table></figure><h2 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h2><hr><p><strong>longtex类型</strong></p><p>“LONGTEXT”数据类型是一种比较大的文本类型，可以容纳最大长度为4 GB的字符数据。</p><p><strong>json类型</strong></p><ol><li>MySQL 5.7及更早版本：<ul><li>最大存储容量为64KB。</li></ul></li><li>MySQL 8.0：<ul><li>最大存储容量为4GB</li></ul></li></ol><p>使用longtext字段存储JSON或其他结构化数据存在一些潜在的问题:</p><ol><li>不便于索引和查询。longtext是非结构化文本,不能建立索引,不便于通过结构化字段进行精确或范围查询。</li><li>性能可能受影响。和直接使用json数据类型相比,从longtext中提取JSON需要额外的解析步骤,可能影响查询性能。</li><li>无法校验数据格式。longtext中存储的内容无法校验是否符合JSON规范,容易出现格式错误无法解析的情况。</li><li>可读性差。与专门的JSON字段相比,直接查看longtext内容无法清晰看出结构。</li><li>存储利用率低。JSON数据本身就很“紧凑”,使用longtext可能存在空间浪费。</li><li>不利于数据隔离。多个文档通常需要使用分隔符隔离,增加解析复杂性。</li><li>后续难扩展。如果需要使用更多JSON功能,就需要迁移数据格式。</li></ol><p><strong>如果条件允许, stronger的做法是直接使用json数据类型来存储和处理JSON内容。</strong></p><p><strong>整数类型</strong></p><ul><li>TINYINT: tinyint类型用于存储范围在-128到127之间的整数。它占1个字节。</li><li>SMALLINT:smallint类型用于存储范围在-32768到32767之间的整数。它占2个字节。</li><li>MEDIUMINT:mediumint类型用于存储范围在-8388608到8388607之间的整数。它占3个字节。</li><li>INT:int类型用于存储范围在-2147483648到2147483647之间的整数。它占4个字节。</li><li>BIGINT:bigint类型用于存储范围在-9,223,372,036,854,775,808到9,223,372,036,854,775,807之间的整数。它占8个字节。</li></ul><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><hr><p><strong>JSON_EXTRACT</strong></p><p>JSON_EXTRACT函数用于从JSON类型字段或变量中提取数据,它的语法形式为:</p><p>JSON_EXTRACT(json_doc, path)</p><p>参数说明:</p><ul><li>json_doc: JSON类型字段或变量,可以是长文本、VARCHAR等类型。</li><li>path: JSON路径表达式,使用点号.指定每个层级,用通配符*匹配多层。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 如果需要查出整行数据,可以在<span class="hljs-keyword">SELECT</span>和<span class="hljs-keyword">WHERE</span>中使用:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">WHERE</span> JSON_EXTRACT(metadata, <span class="hljs-string">&#x27;$.fields[0].fieldPath&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;id&#x27;</span><br><br># 单独执行JSON_EXTRACT语句,直接获取字段值:<br><span class="hljs-keyword">SELECT</span> JSON_EXTRACT(metadata, <span class="hljs-string">&#x27;$.fields[0].fieldPath&#x27;</span>) <br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br></code></pre></td></tr></table></figure><h2 id="4、Mysql5-7和Mysql8-0优缺点"><a href="#4、Mysql5-7和Mysql8-0优缺点" class="headerlink" title="4、Mysql5.7和Mysql8.0优缺点"></a>4、Mysql5.7和Mysql8.0优缺点</h2><hr><p>MySQL 5.7优点:</p><ul><li>稳定性好,生态成熟。5.7版本已经用了很多年,Bug较少。</li><li>兼容性强,与5.6下的应用兼容性好。</li><li>功能完善,支持多种存储引擎。</li><li>性能优化成熟,查询效率高。</li></ul><p>MySQL 5.7缺点:</p><ul><li>不支持新的JSON功能和可拓展存储引擎。</li><li>不支持从库读取复制功能。</li><li>部分新特性支持不够完善。</li></ul><p>MySQL 8.0优点:</p><ul><li>支持新存储引擎如InnoDB容器存储引擎。</li><li>全新的JSON数据类型支持,查询和索引功能强大。</li><li>支持从库读取功能等新复制特性。</li><li>性能有一定提升,支持区块存储引擎对分区表性能优化。</li></ul><p>MySQL 8.0缺点:</p><ul><li>新版本兼容性问题,与5.7下应用迁移成本高。</li><li>新功能测试环境建设难度大。</li><li>BUG率可能高于5.7稳定版本。</li></ul><h2 id="5-、Insert"><a href="#5-、Insert" class="headerlink" title="5 、Insert"></a>5 、Insert</h2><p>在数据库操作中，处理重复插入是一个常见需求，尤其是在尝试插入数据到具有唯一约束（如唯一键、主键）的表时。以下是几种处理重复插入的方法：</p><ol><li><p><strong>忽略重复记录</strong>： 使用 <code>INSERT IGNORE</code> 语句，当插入的记录违反唯一性约束时，MySQL会忽略这条插入语句，而不是抛出错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> IGNORE <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>ON DUPLICATE KEY UPDATE</code>**： 当插入的记录导致唯一键冲突时，此语句可以更新已有记录的某些字段而不是插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...)<br><span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span><br>column1 <span class="hljs-operator">=</span> <span class="hljs-keyword">VALUES</span>(column1), column2 <span class="hljs-operator">=</span> <span class="hljs-keyword">VALUES</span>(column2);<br></code></pre></td></tr></table></figure><p>这里，<code>VALUES(column_name)</code> 函数用于引用新插入的值。</p></li><li><p><strong>先查询后插入（SELECT + INSERT）</strong>：在插入之前，先查询记录是否存在。如果不存在，则插入。这种方法适用于不支持上述特性的数据库系统。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> cat(id, name, age)<br><span class="hljs-keyword">SELECT</span> s.SNO, s.SEX, s.CSZ<br><span class="hljs-keyword">FROM</span> test.student44 s<br><span class="hljs-keyword">WHERE</span> s.SNAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;陈强&#x27;</span><br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> cat c<br>    <span class="hljs-keyword">WHERE</span> c.id <span class="hljs-operator">=</span> s.SNO<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>MERGE</code> 语句（适用于SQL Server和Oracle等）</strong>：</p><p><code>MERGE</code> 是一种更高级的语句，可以同时完成查询、插入、更新和删除操作。对于避免重复插入，它可以用来根据条件决定是插入新记录还是更新现有记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">MERGE</span> <span class="hljs-keyword">INTO</span> Customers <span class="hljs-keyword">AS</span> Target<br><span class="hljs-keyword">USING</span> NewCustomerData <span class="hljs-keyword">AS</span> Source<br><span class="hljs-keyword">ON</span> Target.CustomerID <span class="hljs-operator">=</span> Source.CustomerID<br><span class="hljs-keyword">WHEN</span> MATCHED <span class="hljs-keyword">THEN</span><br>    <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SET</span> Target.Email <span class="hljs-operator">=</span> Source.Email<br><span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">NOT</span> MATCHED <span class="hljs-keyword">THEN</span><br>    <span class="hljs-keyword">INSERT</span> (CustomerID, Name, Email)<br>    <span class="hljs-keyword">VALUES</span> (Source.CustomerID, Source.Name, Source.Email);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 入门</title>
    <link href="/2024/05/27/tools/Redis%E5%85%A5%E9%97%A8/"/>
    <url>/2024/05/27/tools/Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis基本介绍和基本使用方法"><a href="#Redis基本介绍和基本使用方法" class="headerlink" title="Redis基本介绍和基本使用方法"></a>Redis基本介绍和基本使用方法</h2><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h2><p>Redis是一个开源的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">内存数据库</a>，属于NoSQL数据库的一种。它以高性能、支持丰富的数据结构、持久化特性、复制、集群以及发布&#x2F;订阅等特性而闻名。，遵守BSD协议，是一个高性能的key-value非关系型数据库。</p><h3 id="Redis特点："><a href="#Redis特点：" class="headerlink" title="Redis特点："></a>Redis特点：</h3><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</p><p>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, 设置key有效期等等特性。</p><h3 id="redis作用"><a href="#redis作用" class="headerlink" title="redis作用:"></a>redis作用:</h3><p>可以减轻数据库压力，查询内存比查询数据库效率高。</p><h3 id="Redis应用："><a href="#Redis应用：" class="headerlink" title="Redis应用："></a>Redis应用：</h3><p>token生成、session共享、分布式锁、自增id、验证码等。</p><h3 id="比较重要的3个可执行文件："><a href="#比较重要的3个可执行文件：" class="headerlink" title="比较重要的3个可执行文件："></a>比较重要的3个可执行文件：</h3><p>redis-server：Redis服务器程序</p><p>redis-cli：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。</p><p>redis-benchmark：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能。</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>Redis key值是二进制安全的，即可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效key值</p><p>注：<br>定义key的规则：<br>  避免太长的键，不仅因为消耗内存，而且在数据中查找这类键值的计算成本很高；<br>  避免太短的键，如使用u:1000:pwd代替user:1000:password，但后者更易阅读，并且由此增加的空间消耗相对于key object和value object本身来说很小；<br>  最好坚持一种模式。如：<code>object-type:id:field</code></p><h3 id="2-key使用"><a href="#2-key使用" class="headerlink" title="2 key使用"></a>2 key使用</h3><h4 id="2-1-按模式匹配对应的key"><a href="#2-1-按模式匹配对应的key" class="headerlink" title="2.1 按模式匹配对应的key"></a>2.1 按模式匹配对应的key</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"> keys <span class="hljs-keyword">pattern</span><br> <br> gva164:db0<span class="hljs-operator">&gt;</span> keys <span class="hljs-operator">*</span><span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;k1:1&quot;<br><span class="hljs-number">2</span>) &quot;k11&quot;<br><span class="hljs-number">3</span>) &quot;k1&quot;<br>gva164:db0<span class="hljs-operator">&gt;</span> keys <span class="hljs-operator">*</span><span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;k12&quot;<br><span class="hljs-number">2</span>) &quot;k2&quot;<br></code></pre></td></tr></table></figure><h4 id="2-2-判断key是否存在"><a href="#2-2-判断key是否存在" class="headerlink" title="2.2 判断key是否存在"></a>2.2 判断key是否存在</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exists</span> key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">exists</span> k1 k2 k5<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="2-3-查看key的类型"><a href="#2-3-查看key的类型" class="headerlink" title="2.3 查看key的类型"></a>2.3 查看key的类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">type key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> type k2<br>string<br></code></pre></td></tr></table></figure><h4 id="2-4删除指定的key"><a href="#2-4删除指定的key" class="headerlink" title="2.4删除指定的key"></a>2.4删除指定的key</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">del key<br><br>gva164:db0<span class="hljs-operator">&gt;</span> del k3 k13<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="2-5-根据value选择非阻塞删除"><a href="#2-5-根据value选择非阻塞删除" class="headerlink" title="2.5 根据value选择非阻塞删除"></a>2.5 根据value选择非阻塞删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlink key  <br></code></pre></td></tr></table></figure><p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</p><h4 id="2-6-为给定的key设置过期时间（单位-秒）"><a href="#2-6-为给定的key设置过期时间（单位-秒）" class="headerlink" title="2.6 为给定的key设置过期时间（单位 秒）"></a>2.6 为给定的key设置过期时间（单位 秒）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">expire key <span class="hljs-number">10</span> <br><br>gva164:db0<span class="hljs-operator">&gt;</span> expire k1 <span class="hljs-number">10</span><br><span class="hljs-number">1</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello<br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1# 查看key还有多少秒到期,<span class="hljs-number">-1</span>表示用不过期,<span class="hljs-number">-2</span>表示已经过期<br><span class="hljs-number">1</span><br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1<br><span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><h3 id="3-redis-原子性"><a href="#3-redis-原子性" class="headerlink" title="3 redis 原子性"></a>3 redis 原子性</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240515171954888.png?raw=true" alt="image-20240515171954888"></p><p>  原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</p><p>​<strong>Redis命令的原子性主要得益于Redis的单线程</strong></p><h2 id="value的五种数据类型"><a href="#value的五种数据类型" class="headerlink" title="value的五种数据类型"></a>value的五种数据类型</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>  String是Redis value的最基本类型<br>  String类型是二进制安全的，意味着Redis的string可以包含任何数据，比如jpg图片或者序列化的对象。<br>  String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M<br>  字符串类型的内部编码有3种：int：8个字节的长整型；embstr：小于等于39个字节的字符串；raw：大于39个字节的字符串</p><h4 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h4><p><strong>添加键值对</strong></p><p>若原来存在，默认会存在覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello world<br>ERR syntax error<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 hello,world<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>hello,world<br></code></pre></td></tr></table></figure><p>NX：当数据库中key不存在时，可以将key-value添加数据库，<code>可用于分布式锁</code><br>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥<br>EX：key的超时秒数<br>PX：key的超时毫秒数，与EX互斥</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v100 ex <span class="hljs-number">20</span> nx<br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v100 ex <span class="hljs-number">20</span> xx<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v100<br>gva164:db0<span class="hljs-operator">&gt;</span> ttl k1<br><span class="hljs-number">13</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>查询对应键值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v10000<br></code></pre></td></tr></table></figure><p><strong>将给定的value 追加到原值的末尾</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">append  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k1 v1<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> append k1 v2<br><span class="hljs-number">4</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v1v2<br></code></pre></td></tr></table></figure><p><strong>获得值的长度</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">strlen  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> strlen k1<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>将 key 中储存的数字值增1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">incr  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k2 <span class="hljs-number">2</span><br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> incr k2<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR 和 DECRBY，实际上他们在内部就是同一个命令。<br>  INCR是原子操作意味着什么呢？即使多个客户端对同一个key发出INCR命令，也决不会导致竞争的情况。客户端1和客户端2同时读出“10”，二者均对其加到11，然后将新值最终设置为11永远不可能发生，最终的值一定是12。read-increment-set操作完成时，其他客户端不会在同一时间执行任何命令。</p><p><strong>将 key 中储存的数字值减1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">decr  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k3<br><br>gva164:db0<span class="hljs-operator">&gt;</span> decr k3<br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>只能对数字值操作，如果为空，值为-1</p><p><strong>将 key 中储存的数字值增减，自定义步长</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">incrby <span class="hljs-operator">/</span> decrby  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-operator">&lt;</span>步长<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k2<br><span class="hljs-number">3</span><br>gva164:db0<span class="hljs-operator">&gt;</span> incrby k2 <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> k3 <span class="hljs-number">2</span><br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> decrby k3 <span class="hljs-number">5</span><br><span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure><p><strong>同时设置一个或多个 key-value对</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mset  <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>  ..... <br>gva164:db0<span class="hljs-operator">&gt;</span> mset k1 v1 k2 v2 k3 v3<br>OK<br></code></pre></td></tr></table></figure><p><strong>同时获取一个或多个value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mget <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> mget k1 k2 k3<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">msetnx <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>  ..... <br></code></pre></td></tr></table></figure><p>原子性，有一个失败则都失败</p><p><strong>截取字符串</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">getrange  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>起始位置<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>结束位置<span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> ks abcdef<br>OK<br>gva164:db0<span class="hljs-operator">&gt;</span> getrange ks <span class="hljs-number">13</span><br>ERR wrong number <span class="hljs-keyword">of</span> arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getrange&#x27;</span> command<br>gva164:db0<span class="hljs-operator">&gt;</span> getrange ks <span class="hljs-number">1</span> <span class="hljs-number">3</span><br>bcd<br></code></pre></td></tr></table></figure><p><strong>用 value 覆写key所储存的字符串值，从起始位置开始(索引从0开始)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">setrange  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>起始位置<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>设置键值的同时，设置过期时间，单位秒</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">setex  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>过期时间<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>以新换旧，设置了新值同时获得旧值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">getset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v1<br>gva164:db0<span class="hljs-operator">&gt;</span> getset k1 v100<br>v1<br>gva164:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">get</span> k1<br>v100<br></code></pre></td></tr></table></figure><p>如：系统中每当有新用户访问时就用INCR命令操作一个Redis key。若每小时对这个信息收集一次。可使用GETSET给其赋值0并读取原值。</p><h4 id="1-3-数据结构"><a href="#1-3-数据结构" class="headerlink" title="1.3  数据结构"></a>1.3  数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。采用预分配冗余空间的方式来减少内存的频繁分配。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240515175615866.png?raw=true" alt="image-20240515175615866"></p><p>如图中所示，为String类型实际分配的空间一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。</p><h3 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p><strong>单键多值</strong></p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边).</p><p>Redis lists基于LinkedList实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p><p>相对应的，在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linkedlist实现的list上没有那么快。</p><blockquote><p>所以：如何快速地在很大的列表上添加元素，建议使用List;如果快速访问集合元素很重要，建议使用可排序集合(sorted sets)。</p></blockquote><h4 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h4><p><strong>从左边&#x2F;右边插入一个或多个值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">lpush<span class="hljs-operator">/</span>rpush  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>value3<span class="hljs-operator">&gt;</span> .... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v3&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lpush k1 v<span class="hljs-number">-3</span> v<span class="hljs-number">-2</span> v<span class="hljs-number">-1</span> <span class="hljs-number">0</span><br><span class="hljs-number">7</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;0&quot;<br><span class="hljs-number">2</span>) &quot;v-1&quot;<br><span class="hljs-number">3</span>) &quot;v-2&quot;<br><span class="hljs-number">4</span>) &quot;v-3&quot;<br><span class="hljs-number">5</span>) &quot;v3&quot;<br><span class="hljs-number">6</span>) &quot;v2&quot;<br><span class="hljs-number">7</span>) &quot;v1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> rpush k1 v8 v9 v10<br><span class="hljs-number">10</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;0&quot;<br><span class="hljs-number">2</span>) &quot;v-1&quot;<br><span class="hljs-number">3</span>) &quot;v-2&quot;<br><span class="hljs-number">4</span>) &quot;v-3&quot;<br><span class="hljs-number">5</span>) &quot;v3&quot;<br><span class="hljs-number">6</span>) &quot;v2&quot;<br><span class="hljs-number">7</span>) &quot;v1&quot;<br><span class="hljs-number">8</span>) &quot;v8&quot;<br><span class="hljs-number">9</span>) &quot;v9&quot;<br><span class="hljs-number">10</span>) &quot;v10&quot;<br></code></pre></td></tr></table></figure><p>如：在博客引擎实现中，可为每篇日志设置一个list，推入博客评论</p><p>注：<br>  使用LPUSH和RPOP实现生产者和消费者模型，会遇到这种情景：list是空，这时候消费者就需要轮询来获取数据，这样就会增加redis的访问压力、增加消费端的cpu时间，而很多访问都是无用的。为此redis提供了阻塞式访问 BRPOP 和 BLPOP 命令。 消费者可以在获取数据时指定如果数据不存在阻塞的时间，如果在时限内获得数据则立即返回，如果超时还没有数据则返回null, 0表示一直阻塞。</p><p><strong>从左边&#x2F;右边吐出一个值。值在键在，值光键亡</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">lpop<span class="hljs-operator">/</span>rpop  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lpop k2<br>v1<br>localhost:db0<span class="hljs-operator">&gt;</span> rpop k2<br>v3<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange k2 <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;v2&quot;<br></code></pre></td></tr></table></figure><p><strong>从key1列表右边吐出一个值，插到key2列表左边</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">rpoplpush  <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lpush <span class="hljs-keyword">order</span> a1 a2 a3 a4<br><span class="hljs-number">4</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange <span class="hljs-keyword">order</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a1<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a2<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a3<br>localhost:db0<span class="hljs-operator">&gt;</span> rpoplpush <span class="hljs-keyword">order</span> history_order<br>a4<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br></code></pre></td></tr></table></figure><p><strong>按照索引下标获得元素(从左到右)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>stop<span class="hljs-operator">&gt;</span><br><br></code></pre></td></tr></table></figure><p>0左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p>如新闻网站,可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p><p><strong>按照索引下标获得元素(从左到右)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>index<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;a3&quot;<br><span class="hljs-number">3</span>) &quot;a2&quot;<br><span class="hljs-number">4</span>) &quot;a1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lindex history_order <span class="hljs-number">1</span><br>a3<br>localhost:db0<span class="hljs-operator">&gt;</span> lindex history_order <span class="hljs-number">3</span><br>a1<br></code></pre></td></tr></table></figure><p><strong>获得列表长度</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">llen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> llen history_order<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>在 value的前面或后面插入 newvalue</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>newvalue<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> linsert history_order before a3 mya3<br><span class="hljs-number">5</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange history_order <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a4&quot;<br><span class="hljs-number">2</span>) &quot;mya3&quot;<br><span class="hljs-number">3</span>) &quot;a3&quot;<br><span class="hljs-number">4</span>) &quot;a2&quot;<br><span class="hljs-number">5</span>) &quot;a1&quot;<br></code></pre></td></tr></table></figure><p><strong>从左到右删除n个value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">lrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>n<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lpush a a b a b a b<br><span class="hljs-number">6</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;b&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;b&quot;<br><span class="hljs-number">4</span>) &quot;a&quot;<br><span class="hljs-number">5</span>) &quot;b&quot;<br><span class="hljs-number">6</span>) &quot;a&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lrem a <span class="hljs-number">3</span> b<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;a&quot;<br></code></pre></td></tr></table></figure><p><strong>将列表key下标为index的值替换成value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">lset<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>index<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;a&quot;<br><span class="hljs-number">3</span>) &quot;a&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> lset a <span class="hljs-number">1</span> bbb<br>OK<br>localhost:db0<span class="hljs-operator">&gt;</span> lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) &quot;a&quot;<br><span class="hljs-number">2</span>) &quot;bbb&quot;<br><span class="hljs-number">3</span>) &quot;a<br></code></pre></td></tr></table></figure><h4 id="2-3-数据结构"><a href="#2-3-数据结构" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h4><p>​List的数据结构为快速链表quickList</p><p>​    首先在列表元素较少的情况下使用ziplist，即压缩列表。它将所有的元素紧挨在一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，需要两个额外的指针prev和next。Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516095854166.png?raw=true" alt="image-20240516095854166"></p><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>​set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的,且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>​</p><p>​Redis的Set是string类型的无序集合,底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1) ，O(1)，数据增加，查找数据的时间不变</p><h4 id="3-2-常用命令"><a href="#3-2-常用命令" class="headerlink" title="3.2 常用命令"></a>3.2 常用命令</h4><p><strong>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> ..... <br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 v1 v1 v2 v3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br><br></code></pre></td></tr></table></figure><p><strong>取出该集合的所有值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 v1 v1 v2 v3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p> <strong>判断集合key是否为含有该value值，有1，没有0</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> sismember<br>k1 v1<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>返回该集合的元素个数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> scard k1<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>删除集合中的某个元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span> .... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> srem k1 v1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>随机从该集合中吐出n个值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [n]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> spop k1 <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br></code></pre></td></tr></table></figure><p><strong>随机从该集合中取出n个值，不会从集合中删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">srandmember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [n]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> srandmember k1 <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br></code></pre></td></tr></table></figure><p><strong>把集合中一个值从一个集合移动到另一个集合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">smove <span class="hljs-operator">&lt;</span>source<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>destination<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k2 p1 p2 p3<br><span class="hljs-number">3</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;p2&quot;<br><span class="hljs-number">2</span>) &quot;p3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smove k1 k2 v1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的交集元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sinter k1 k2<br><br>localhost:db0<span class="hljs-operator">&gt;</span> sadd k1 p1<br><span class="hljs-number">1</span><br>localhost:db0<span class="hljs-operator">&gt;</span> sinter k1 k2<br><span class="hljs-number">1</span>) &quot;p1&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的并集元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sunion k1 k2<br><span class="hljs-number">1</span>) &quot;p1&quot;<br><span class="hljs-number">2</span>) &quot;v2&quot;<br><span class="hljs-number">3</span>) &quot;v3&quot;<br><span class="hljs-number">4</span>) &quot;v1&quot;<br><span class="hljs-number">5</span>) &quot;p2&quot;<br><span class="hljs-number">6</span>) &quot;p3&quot;<br></code></pre></td></tr></table></figure><p><strong>返回两个集合的差集元素(key1中与key2不重复的value)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k1<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br><span class="hljs-number">3</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> smembers k2<br><span class="hljs-number">1</span>) &quot;v1&quot;<br><span class="hljs-number">2</span>) &quot;p2&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br><span class="hljs-number">4</span>) &quot;p1&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sdiff k1 k2<br><span class="hljs-number">1</span>) &quot;v2&quot;<br><span class="hljs-number">2</span>) &quot;v3&quot;<br>localhost:db0<span class="hljs-operator">&gt;</span> sdiff k2 k1<br><span class="hljs-number">1</span>) &quot;p2&quot;<br><span class="hljs-number">2</span>) &quot;v1&quot;<br><span class="hljs-number">3</span>) &quot;p3&quot;<br></code></pre></td></tr></table></figure><h4 id="2-3-数据结构-1"><a href="#2-3-数据结构-1" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h4><p>​Set数据结构是dict字典，字典是用哈希表实现的</p><p>​Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id="4-哈希-hash"><a href="#4-哈希-hash" class="headerlink" title="4 哈希(hash)"></a>4 哈希(hash)</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><p>​Redis hash 是一个键值对集合</p><p>​Redis hash 是一个string 类型的field和value的映射表 ,hash 特别适合用于存储对象,类似java里面的Map&lt;string,Object&gt;</p><h4 id="4-2-常用命令"><a href="#4-2-常用命令" class="headerlink" title="4.2 常用命令"></a>4.2 常用命令</h4><p><strong>给key集合中的 field键赋值value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hset key [field <span class="hljs-keyword">value</span> ...]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> hset <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name cz grade <span class="hljs-number">88</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>从集合取出 value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hget <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br>cz<br></code></pre></td></tr></table></figure><p><strong>批量设置hash的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hmset <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field2<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>... <br><br>localhost:db0<span class="hljs-operator">&gt;</span> hmset <span class="hljs-keyword">user</span>:<span class="hljs-number">2</span> name yu grade <span class="hljs-number">90</span><br>OK<br></code></pre></td></tr></table></figure><p><strong>查看哈希表 key 中，给定域 field 是否存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">hexists<span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hexists <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>列出该hash集合的所有field</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">hkeys <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hkeys <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;name&quot;<br><span class="hljs-number">2</span>) &quot;grade&quot;<br></code></pre></td></tr></table></figure><p><strong>列出该hash集合的所有value</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hvals <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) &quot;cz&quot;<br><span class="hljs-number">2</span>) &quot;88&quot;<br></code></pre></td></tr></table></figure><p><strong>为哈希表 key 中的域 field 的值加上增量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">hincrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>increment<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> hincrby <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> grade <span class="hljs-number">4</span><br><span class="hljs-number">92</span><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> grade<br><span class="hljs-number">92</span><br></code></pre></td></tr></table></figure><p><strong>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">hsetnx <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>field<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>.<br><br>localhost:db0<span class="hljs-operator">&gt;</span> hsetnx <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name io<br><span class="hljs-number">0</span><br>localhost:db0<span class="hljs-operator">&gt;</span> hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> name<br>cz<br></code></pre></td></tr></table></figure><h4 id="4-3-数据结构"><a href="#4-3-数据结构" class="headerlink" title="4.3 数据结构"></a>4.3 数据结构</h4><p>​Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id="5-有序集合-Zset-sorted-set"><a href="#5-有序集合-Zset-sorted-set" class="headerlink" title="5 有序集合(Zset(sorted set))"></a>5 有序集合(Zset(sorted set))</h3><h4 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h4><p>​序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>​不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可重复因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h4><p><strong>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">zadd  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>score1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value1<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>score2<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>value2<span class="hljs-operator">&gt;</span>…<br><br>localhost:db0<span class="hljs-operator">&gt;</span> zadd topn <span class="hljs-number">200</span> java <span class="hljs-number">300</span> python <span class="hljs-number">150</span> c<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>返回有序集 key 中，下标在 start stop之间的元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>stop<span class="hljs-operator">&gt;</span>  [WITHSCORES]  <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</strong></p><p>有序集成员按 score 值递增(从小到大)次序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrangebyscore key min max [withscores] [limit <span class="hljs-keyword">offset</span> count]<br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrangebyscore topn <span class="hljs-number">200</span> <span class="hljs-number">500</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>有序集成员按 score 值递增(从大到小)次序排列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrevrangebyscore key max min [withscores] [limit <span class="hljs-keyword">offset</span> count]    <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrevrangebyscore topn <span class="hljs-number">500</span> <span class="hljs-number">200</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p><strong>为元素的score加上增量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">zincrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>increment<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>    <br><br>localhost:db0<span class="hljs-operator">&gt;</span> zincrby topn <span class="hljs-number">50</span> java<br><span class="hljs-number">250</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">250</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>删除该集合下，指定值的元素</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrem  <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrem topc c<br><span class="hljs-number">0</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrange topn <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) &quot;c&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">150</span><br><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) &quot;java&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">250</span><br><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) &quot;python&quot;<br><span class="hljs-number">2</span>) <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p><strong>统计该集合，分数区间内的元素个数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>min<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>max<span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zcount topn <span class="hljs-number">100</span> <span class="hljs-number">500</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>返回该值在集合中的排名，从0开始</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><br>localhost:db0<span class="hljs-operator">&gt;</span> zrank topn python<br><span class="hljs-number">2</span><br>localhost:db0<span class="hljs-operator">&gt;</span> zrank topn java<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="5-3-数据结构"><a href="#5-3-数据结构" class="headerlink" title="5.3 数据结构"></a>5.3 数据结构</h4><p>​SortedSet(zset)是Redis提供的一个非常特别的数据结构,一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>set底层使用了两个数据结构<br>（1）<strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）<strong>跳跃表</strong>，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</p><h5 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a><strong>跳跃表（跳表）</strong></h5><p>1 简介</p><pre><code class="hljs">      有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</code></pre><p>2、实例<br>         对比有序链表和跳跃表，从链表中查询出51<br>        （1）有序链表<br>      要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>​<img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516110419403.png?raw=true" alt="image-20240516110419403"></p><p>​（2）跳跃表</p><p>​   <img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240516110521024.png?raw=true" alt="image-20240516110521024">  </p><p>​</p><p>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>跳跃表比有序链表效率要高</p><h2 id="reids-操作命令"><a href="#reids-操作命令" class="headerlink" title="reids 操作命令"></a>reids 操作命令</h2><blockquote><p>redis 默认为 16 个库 (在 redis.conf 文件可配置，该文件很重要，后续很多操作都是这个配置文件) redis 默认自动使用 0 号库</p></blockquote><p><strong>沟通命令，查看状态</strong></p><p>连接到客户端之后，输入ping，redis返回pong。表示redis能够正常运行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> ping<br>PONG<br></code></pre></td></tr></table></figure><p><strong>查看当前数据库中key的数量：dbsize</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> dbsize<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>切换库命令：select db</strong></p><p>库的下标从0开始，redis.conf配置中默认16个库。下标0-15</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">localhost:db0<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-number">5</span><br>OK<br>localhost:db5<span class="hljs-operator">&gt;</span> dbsize<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>删除当前数据库的所有数据：flushdb</strong></p><p><strong>退出客户端连接：exit或者quit</strong></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级1</title>
    <link href="/2024/05/27/tools/Mysql%E9%AB%98%E7%BA%A71/"/>
    <url>/2024/05/27/tools/Mysql%E9%AB%98%E7%BA%A71/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql高级1"><a href="#Mysql高级1" class="headerlink" title="Mysql高级1"></a>Mysql高级1</h1><h3 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h3><table><thead><tr><th align="center">序号</th><th>Day01</th><th>Day02</th><th>Day03</th><th>Day04</th></tr></thead><tbody><tr><td align="center">1</td><td>Linux系统安装MySQL</td><td>体系结构</td><td>应用优化</td><td>MySQL 常用工具</td></tr><tr><td align="center">2</td><td>索引</td><td>存储引擎</td><td>查询缓存优化</td><td>MySQL 日志</td></tr><tr><td align="center">3</td><td>视图</td><td>优化SQL步骤</td><td>内存管理及优化</td><td>MySQL 主从复制</td></tr><tr><td align="center">4</td><td>存储过程和函数</td><td>索引使用</td><td>MySQL锁问题</td><td>综合案例</td></tr><tr><td align="center">5</td><td>触发器</td><td>SQL优化</td><td>常用SQL技巧</td><td></td></tr></tbody></table><h3 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1. Linux 系统安装MySQL"></a>1. Linux 系统安装MySQL</h3><h4 id="1-1-下载Linux-安装包"><a href="#1-1-下载Linux-安装包" class="headerlink" title="1.1 下载Linux 安装包"></a>1.1 下载Linux 安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/downloads/my</span>sql/<span class="hljs-number">5.7</span>.html<span class="hljs-comment">#downloads</span><br></code></pre></td></tr></table></figure><h4 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1.2 安装MySQL"></a>1.2 安装MySQL</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>). 卸载 centos 中预安装的 mysql<br><br><span class="hljs-attribute">rpm</span> -qa | grep -i mysql<br><br><span class="hljs-attribute">rpm</span> -e mysql-libs-<span class="hljs-number">5</span>.<span class="hljs-number">1</span>.<span class="hljs-number">71</span>-<span class="hljs-number">1</span>.el6.x86_64 --nodeps<br><br><span class="hljs-attribute">2</span>). 上传 mysql 的安装包<br><br><span class="hljs-attribute">alt</span> + p -------&gt; put  E:/test/MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar<br><br><span class="hljs-attribute">3</span>). 解压 mysql 的安装包 <br><br><span class="hljs-attribute">mkdir</span> mysql<br><br><span class="hljs-attribute">tar</span> -xvf MySQL-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm-bundle.tar -C /root/mysql<br><br><span class="hljs-attribute">4</span>). 安装依赖包 <br><br><span class="hljs-attribute">yum</span> -y install libaio.so.<span class="hljs-number">1</span> libgcc_s.so.<span class="hljs-number">1</span> libstdc++.so.<span class="hljs-number">6</span> libncurses.so.<span class="hljs-number">5</span> --setopt=protected_multilib=false<br><br><span class="hljs-attribute">yum</span>  update libstdc++-<span class="hljs-number">4</span>.<span class="hljs-number">4</span>.<span class="hljs-number">7</span>-<span class="hljs-number">4</span>.el6.x86_64<br><br><span class="hljs-attribute">5</span>). 安装 mysql-client<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-client-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br><span class="hljs-attribute">6</span>). 安装 mysql-server<br><br><span class="hljs-attribute">rpm</span> -ivh MySQL-server-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">22</span>-<span class="hljs-number">1</span>.el6.i686.rpm<br><br></code></pre></td></tr></table></figure><h4 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">service mysql <span class="hljs-keyword">start</span><br><br>service mysql stop<br><br>service mysql status<br><br>service mysql restart<br></code></pre></td></tr></table></figure><h4 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : /root/.mysql_secret<br><br>mysql -u root -p <br><br>登录之后, 修改密码 :<br><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> = <span class="hljs-keyword">password</span>(<span class="hljs-string">&#x27;itcast&#x27;</span>);<br><br>授权远程访问 : <br><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;root&#x27;</span> @<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br><br></code></pre></td></tr></table></figure><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的&#x3D;&#x3D;示意图&#x3D;&#x3D;所示 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093105938.png?raw=true" alt="image-20240511093105938"></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p><h4 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h4><p>优势</p><p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p><p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>劣势</p><p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p><p>2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><h4 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h4><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h5 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h5><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[ceil(m&#x2F;2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。所以 2 &lt;&#x3D; n &lt;&#x3D;4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p>演变过程如下：</p><p>1). 插入前4个字母 C N G A </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093133875.png?raw=true" alt="image-20240511093133875"></p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093226560.png?raw=true" alt="image-20240511093226560"></p><p>3). 插入E，K，Q不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093242231.png?raw=true" alt="image-20240511093242231"></p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093256714.png?raw=true" alt="image-20240511093256714"></p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093311693.png?raw=true" alt="image-20240511093311693"></p><p>6). 插入Z，中间元素T向上分裂到父节点中 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093325753.png?raw=true" alt="image-20240511093325753"></p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093339035.png?raw=true" alt="image-20240511093339035"> </p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p> <img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093408372.png?raw=true" alt="image-20240511093408372"></p><p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p><h5 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h5><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p><p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p><p>3). 所有的非叶子节点都可以看作是key的索引部分。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511095521998.png?raw=true" alt="image-20240511095521998"></p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><h5 id="2-3-3-MySQL中的B-Tree"><a href="#2-3-3-MySQL中的B-Tree" class="headerlink" title="2.3.3 MySQL中的B+Tree"></a>2.3.3 MySQL中的B+Tree</h5><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p>MySQL中的 B+Tree 索引结构示意图: </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093508330.png?raw=true" alt="image-20240511093508330">  </p><h4 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h4><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p><p>2） 唯一索引 ：索引列的值必须唯一，但允许有空值</p><p>3） 复合索引 ：即一个索引包含多个列</p><h4 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h4><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p><p>准备环境:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database demo_01 <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br>use demo_01;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `city` (<br>  `city_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `city_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`city_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `country` (<br>  `country_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `country_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`country_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;西安&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;NewYork&#x27;</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;China&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;America&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Japan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `country` (`country_id`, `country_name`) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;UK&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h5><p>语法 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span><span class="hljs-operator">|</span>FULLTEXT<span class="hljs-operator">|</span>SPATIAL]  INDEX index_name <br>[<span class="hljs-keyword">USING</span>  index_type]<br><span class="hljs-keyword">ON</span> tbl_name(index_col_name,...)<br><br><br>index_col_name : column_name[(length)][<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure><p>示例 ： 为city表中的city_name字段创建索引 ；</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093540046.png?raw=true" alt="image-20240511093540046">      </p><p>​</p><h5 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h5><p>语法： </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span>  <span class="hljs-keyword">from</span>  <span class="hljs-built_in">table_name</span>;<br></code></pre></td></tr></table></figure><p>示例：查看city表中的索引信息；</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093603250.png?raw=true" alt="image-20240511093603250"> </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093619542.png?raw=true" alt="image-20240511093619542">  </p><h5 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h5><p>语法 ：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">INDEX</span>  index_name  <span class="hljs-keyword">ON</span>  tbl_name;<br></code></pre></td></tr></table></figure><p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093636153.png?raw=true" alt="image-20240511093636153">  </p><h5 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sas">1). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">primary</span>  <span class="hljs-keyword">key</span>(column_list); <br><br>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="hljs-keyword">NULL</span><br><br>2). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">unique</span> index_name(column_list);<br><br>这条语句创建索引的值必须是唯一的（除了<span class="hljs-keyword">NULL</span>外，<span class="hljs-keyword">NULL</span>可能会出现多次）<br><br>3). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  <span class="hljs-keyword">index</span> index_name(column_list);<br><br>添加普通索引， 索引值可以出现多次。<br><br>4). <span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span>  tb_name  <span class="hljs-keyword">add</span>  fulltext  index_name(column_list);<br><br>该语句指定了索引为FULLTEXT， 用于全文索引<br><br></code></pre></td></tr></table></figure><h4 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h4><p>​索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p><ul><li><p>对查询频次较高，且数据量比较大的表建立索引。</p></li><li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p></li><li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p></li><li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。</p></li><li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">创建复合索引:<br><br>CREATE <span class="hljs-built_in">INDEX</span> idx_name_email_status ON tb_seller(<span class="hljs-keyword">NAME</span>,email,<span class="hljs-keyword">STATUS</span>);<br><br>就相当于<br>对<span class="hljs-keyword">name</span> 创建索引 ;<br>对<span class="hljs-keyword">name</span> , email 创建了索引 ;<br>对<span class="hljs-keyword">name</span> , email, <span class="hljs-keyword">status</span> 创建了索引 ;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h3><h4 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h4><p>​视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><p>视图相对于普通的表的优势主要包括以下几项。</p><ul><li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li><li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li></ul><h4 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h4><p>创建视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><p>修改视图的语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> [ALGORITHM <span class="hljs-operator">=</span> &#123;UNDEFINED <span class="hljs-operator">|</span> <span class="hljs-keyword">MERGE</span> <span class="hljs-operator">|</span> TEMPTABLE&#125;]<br><br><span class="hljs-keyword">VIEW</span> view_name [(column_list)]<br><br><span class="hljs-keyword">AS</span> select_statement<br><br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION]<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">选项 : <br><span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION 决定了是否允许更新数据使记录不再满足视图的条件。<br><br><span class="hljs-keyword">LOCAL</span> ： 只要满足本视图的条件就可以更新。<br><span class="hljs-keyword">CASCADED</span> ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.<br></code></pre></td></tr></table></figure><p>示例 , 创建city_country_view视图 , 执行如下SQL : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> city_country_view <br><span class="hljs-keyword">as</span> <br><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span>,c.country_name <span class="hljs-keyword">from</span> country c , city t <span class="hljs-keyword">where</span> c.country_id <span class="hljs-operator">=</span> t.country_id;<br><br></code></pre></td></tr></table></figure><p>查询视图 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093657857.png?raw=true" alt="image-20240511093657857"> </p><h4 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h4><p>​从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093713607.png?raw=true" alt="image-20240511093713607"> </p><p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093736277.png?raw=true" alt="image-20240511093736277"> </p><p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240511093747136.png?raw=true" alt="image-20240511093747136">  </p><h4 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h4><p>语法 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT <span class="hljs-operator">|</span> CASCADE]<br></code></pre></td></tr></table></figure><p>示例 , 删除视图city_country_view :</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">DROP</span> <span class="hljs-built_in">VIEW</span> city_country_view ;<br></code></pre></td></tr></table></figure><h3 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h3><h4 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h4><p>​存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>​存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p><p>​函数 ： 是一个有返回值的过程 ；</p><p>​过程 ： 是一个没有返回值的函数 ；</p><h4 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> procedure_name ([proc_parameter[,...]])<br><span class="hljs-keyword">begin</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">end</span> ;<br></code></pre></td></tr></table></figure><p>示例 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test1()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Hello Mysql&#x27;</span> ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p><strong><font color="red">知识小贴士</font></strong></p><p>DELIMITER</p><p>​该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p><p>dbeaver 图形工具新修改执行命令即可</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4570978019.jpg?raw=true" alt="img"></p><h4 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">call</span> procedure_name() ;<br></code></pre></td></tr></table></figure><h4 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询db_name数据库中的所有的存储过程</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> mysql.proc <span class="hljs-keyword">where</span> db<span class="hljs-operator">=</span><span class="hljs-string">&#x27;db_name&#x27;</span>;<br><br><br><span class="hljs-comment">-- 查询存储过程的状态信息</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">procedure</span> status;<br><br><br><span class="hljs-comment">-- 查询某个存储过程的定义</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> test.pro_test1 \G;<br></code></pre></td></tr></table></figure><h4 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span>  [IF <span class="hljs-keyword">EXISTS</span>] sp_name ；<br></code></pre></td></tr></table></figure><h4 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h4><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p><h5 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h5><ul><li>DECLARE</li></ul><p>  通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> var_name[,...] type [<span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">value</span>]<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test2() <br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> num<span class="hljs-operator">+</span> <span class="hljs-number">10</span>; <br><span class="hljs-keyword">end</span>$<br><br>delimiter ; <br></code></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET var_name = <span class="hljs-built_in">expr</span> [, var_name = <span class="hljs-built_in">expr</span>] ...<br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test3()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">SET</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MYSQL&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> NAME ;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>也可以通过select … into 方式进行赋值操作 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL">DELIMITER $<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> pro_test5()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">declare</span>  countnum <span class="hljs-type">int</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> countnum <span class="hljs-keyword">from</span> city;<br><span class="hljs-keyword">select</span> countnum;<br><span class="hljs-keyword">END</span>$<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h5 id="4-6-2-if条件判断"><a href="#4-6-2-if条件判断" class="headerlink" title="4.6.2 if条件判断"></a>4.6.2 if条件判断</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">if search_condition <span class="hljs-keyword">then</span> statement_list<br><br>[elseif search_condition <span class="hljs-keyword">then</span> statement_list] ...<br><br>[<span class="hljs-keyword">else</span> statement_list]<br><br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><p>需求： </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">根据定义的身高变量，判定当前身高的所属的身材类型 <br><br><span class="hljs-number">180</span> 及以上 <span class="hljs-comment">----------&gt; 身材高挑</span><br><br><span class="hljs-number">170</span> - <span class="hljs-number">180</span>  <span class="hljs-comment">---------&gt; 标准身材</span><br><br><span class="hljs-number">170</span> 以下  <span class="hljs-comment">----------&gt; 一般身材</span><br></code></pre></td></tr></table></figure><p>示例 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test6()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span>  height  <span class="hljs-type">int</span>  <span class="hljs-keyword">default</span>  <span class="hljs-number">175</span>; <br>  <span class="hljs-keyword">declare</span>  description  <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <br>  if  height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span>  <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br>  <br>  <span class="hljs-keyword">select</span> description ;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><p>调用结果为 : </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240510165046431.png?raw=true" alt="image-20240510165046431"></p><h5 id="4-6-3-传递参数"><a href="#4-6-3-传递参数" class="headerlink" title="4.6.3 传递参数"></a>4.6.3 传递参数</h5><p>语法格式 : </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-title function_">procedure_name</span><span class="hljs-params">([<span class="hljs-keyword">in</span>/<span class="hljs-keyword">out</span>/inout] 参数名   参数类型)</span><br>...<br><br><br><span class="hljs-title function_">IN</span> :   该参数可以作为输入，也就是需要调用方传入值 , 默认<br><span class="hljs-keyword">OUT</span>:   该参数作为输出，也就是该参数可以作为返回值<br>INOUT: 既可以作为输入参数，也可以作为输出参数<br></code></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据定义的身高变量，判定当前身高的所属的身材类型 <br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;身高 &#x27;</span>, height , <span class="hljs-string">&#x27;对应的身材类型为:&#x27;</span>,description);<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br><span class="hljs-keyword">CALL</span> pro_test5(<span class="hljs-number">180</span>); #调用<br><br># 返回<br>身高 <span class="hljs-number">180</span>对应的身材类型为:身材高挑<br></code></pre></td></tr></table></figure><p><strong>OUT-输出</strong></p><p> 需求 :</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">根据传入的身高变量，获取当前身高的所属的身材类型  <br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test5(<span class="hljs-keyword">in</span> height <span class="hljs-type">int</span> , <span class="hljs-keyword">out</span> description <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>))<br><span class="hljs-keyword">begin</span><br>  if height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;身材高挑&#x27;</span>;<br>  elseif height <span class="hljs-operator">&gt;=</span> <span class="hljs-number">170</span> <span class="hljs-keyword">and</span> height <span class="hljs-operator">&lt;</span> <span class="hljs-number">180</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;标准身材&#x27;</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">set</span> description<span class="hljs-operator">=</span><span class="hljs-string">&#x27;一般身材&#x27;</span>;<br>  <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span>$<br></code></pre></td></tr></table></figure><p>调用:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">call</span> <span class="hljs-selector-tag">pro_test5</span>(<span class="hljs-number">168</span>, <span class="hljs-variable">@description</span>);<br><span class="hljs-selector-tag">select</span> @<span class="hljs-selector-tag">description</span>;<br></code></pre></td></tr></table></figure><p><font color='red'><strong>小知识</strong> </font></p><p>@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p><p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 </p><h5 id="4-6-4-case结构"><a href="#4-6-4-case结构" class="headerlink" title="4.6.4 case结构"></a>4.6.4 case结构</h5><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs SQL">方式一 : <br><br><span class="hljs-keyword">CASE</span> case_value<br><br>  <span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> when_value <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br><br>方式二 : <br><br><span class="hljs-keyword">CASE</span><br><br>  <span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list<br>  <br>  [<span class="hljs-keyword">WHEN</span> search_condition <span class="hljs-keyword">THEN</span> statement_list] ...<br>  <br>  [<span class="hljs-keyword">ELSE</span> statement_list]<br>  <br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">给定一个月份, 然后计算出所在的季度<br></code></pre></td></tr></table></figure><p>示例  :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test9(<span class="hljs-keyword">month</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> <span class="hljs-keyword">result</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>);<br>  <span class="hljs-keyword">case</span> <br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">3</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第一季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">6</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第二季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">9</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第三季度&#x27;</span>;<br>    <span class="hljs-keyword">when</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span> <span class="hljs-operator">&lt;=</span><span class="hljs-number">12</span> <span class="hljs-keyword">then</span> <br>      <span class="hljs-keyword">set</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;第四季度&#x27;</span>;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br>  <br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;您输入的月份为 :&#x27;</span>, <span class="hljs-keyword">month</span> , <span class="hljs-string">&#x27; , 该月份为 : &#x27;</span> , <span class="hljs-keyword">result</span>) <span class="hljs-keyword">as</span> content ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br><br><br><span class="hljs-keyword">call</span> pro_test9(<span class="hljs-number">3</span>);<br><br># 返回<br>content<br>您输入的月份为 :<span class="hljs-number">3</span> , 该月份为 : 第一季度<br></code></pre></td></tr></table></figure><h5 id="4-6-5-while循环"><a href="#4-6-5-while循环" class="headerlink" title="4.6.5 while循环"></a>4.6.5 while循环</h5><p>语法结构: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">while search_condition do<br><br>statement_list<br><br><span class="hljs-keyword">end</span> while;<br></code></pre></td></tr></table></figure><p>需求:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test8(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">declare</span> num <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  while num<span class="hljs-operator">&lt;=</span>n do<br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> num;<br><span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> num <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span> while;<br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test8(<span class="hljs-number">3</span>);<br><br>#返回<br>totle<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h5 id="4-6-6-repeat结构"><a href="#4-6-6-repeat结构" class="headerlink" title="4.6.6 repeat结构"></a>4.6.6 repeat结构</h5><p>有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。</p><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL">REPEAT<br><br>  statement_list<br><br>  UNTIL search_condition<br><br><span class="hljs-keyword">END</span> REPEAT;<br></code></pre></td></tr></table></figure><p>需求: </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">计算从<span class="hljs-number">1</span>加到<span class="hljs-built_in">n</span>的值<br></code></pre></td></tr></table></figure><p>示例  : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test10(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  repeat <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>    until n<span class="hljs-operator">=</span><span class="hljs-number">0</span>  <br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">select</span> total ;<br>  <br><span class="hljs-keyword">end</span>$<br><br><br>delimiter ;<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test10(<span class="hljs-number">5</span>);<br><br># 返回<br>totle<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h5 id="4-6-7-loop语句"><a href="#4-6-7-loop语句" class="headerlink" title="4.6.7 loop语句"></a>4.6.7 loop语句</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">[begin_label:] LOOP<br><br>  statement_list<br><br><span class="hljs-keyword">END</span> LOOP [end_label]<br></code></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。</p><h5 id="4-6-8-leave语句"><a href="#4-6-8-leave语句" class="headerlink" title="4.6.8 leave语句"></a>4.6.8 leave语句</h5><p>用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SQL">delimiter $<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> pro_test11(n <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">declare</span> total <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br>  <br>  ins: LOOP<br>    <br>    IF n <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>      leave ins;<br>    <span class="hljs-keyword">END</span> IF;<br>    <br>    <span class="hljs-keyword">set</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> n;<br>    <span class="hljs-keyword">set</span> n <span class="hljs-operator">=</span> n <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">END</span> LOOP ins;<br>  <br>  <span class="hljs-keyword">select</span> total;<br><span class="hljs-keyword">END</span>$<br><br>delimiter ;<br></code></pre></td></tr></table></figure><h5 id="4-6-9-游标-光标"><a href="#4-6-9-游标-光标" class="headerlink" title="4.6.9 游标&#x2F;光标"></a>4.6.9 游标&#x2F;光标</h5><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> cursor_name <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> select_statement ;<br></code></pre></td></tr></table></figure><p>OPEN 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">OPEN</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>FETCH 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FETCH</span> cursor_name <span class="hljs-keyword">INTO</span> var_name [, var_name] ...<br></code></pre></td></tr></table></figure><p>CLOSE 光标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CLOSE</span> cursor_name ;<br></code></pre></td></tr></table></figure><p>示例 : </p><p>初始化脚本:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment ,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;薪水&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;金毛狮王&#x27;</span>,<span class="hljs-number">55</span>,<span class="hljs-number">3800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;白眉鹰王&#x27;</span>,<span class="hljs-number">60</span>,<span class="hljs-number">4000</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;青翼蝠王&#x27;</span>,<span class="hljs-number">38</span>,<span class="hljs-number">2800</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;紫衫龙王&#x27;</span>,<span class="hljs-number">42</span>,<span class="hljs-number">1800</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 查询emp表中数据, 并逐行获取进行展示</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test11()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> e_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">declare</span> e_age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> e_salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">declare</span> emp_result <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> e_id,e_name,e_age,e_salary;<br>  <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id=&#x27;</span>,e_id , <span class="hljs-string">&#x27;, name=&#x27;</span>,e_name, <span class="hljs-string">&#x27;, age=&#x27;</span>, e_age, <span class="hljs-string">&#x27;, 薪资为: &#x27;</span>,e_salary);<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br># 调用<br><span class="hljs-keyword">call</span> pro_test11();<br><br># 返回 <br><span class="hljs-keyword">No</span> data <span class="hljs-operator">-</span> zero <span class="hljs-keyword">rows</span> fetched, selected, <span class="hljs-keyword">or</span> processed    # 因为多出一次获取游标数据 四次返回正常<br><br><br></code></pre></td></tr></table></figure><p>通过循环结构 , 获取游标中的数据 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> pro_test12()<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">DECLARE</span> age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> salary <span class="hljs-type">int</span>(<span class="hljs-number">11</span>);<br>  <span class="hljs-keyword">DECLARE</span> has_data <span class="hljs-type">int</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">DECLARE</span> emp_result <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br>  <span class="hljs-keyword">DECLARE</span> EXIT HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">open</span> emp_result;<br>  <br>  repeat<br>    <span class="hljs-keyword">fetch</span> emp_result <span class="hljs-keyword">into</span> id , name , age , salary;<br>    <span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id为&#x27;</span>,id, <span class="hljs-string">&#x27;, name 为&#x27;</span> ,name , <span class="hljs-string">&#x27;, age为 &#x27;</span> ,age , <span class="hljs-string">&#x27;, 薪水为: &#x27;</span>, salary);<br>    until has_data <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">end</span> repeat;<br>  <br>  <span class="hljs-keyword">close</span> emp_result;<br><span class="hljs-keyword">end</span>$<br><br>DELIMITER ; <br># 调用<br><span class="hljs-keyword">call</span> pro_test11();<br><br># 返回 <br>id为<span class="hljs-number">1</span>, name 为金毛狮王, age为 <span class="hljs-number">55</span>, 薪水为: <span class="hljs-number">3800</span><br>id为<span class="hljs-number">2</span>, name 为白眉鹰王, age为 <span class="hljs-number">60</span>, 薪水为: <span class="hljs-number">4000</span><br>id为<span class="hljs-number">3</span>, name 为青翼蝠王, age为 <span class="hljs-number">38</span>, 薪水为: <span class="hljs-number">2800</span><br>id为<span class="hljs-number">4</span>, name 为紫衫龙王, age为 <span class="hljs-number">42</span>, 薪水为: <span class="hljs-number">1800</span><br></code></pre></td></tr></table></figure><h4 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h4><p>语法结构:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> function_name([param <span class="hljs-built_in">type</span> ... ]) <br>RETURNS <span class="hljs-built_in">type</span> <br><span class="hljs-keyword">BEGIN</span><br>...<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>案例 : </p><p>定义一个存储过程, 请求满足条件的总记录数 ;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><br>delimiter $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> count_city(countryId <span class="hljs-type">int</span>)<br><span class="hljs-keyword">returns</span> <span class="hljs-type">int</span> <span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">declare</span> cnum <span class="hljs-type">int</span> ;<br>  <br>  <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> cnum <span class="hljs-keyword">from</span> city <span class="hljs-keyword">where</span> country_id <span class="hljs-operator">=</span> countryId;<br>  <br>  <span class="hljs-keyword">return</span> cnum;<br><span class="hljs-keyword">end</span>$<br><br>delimiter ;<br><br># 确定函数属性 不确定无法创建<br><span class="hljs-keyword">DETERMINISTIC</span>: 如果你的函数对于相同的输入参数，每次调用都返回相同的结果，且不依赖于外部状态或数据库状态的变化，就可以声明为 <span class="hljs-keyword">DETERMINISTIC</span>。例如，一个计算两个数字相加的函数就是确定性的。<br><br><span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span>: 如果你的函数完全不包含任何 <span class="hljs-keyword">SQL</span> 语句，也就是说它不读取也不修改数据库中的数据，可以声明为 <span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span>。<br><br><span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA: 如果你的函数读取数据库中的数据但不修改数据，应声明为 <span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA。<br></code></pre></td></tr></table></figure><p>调用: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count_city</span>(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h4 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h4><p>语法结构 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> trigger_name <br><br>before<span class="hljs-operator">/</span>after <span class="hljs-keyword">insert</span><span class="hljs-operator">/</span><span class="hljs-keyword">update</span><span class="hljs-operator">/</span><span class="hljs-keyword">delete</span><br><br><span class="hljs-keyword">on</span> tbl_name <br><br>[ <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> ]  <span class="hljs-comment">-- 行级触发器</span><br><br><span class="hljs-keyword">begin</span><br><br>trigger_stmt ;<br><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>示例 </p><p>需求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;<br></code></pre></td></tr></table></figure><p>首先创建一张日志表 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp_logs(<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>  operation <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作类型, insert/update/delete&#x27;</span>,<br>  operate_time datetime <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,<br>  operate_id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;操作表的ID&#x27;</span>,<br>  operate_params <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) comment <span class="hljs-string">&#x27;操作参数&#x27;</span>,<br>  <span class="hljs-keyword">primary</span> key(`id`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>创建 insert 型触发器，完成插入数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_insert_trigger<br>after <span class="hljs-keyword">insert</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));<br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建 update 型触发器，完成更新数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_update_trigger<br>after <span class="hljs-keyword">update</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="hljs-string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="hljs-string">&#x27;name:&#x27;</span>,new.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,new.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,new.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> emp_logs_delete_trigger<br>after <span class="hljs-keyword">delete</span> <br><span class="hljs-keyword">on</span> emp <br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> <br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="hljs-string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="hljs-string">&#x27;, name:&#x27;</span>,old.name,<span class="hljs-string">&#x27;, age:&#x27;</span>,old.age,<span class="hljs-string">&#x27;, salary:&#x27;</span>,old.salary,<span class="hljs-string">&#x27;)&#x27;</span>));                                                                      <br><span class="hljs-keyword">end</span> $<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明左使&#x27;</span>,<span class="hljs-number">30</span>,<span class="hljs-number">3500</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(id,name,age,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;光明右使&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-number">3200</span>);<br><br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">39</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h4><p>语法结构 : </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> [<span class="hljs-built_in">schema_name</span>.]trigger_name<br></code></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h4 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h4><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> triggers ；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora 用法</title>
    <link href="/2024/05/27/tools/Typora%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/27/tools/Typora%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Typora的语法"><a href="#Typora的语法" class="headerlink" title="Typora的语法"></a>Typora的语法</h2><p>表格<br>可以在—分割线加入：设置表格对齐方式<br>“:——–“表示左对齐，”:———:“表示居中对齐，”———-:”表示右对齐</p><p>无序列表：- + 空格<br>有序列表：1. + 空格<br>引用：&gt; + 空格<br>标题：ctrl + 数字<br>表格：ctrl + t<br>生成目录：[TOC] + 回车<br>选中一整行：ctrl + l<br>选中单词：ctrl + d<br>选中相同格式的文字：ctrl + e<br>跳转到文章开头：ctrl + home<br>跳转到文章结尾：ctrl + end<br>搜索：ctrl + f<br>替换：ctrl + h<br>加粗：ctrl + b<br>倾斜：ctrl + i<br>下划线：ctrl + u<br>删除线：alt + shift + 5<br>插入图片：直接拖动到指定位置即可或者ctrl + shift + i<br>插入链接：ctrl + k</p><p><a href="https://blog.csdn.net/qq_40896997/article/details/106551767">表情</a></p><p>:white_check_mark:</p><p>:x:</p><p>:heavy_check_mark:</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu_for_clash</title>
    <link href="/2024/05/27/tools/Ubuntu_for_clash/"/>
    <url>/2024/05/27/tools/Ubuntu_for_clash/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu配置翻墙软件"><a href="#Ubuntu配置翻墙软件" class="headerlink" title="Ubuntu配置翻墙软件"></a>Ubuntu配置翻墙软件</h1><p><a href="https://opclash.com/article/302.html">参考地址</a></p><h2 id="安装包配置"><a href="#安装包配置" class="headerlink" title="安装包配置"></a><strong>安装包配置</strong></h2><h3 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h3><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> clash &amp;&amp; <span class="hljs-built_in">cd</span> clash<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/Dreamacro/clash/releases/download/v1.18.0/clash-linux-amd64-v1.18.0.gz<br></code></pre></td></tr></table></figure><h3 id="2、解压授权"><a href="#2、解压授权" class="headerlink" title="2、解压授权"></a>2、解压授权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压文件</span><br>gzip -d clash-linux-amd64-v1.18.0.gz<br><br><span class="hljs-comment"># 给予权限</span><br><span class="hljs-built_in">chmod</span> +x clash-linux-amd64-v1.18.0<br><br><br><span class="hljs-comment"># 查看版本</span><br>./clash-linux-amd64-v1.18.0 -v<br></code></pre></td></tr></table></figure><h3 id="3、启动创建文件夹"><a href="#3、启动创建文件夹" class="headerlink" title="3、启动创建文件夹"></a>3、启动创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 Clash</span><br>./clash-linux-amd64-v1.18.0<br><br><span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">cd</span> ~/.config/clash/<br><br><span class="hljs-comment"># 导入订阅(尝试失败)</span><br>wget -O config.yaml 订阅地址<br><br><span class="hljs-comment"># 手动节点（适用于自建 复制config地址信息）</span><br><br>vim ~/.config/clash/config.yaml<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310271642850.png" alt="image-20231027164226790"></p><h3 id="4、配置环境变量"><a href="#4、配置环境变量" class="headerlink" title="4、配置环境变量"></a>4、配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;export http_proxy=http://127.0.0.1:7890\nexport https_proxy=http://127.0.0.1:7890&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>为防止意外，打开Ubuntu的“设置” 管理，在网络内将“网络代理”的自动改为“手动”</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310271644906.png" alt="image-20231027164429813"></p><h3 id="5、启动clash"><a href="#5、启动clash" class="headerlink" title="5、启动clash"></a>5、启动clash</h3><p>进入clash 二进制文件目录</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./clash-linux-amd64-<span class="hljs-built_in">v1</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>web页面cat </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 节点管理</span><br>http://clash.razord.top/<span class="hljs-comment">#/proxies</span><br><br><span class="hljs-comment">#设置凭证密码</span><br></code></pre></td></tr></table></figure><p>需要后台运行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nohup</span> ./clash-linux-amd64-v1.<span class="hljs-number">18</span>.<span class="hljs-number">0</span> &gt;/dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>停止查看进程id kill</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">super</span>@super:~/work/tools/clash$ ps -ef | grep clash<br><span class="hljs-attribute">super</span>      <span class="hljs-number">63953</span>   <span class="hljs-number">51347</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ./clash-linux-amd64-v1.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">super</span>      <span class="hljs-number">64324</span>   <span class="hljs-number">64035</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span>:<span class="hljs-number">54</span> pts/<span class="hljs-number">4</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto clash<br><br><span class="hljs-attribute">super</span>@super:~/work/tools/clash$ kill <span class="hljs-number">63953</span><br></code></pre></td></tr></table></figure><p>停止不能访问网络将代理设置禁用即可</p><p>脚本proxy.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>status=$1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设 status 参数用于决定是否开启或关闭代理配置</span><br>if [ &quot;$status&quot; = &quot;on&quot; ]; then<br>    echo &quot;开启代理配置&quot;<br>    sed -i &#x27;s/#export http_proxy/export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/#export https_proxy/export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>    echo &quot;启动clash服务&quot;<br>    clash<br>elif [ &quot;$status&quot; = &quot;off&quot; ]; then<br>    echo &quot;关闭代理配置&quot;<br>    sed -i &#x27;s/export http_proxy/#export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/export https_proxy/#export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>else<br>    echo &quot;未知的状态指令，请输入 &#x27;on&#x27; 或 &#x27;off&#x27;&quot;<br>fi<br><br></code></pre></td></tr></table></figure><p>通过参数控制是否配置本地代理环境，每次建议手动开启系统界面的网络配置</p><h2 id="docker-compose-yml-配置"><a href="#docker-compose-yml-配置" class="headerlink" title="docker-compose.yml 配置"></a>docker-compose.yml 配置</h2><h3 id="1、修改config-yaml配置"><a href="#1、修改config-yaml配置" class="headerlink" title="1、修改config.yaml配置"></a>1、修改config.yaml配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim  config.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将host从127.0.0.1 改称0.0.0.0 配合ui获取接口</span><br>external-controller: &#x27;0.0.0.0:9090&#x27;<br></code></pre></td></tr></table></figure><h3 id="2、配置环境变量代理"><a href="#2、配置环境变量代理" class="headerlink" title="2、配置环境变量代理"></a>2、配置环境变量代理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh proxy.sh on<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>status=$1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设 status 参数用于决定是否开启或关闭代理配置</span><br>if [ &quot;$status&quot; = &quot;on&quot; ]; then<br>    echo &quot;开启代理配置&quot;<br>    sed -i &#x27;s/#export http_proxy/export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/#export https_proxy/export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>elif [ &quot;$status&quot; = &quot;off&quot; ]; then<br>    echo &quot;关闭代理配置&quot;<br>    sed -i &#x27;s/export http_proxy/#export http_proxy/g&#x27; ~/.bashrc<br>    sed -i &#x27;s/export https_proxy/#export https_proxy/g&#x27; ~/.bashrc<br>    source ~/.bashrc<br>else<br>    echo &quot;未知的状态指令，请输入 &#x27;on&#x27; 或 &#x27;off&#x27;&quot;<br>fi<br></code></pre></td></tr></table></figure><p>并且在系统网络里面配置网络代理，手动——http&#x2F;https代理 127.0.0.1:7890   Socks主机 127.0.0.1:7891</p><h3 id="3、启动clash服务"><a href="#3、启动clash服务" class="headerlink" title="3、启动clash服务"></a>3、启动clash服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker-compose</span> <span class="hljs-string">up</span> <span class="hljs-string">-d</span><br><br><br><span class="hljs-comment"># docker-compose.yml</span><br><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.7&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">clash-server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">dreamacro/clash</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">clash</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7890:7890&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7891:7891&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config.yaml:/root/.config/clash/config.yaml</span><br><br>  <span class="hljs-attr">clash-ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">haishanh/yacd</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">clash-ui</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">5080</span><span class="hljs-string">:80</span><br></code></pre></td></tr></table></figure><h3 id="4、访问http-127-0-0-1-5080"><a href="#4、访问http-127-0-0-1-5080" class="headerlink" title="4、访问http://127.0.0.1:5080"></a>4、访问<a href="http://127.0.0.1:5080/">http://127.0.0.1:5080</a></h3><p>配置 API Base URL：<a href="http://localhost:9090/">http://localhost:9090</a>  ,点击add</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora 图床</title>
    <link href="/2024/05/27/tools/github%20%E5%9B%BE%E5%BA%8A/"/>
    <url>/2024/05/27/tools/github%20%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="typora-图床"><a href="#typora-图床" class="headerlink" title="typora 图床"></a>typora 图床</h1><h2 id="1、配置Github"><a href="#1、配置Github" class="headerlink" title="1、配置Github"></a>1、配置Github</h2><p>进入github平台 <a href="https://github.com/">github</a></p><p>登录账号 创建仓库</p><p>配置仓库名 勾选 Add a README file 点击create</p><p>点击头像 创建token 界面划到最下面 点击&lt;&gt;Developer settings 设置token永不过期</p><p>创建完保存好 仅可见一次</p><h2 id="2、配置PicGo"><a href="#2、配置PicGo" class="headerlink" title="2、配置PicGo"></a>2、<strong>配置PicGo</strong></h2><p>官网网站下载 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD">PicGo</a></p><p>安装完成之后配置Github图床配置</p><p>设定仓库名：Github用户名&#x2F;仓库名</p><p>设定分支名：main </p><p>设定Token: 前面保存的token信息</p><p>设定存储路径：img&#x2F;</p><p>设定自定义域名：使用cdn加速域名   </p><p><a href="https://cdn.staticaly.com/gh/gondmhd/blogImage@main">https://cdn.staticaly.com/gh/gondmhd/blogImage@main</a></p><h2 id="3、配置typora"><a href="#3、配置typora" class="headerlink" title="3、配置typora"></a>3、配置typora</h2><p>文件-偏好设置-图像设置图床配置 </p><p>外观 自定义字段大小</p><h3 id="3-1-typora颜色样式"><a href="#3-1-typora颜色样式" class="headerlink" title="3.1 typora颜色样式"></a>3.1 typora颜色样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;cornflowerblue&quot;</span>&gt;</span>蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;orange&quot;</span>&gt;</span>橘色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>红色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;<font color="cornflowerblue">蓝色</font>&#x3D;&#x3D;<br>&#x3D;&#x3D;<font color="orange">橘色</font>&#x3D;&#x3D;<br>&#x3D;&#x3D;<font color="red">红色</font>&#x3D;&#x3D;</p><h3 id="3-2-代码块Mac风格三个圆点"><a href="#3-2-代码块Mac风格三个圆点" class="headerlink" title="3.2 代码块Mac风格三个圆点"></a>3.2 代码块Mac风格三个圆点</h3><p><strong>偏好设置-外观-打开主题-找到在使用主题css-修改代码块样式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 代码块主题 */</span><br><span class="hljs-comment">/* 顶部 */</span><br><span class="hljs-selector-class">.md-fences</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#c5c8c6</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#21252b</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> / <span class="hljs-number">40%</span>);<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">font-family</span>: monospace, <span class="hljs-string">&#x27;PingFang SC&#x27;</span>, <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.md-fences</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span>;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">12px</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭所有typora窗口 重新打开 即可获取小圆点</p><h2 id="4、配置Pandoc"><a href="#4、配置Pandoc" class="headerlink" title="4、配置Pandoc"></a>4、配置Pandoc</h2><p><a href="https://github.com/jgm/pandoc/releases/tag/3.1.6.1">Pandoc下载地址</a></p><p>将解压安装路径配置window环境变量path</p><p>pandoc –version# 检查是否生效</p><p>重启Typora</p><h2 id="5、ubuntu情况下-picgo-存在问题"><a href="#5、ubuntu情况下-picgo-存在问题" class="headerlink" title="5、ubuntu情况下 picgo 存在问题"></a>5、ubuntu情况下 picgo 存在问题</h2><blockquote><p>手动方案</p></blockquote><p><strong>5.1 git clone 图片仓库</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:gondmhd/XXXX.git<br></code></pre></td></tr></table></figure><p><strong>5.2 typora保存图片到本地仓库路径下</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240508164956733.png?raw=true" alt="image-20240508164956733"></p><p><strong>5.3 使用typora正常编辑保存图片</strong></p><p><strong>5.4 git push 图片到仓库 复制图片链接到md文档</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240508165232708.png?raw=true" alt="image-20240508165232708"></p><p><strong>5.5 将图片路径修改</strong></p><p>修改成复制的网络地址(也可修改路径拼接后面 ?raw&#x3D;true)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">https://github.com/gondmhd/blogImage/blob/main/img/image-20240508165232708.png?raw=true<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile构建技巧</title>
    <link href="/2024/05/27/docker/Dockfile%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/05/27/docker/Dockfile%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile构建技巧"><a href="#Dockerfile构建技巧" class="headerlink" title="Dockerfile构建技巧"></a>Dockerfile构建技巧</h1><h2 id="1、不使用多阶段构建"><a href="#1、不使用多阶段构建" class="headerlink" title="1、不使用多阶段构建"></a>1、不使用多阶段构建</h2><p>我们知道在Dockerfile 中没新增一个指令都会在镜像中生产新的层，一个高校的Dockerfile应该在继续下一层之前清楚之前所有不需要的资源 </p><p>不使用多阶段构建时，<strong>我们通常会创建两个dockerfile文件，一个用于开发及编程应用，另一个用于构建精简的生成镜像，</strong>这样能比较大限度的减小镜像的大小。</p><p>我们以一个go应用来看看，首先创建一个dockerfile,构建这个镜像的主要目的就是编译我们的应用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-comment">#go编译</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build  -o myapp app.go</span><br></code></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost dockerfiles]<span class="hljs-comment"># docker build -t builder_app:v1 .</span><br>Sending build context to Docker daemon  3.072kB<br>Step 1/4 : FROM golang:1.16<br> ---&gt; 019c7b2e3cb8<br>Step 2/4 : WORKDIR /go/src<br> ---&gt; Using cache<br> ---&gt; 15362720e897<br>Step 3/4 : COPY app.go ./<br> ---&gt; Using cache<br> ---&gt; 8f14ac97a68a<br>Step 4/4 : RUN go build  -o myapp app.go<br> ---&gt; Running <span class="hljs-keyword">in</span> 4368cc4617a7<br>Removing intermediate container 4368cc4617a7<br> ---&gt; 631f67587803<br>Successfully built 631f67587803<br>Successfully tagged builder_app:v1<br></code></pre></td></tr></table></figure><p>这样在这个镜像中就包含了我们编译后的应用myapp，现在我们可以创建容器将myapp拷贝到宿主机等待后续使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker create --name builder builder_app:v1# 创建一个新的容器，但并不启动它 --name builder  builder_app:v1：这是指定要创建的容器所使用的镜像名称和标签</span><br>fafc1cf7ffa42e06d19430b807d24eafe0bf731fc45ff0ecf31ada5a6075f1d5<br><span class="hljs-comment"># docker cp builder:/go/src/myapp ./ # 从一个容器中复制文件或目录到本地主机。</span><br></code></pre></td></tr></table></figure><p>我们有了应用，下一步就是构建生产镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM scratch<br>WORKDIR /server<br>COPY myapp ./<br>CMD [<span class="hljs-string">&quot;./myapp&quot;</span>]<br></code></pre></td></tr></table></figure><p>由于此时我们不需要其他依赖环境，所以我们采用scratch这个空镜像，不仅可以减小容器尺寸，还可以提高安全性。</p><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker build  --no-cache -t server_app:v1 .   #  --no-cache 指示Docker在构建过程中不使用任何缓存。通常，Docker会缓存之前步骤的结果来加速连续构建过程，但是使用这个标志会强制Docker忽略所有缓存，从头开始构建每个层。</span><br></code></pre></td></tr></table></figure><p>我们看一次构建的两个镜像大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker images </span><br>REPOSITORY            TAG       IMAGE ID       CREATED          SIZE<br>server_app            v1        6ebc0833cad0   6 minutes ago    1.94MB<br>builder_app           v1        801f0b615004   23 minutes ago   921MB<br></code></pre></td></tr></table></figure><p><strong>显然在不使用多阶段构建时，我们也可以构建出生产镜像，但是我们需要维护两个dockerfile，需要将app遗留到本地，并且带来了更多存储空间开销。在使用多阶段构建时能比较好的解决以上问题。</strong></p><h2 id="2、使用多阶段构建"><a href="#2、使用多阶段构建" class="headerlink" title="2、使用多阶段构建"></a>2、使用多阶段构建</h2><p>在一个Dockfile 中使用多个FROM 指令，每个FROM 都可以使用不同的基镜像，并且每条指令都将开始新阶段构建。在多阶段构建中，我们可以将资源从一个阶段复制到另一个阶段，在最终镜像中只保留我们所需要的内容。</p><p>我们将上面实例的两个Dockfile合并如下为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=0 /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>构建镜像</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># docker build --no-cache  -t server_app:v2 .</span><br></code></pre></td></tr></table></figure><p><strong>查看构建好的镜像</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># docker images</span><br><span class="hljs-attribute">REPOSITORY</span>            TAG       IMAGE ID       CREATED              SIZE<br><span class="hljs-attribute">server_app</span>            v2        <span class="hljs-number">20225</span>cb1ea6b   <span class="hljs-number">12</span> seconds ago       <span class="hljs-number">1</span>.<span class="hljs-number">94</span>MB<br></code></pre></td></tr></table></figure><p>这样我们无需创建额外镜像，以更简单的方式构建出了同样微小的目标镜像。可以看到在多阶段构建dockerfile中最关键的是<code>COPY --from=0 /go/src/myapp ./</code> 通过<code>--from=0</code>指定我们资源来源，这里的0即是指第一阶段。</p><p><strong>命令构建阶段</strong></p><p>默认情况下构建阶段没有名称，我们可以通过整数0~N来引用，即第一个from从0开始。其实我们还可以在<code>FROM</code>指令中添加<code>AS &lt;NAME&gt;</code> 来命名构建阶段，接着在COPY指令中通过<code>&lt;NAME&gt;</code>引用。我们对上面dockerfile修改如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1命名为builder</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span> as builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-comment">#通过名称引用</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>只构建某个接蹲</strong></p><p>构建镜像时，不一定需要构建整个 Dockerfile，我们可以通过<code>--target</code>参数指定某个目标阶段构建，比如我们开发阶段我们只构建builder阶段进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#docker build --target builder -t builder_app:v2 .</span><br></code></pre></td></tr></table></figure><p><strong>使用外部镜像</strong></p><p>使用多阶段构建时，我们局限于从之前在 Dockerfile 中创建的阶段进行复制。还可以使用<code>COPY --from</code>指令从单独的镜像复制，如本地镜像名称、本地或 Dockerhub上可用的标签或标签 ID。Docker 客户端在必要时会拉取需要的镜像到本地。</p><p><strong>从上一阶段创建新的阶段</strong></p><p>我们可以通过FROM指令来引用上一阶段作为新阶段的开始</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1命名为builder</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span> as builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> builder as builder_ex<br><span class="hljs-keyword">ADD</span><span class="language-bash"> dest.tar ./</span><br>...<br><br></code></pre></td></tr></table></figure><p><strong>使用本地环境构建镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">#阶段1</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app.go ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build app.go -o myapp</span><br><span class="hljs-comment">#阶段2</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /server</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=0 /go/src/myapp ./</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;./myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>使用本地脚本控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 根据是否有阶段参数执行构建</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$#</span>&quot;</span> -gt 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># 如果有参数，则执行带有 --cache-from 的构建，假定参数是期望的构建阶段名（这里假设为 builder）</span><br>    docker build --cache-from=builder_app:v3 --target final -t work:dev .<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># 没有参数，执行完整的构建流程</span><br>    <span class="hljs-comment"># 先构建 builder 阶段</span><br>    docker build --target builder -t builder_app:v3 .<br>    <span class="hljs-comment"># 使用 builder 镜像作为缓存来源，构建最终镜像</span><br>    docker build --cache-from=builder_app:v3 --target final -t work:dev .<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose网络关联配置</title>
    <link href="/2024/05/27/docker/docker-compose%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/05/27/docker/docker-compose%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-compose网络配置"><a href="#docker-compose网络配置" class="headerlink" title="docker-compose网络配置"></a>docker-compose网络配置</h1><hr><blockquote><p>在工作中我们可能需要数据库和api接口分开部署的情况，如果都用docker-compose部署的话， 在有的操作系统中可能无法使用（ip+端口）连接数据库，必须使用服务名称去连接。 这时我们就需要让这两个docker-compose启动的服务共享网络，这样就可以相互调用服务了</p></blockquote><h2 id="1-使用docker-compose-yml-文件引用"><a href="#1-使用docker-compose-yml-文件引用" class="headerlink" title="1 使用docker-compose.yml 文件引用"></a>1 使用docker-compose.yml 文件引用</h2><hr><h3 id="数据库的docker-compose文件"><a href="#数据库的docker-compose文件" class="headerlink" title="数据库的docker-compose文件"></a>数据库的docker-compose文件</h3><ul><li>先启动数据库服务，最后api服务的docker-compose.yml引用数据库的网络即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-container</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_net</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">my_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure><ul><li><p>这里需要指定网络 my_net，指定后网络名称为当前文件夹加上_my_net，如果不指定会使用当前文件夹的名称加上_default</p></li><li><p>启动命令 docker-compose -p supercom up -d (加上-p指定网络名称)</p></li><li><p>查看网络 docker network ls</p></li><li><p>这里我查看的是 supercom_my_net</p><p><img src="https://raw.githubusercontent.com/gondmhd/blogImage/main/img/202310251507487.png" alt="202308241527417"></p></li></ul><h3 id="api的docker-compose文件"><a href="#api的docker-compose文件" class="headerlink" title="api的docker-compose文件"></a>api的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">api:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/superhorizon/superhorizon-backend-java</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">api</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8089:8089&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">supercom_my_net</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">super_horizon_123456</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">horizon_dev</span><br>      <span class="hljs-attr">MYSQL_NAME:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">opensearch_ip:</span> <span class="hljs-string">opensearch</span><br>      <span class="hljs-attr">opensearch_dashboard_url:</span> <span class="hljs-string">http://192.168.0.190:8889</span><br>      <span class="hljs-attr">situation_picture_url:</span> <span class="hljs-string">/situation_picture_url/</span><br>      <span class="hljs-attr">situation_ipAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.190</span><br>      <span class="hljs-attr">situation_port:</span> <span class="hljs-number">8889</span><br>      <span class="hljs-attr">keycloak-enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">keycloak-auth-server-url:</span> <span class="hljs-string">http://keycloak:8080/auth</span><br>      <span class="hljs-attr">keycloak-realm:</span> <span class="hljs-string">myrealm</span><br>      <span class="hljs-attr">JDBC_URL:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/horizon_dev?allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=UTF8&amp;zeroDateTimeBehavior=round&amp;allowMultiQueries=true</span><br><span class="hljs-string">ex</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">supercom_my_net:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 来自外部</span><br></code></pre></td></tr></table></figure><p>在使用共享网络后，我们在连接 mysql的使用就可以使用服务名称，db-mysql，可进入容器进行ping测试</p><hr><h2 id="2-提前创建docker-网络"><a href="#2-提前创建docker-网络" class="headerlink" title="2 提前创建docker 网络"></a>2 提前创建docker 网络</h2><p>我们可以使用 <strong>docker network create my_net</strong> 创建一个网络，之后每个docker-compose.yml引用即可</p><h3 id="数据库的docker-compose文件-1"><a href="#数据库的docker-compose文件-1" class="headerlink" title="数据库的docker-compose文件"></a>数据库的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-container</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test_super</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">test_super:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="api的docker-compose文件-1"><a href="#api的docker-compose文件-1" class="headerlink" title="api的docker-compose文件"></a>api的docker-compose文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">api:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/superhorizon/superhorizon-backend-java</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">api</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8089:8089&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test_super</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">super_horizon_123456</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">horizon_dev</span><br>      <span class="hljs-attr">MYSQL_NAME:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">opensearch_ip:</span> <span class="hljs-string">opensearch</span><br>      <span class="hljs-attr">opensearch_dashboard_url:</span> <span class="hljs-string">http://192.168.0.190:8889</span><br>      <span class="hljs-attr">situation_picture_url:</span> <span class="hljs-string">/situation_picture_url/</span><br>      <span class="hljs-attr">situation_ipAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.190</span><br>      <span class="hljs-attr">situation_port:</span> <span class="hljs-number">8889</span><br>      <span class="hljs-attr">keycloak-enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">keycloak-auth-server-url:</span> <span class="hljs-string">http://keycloak:8080/auth</span><br>      <span class="hljs-attr">keycloak-realm:</span> <span class="hljs-string">myrealm</span><br>      <span class="hljs-attr">JDBC_URL:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/horizon_dev?allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;useSSL=false&amp;characterEncoding=UTF8&amp;zeroDateTimeBehavior=round&amp;allowMultiQueries=true</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">test_super:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 来自外部</span><br></code></pre></td></tr></table></figure><p>进入容器测试即可</p><h2 id="3、-Docker-Compose-环境变量"><a href="#3、-Docker-Compose-环境变量" class="headerlink" title="3、 Docker Compose 环境变量"></a>3、 Docker Compose 环境变量</h2><p> Docker Compose 配置中，直接在 <code>environment</code> 下设置环境变量与使用 <code>env_file</code> 引用文件来设置环境变量，主要有以下几点区别：</p><ol><li><p><strong>声明方式</strong>:</p><ul><li><strong>环境变量块 (<code>environment</code>)</strong>: 直接在 <code>environment</code> 下列出的环境变量是以键值对的形式直接写在 <code>docker-compose.yml</code> 文件中的。这种方式适合于少量的、不敏感或者特定于服务的环境变量设置。</li></ul><p>Yaml</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>services:<br><span class="hljs-symbol">2 </span> nginx-proxy:<br><span class="hljs-symbol">3 </span>   environment:<br><span class="hljs-symbol">4 </span>     VIRTUAL_HOST: <span class="hljs-comment">&#x27;api.malcolm.local&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>环境变量文件 (<code>env_file</code>)</strong>: 使用 <code>env_file</code> 指令引用一个或多个外部文件，每个文件中包含多行 <code>KEY=VALUE</code> 格式的环境变量。这种方式适合于管理大量的环境变量，尤其是那些可能在不同环境（如开发、测试、生产）间变化的配置，或者包含敏感信息（尽管对于敏感信息最好使用 Docker 的秘密管理功能）。</li></ul></li><li><p><strong>可维护性和可扩展性</strong>:</p><ul><li><code>env_file</code> 提供了更好的可维护性和扩展性，因为环境相关的配置可以独立于服务定义存放，易于修改和版本控制。特别是当环境变量较多时，直接在 <code>docker-compose.yml</code> 中管理会变得混乱。</li></ul></li><li><p><strong>优先级</strong>:</p><ul><li>如果同一个环境变量既在 <code>env_file</code> 中定义，也在 <code>environment</code> 块中直接定义，那么直接在 <code>environment</code> 块中定义的值会覆盖 <code>env_file</code> 中的值。这是因为直接在服务定义中设置的环境变量具有更高的优先级。</li></ul></li><li><p><strong>安全性</strong>:</p><ul><li>尽管两者都可以用来设置环境变量，但使用 <code>env_file</code> 方式更适合存储敏感信息，因为它允许你将这些信息放在 <code>.env</code> 文件中，该文件通常会被加入 <code>.gitignore</code> 避免误提交到版本控制系统中。然而，最佳实践仍然是使用Docker的密钥管理系统来处理敏感信息。</li></ul></li></ol><p>综上所述，选择直接在 <code>environment</code> 块内定义还是使用 <code>env_file</code> 引入环境变量，取决于你的具体需求、环境变量的数量、安全考量以及是否需要跨服务或跨环境共享配置。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础</title>
    <link href="/2024/05/27/docker/Docker%E5%85%A5%E9%97%A8/"/>
    <url>/2024/05/27/docker/Docker%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官方文档地址：<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p><p>中文参考手册：<a href="https://docker_practice.gitee.io/zh-cn">https://docker_practice.gitee.io/zh-cn</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-什么是-docker"><a href="#1-1-什么是-docker" class="headerlink" title="1.1 什么是 docker"></a>1.1 什么是 docker</h2><p>Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，以便快速交付软件。使用 Docker 您可以使用与管理应用程序相同的方式管理您的基础设施。通过利用 Docker 用于快速交付、测试和部署代码的方法，您可以显著减少编写代码和在生产中运行代码之间的延迟。<strong>Docker 提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程</strong></p><blockquote><p>Docker 是一个容器技术</p></blockquote><h2 id="1-2-docker-起源"><a href="#1-2-docker-起源" class="headerlink" title="1.2 docker 起源"></a>1.2 docker 起源</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</strong>。</p><h2 id="1-3-为什么是-docker"><a href="#1-3-为什么是-docker" class="headerlink" title="1.3 为什么是 docker"></a>1.3 为什么是 docker</h2><blockquote><p>开发的时候，本机测试环境可以跑，生产环境跑步起来</p></blockquote><p>假如上线一个 java web 项目，这个应用程序涉及很多东西如：jdk、tomcat、redis、mysql等，当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker 则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p><p><strong>优势一：一致的运行环境，更轻松的迁移</strong></p><blockquote><p>别人程序出了问题把服务器资源吃光，导致自己的应用挂掉了</p></blockquote><p>如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker 就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p><p><strong>优势二：进程级的隔离，容器与容器之间互不影响，更高效利用资源</strong></p><blockquote><p>促销活动需要临时拓展几十台服务器</p></blockquote><p>在没有 Docker 的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用 Docker 的话，只需要将程序打包成镜像，你要多少台服务，我就启动多少容器，极大地提高了部署效率。</p><p><strong>优势三: 通过镜像复制N多个环境一致容器</strong></p><h2 id="1-4-docker-与虚拟机"><a href="#1-4-docker-与虚拟机" class="headerlink" title="1.4 docker 与虚拟机"></a>1.4 docker 与虚拟机</h2><ol><li>虚拟机是携带操作系统的，docker 不携带操作系统</li><li>虚拟机调度资源步骤为：利用 Hypervisor 虚拟化内存，虚拟内存 -&gt; 虚拟物理内存 -&gt; 物理内存</li><li>docker 调度资源步骤为：利用 Docker Engine 调用宿主机资源，虚拟内存 -&gt; 物理内存</li></ol><table><thead><tr><th></th><th>传统虚拟机</th><th>Docker容器</th></tr></thead><tbody><tr><td>磁盘占用</td><td>几个GB到几十个GB左右</td><td>几十MB到几百MB左右</td></tr><tr><td>CPU内存占用</td><td>虚拟操作系统非常占用CPU和内存</td><td>Docker引擎占用极低</td></tr><tr><td>启动速度</td><td>（从开机到运行项目）几分钟</td><td>（从开启容器到运行项目）几秒</td></tr><tr><td>安装管理</td><td>需要专门的运维技术</td><td>安装、管理方便</td></tr><tr><td>应用部署</td><td>每次部署都费时费力</td><td>从第二次部署开始轻松简捷</td></tr><tr><td>耦合性</td><td>多个应用服务安装到一起，容易互相影响</td><td>每个应用服务一个容器，达成隔离</td></tr><tr><td>系统依赖</td><td>无</td><td>需求相同或相似的内核，目前推荐是Linux</td></tr></tbody></table><h2 id="1-5-docker-安装"><a href="#1-5-docker-安装" class="headerlink" title="1.5 docker 安装"></a>1.5 docker 安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 –mirror 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh --mirror Aliyun</span><br></code></pre></td></tr></table></figure><p>启动 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br></code></pre></td></tr></table></figure><p>个人使用的是 docker for mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install -cask docker</span><br></code></pre></td></tr></table></figure><p>或者直接去官网下载 docker for desktop</p><h2 id="1-6-docker-架构"><a href="#1-6-docker-架构" class="headerlink" title="1.6 docker 架构"></a>1.6 docker 架构</h2><ul><li>镜像：镜像代表一个应用环境，它是一个只读文件，如：mysql镜像、tomcat镜像等</li><li>容器：镜像每次运行之后会产生一个容器，即正在运行的镜像，可读可写</li><li>仓库：存档镜像的位置，用于镜像的上传和下载</li><li>Dockerfile：docker生成镜像的配置文件，用于自定义镜像的一些配置</li><li>tar：对镜像的打包文件，可以基于这个文件还原成镜像</li></ul><h2 id="1-7-docker-运行流程"><a href="#1-7-docker-运行流程" class="headerlink" title="1.7 docker 运行流程"></a>1.7 docker 运行流程</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240517140420277.png?raw=true" alt="image-20240517140420277"></p><h2 id="1-8-配置镜像加速"><a href="#1-8-配置镜像加速" class="headerlink" title="1.8 配置镜像加速"></a>1.8 配置镜像加速</h2><p>Linux 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;&#123;<br>    &quot;registry-mirrors&quot;:[<br>        &quot;https://docker.m.daocloud.io/&quot;,<br>        &quot;https://dockerproxy.com/&quot;,<br>        &quot;https://docker.mirrors.ustc.edu.cn/&quot;,<br>        &quot;https://docker.nju.edu.cn/&quot;<br>    ],<br>    &quot;data-root&quot;:&quot;/home/dockerdate&quot;,<br>    &quot;log-driver&quot;:&quot;json-file&quot;,<br>    &quot;log-opts&quot;:&#123;<br>        &quot;max-size&quot;:&quot;512m&quot;,&quot;max-file&quot;:&quot;3&quot;<br>    &#125;<br>&#125;&#x27; | sudo tee /etc/docker/daemon.json<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>验证镜像加速是否生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker info<br>..........<br>    127.0.0.0/8<br> Registry Mirrors:<br>  https://docker.m.daocloud.io/<br> https://dockerproxy.com/<br> https://docker.mirrors.ustc.edu.cn/<br> https://docker.nju.edu.cn/<br><br>   Live Restore Enabled: false<br>   Product License: Community Engine<br></code></pre></td></tr></table></figure><h1 id="二、Docker-入门"><a href="#二、Docker-入门" class="headerlink" title="二、Docker 入门"></a>二、Docker 入门</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run hello-world                                       <br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>93288797bd35: Pull complete <br>Digest: sha256:393b81f0ea5a98a7335d7ad44be96fe76ca8eb2eaa76950eb8c989ebf2b78ec0<br>Status: Downloaded newer image for hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.<br>    (arm64v8)<br> 3. The Docker daemon created a new container from that image which runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, which sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br><span class="hljs-meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span><br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></td></tr></table></figure><h2 id="2-1-辅助命令"><a href="#2-1-辅助命令" class="headerlink" title="2.1 辅助命令"></a>2.1 辅助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看docker信息</span><br>docker version<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看消息信息</span><br>docker info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">帮助命令</span><br>docker --help<br></code></pre></td></tr></table></figure><h2 id="2-2-镜像命令"><a href="#2-2-镜像命令" class="headerlink" title="2.2 镜像命令"></a>2.2 镜像命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机所有镜像</span><br>docker images<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有镜像(包含中间镜像层)</span><br>  docker images -a<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">只显示镜像<span class="hljs-built_in">id</span>(用于批量删除)</span><br>  docker -q<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索镜像</span><br>docker search [options] 镜像名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示完整信息</span><br>docker search --no-trunc tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从仓库下载镜像</span><br>docker pull 镜像名[:TAG|@DIGEST]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅镜像名默认下载 latest</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除镜像</span><br>docker image rm 镜像名|镜像ID<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">简写</span><br>  docker rmi 镜像名|镜像ID<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">强制删除</span><br>  docker rmi -f 镜像名|镜像ID<br></code></pre></td></tr></table></figure><p>补充：</p><p>docker images 展示的镜像信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">REPOSITORY       TAG       IMAGE ID       CREATED       SIZE<br></code></pre></td></tr></table></figure><ul><li>REPOSITORY：仓库，即镜像名称</li><li>TAG：分支，可以理解为版本号</li><li>IMAGE ID：镜像ID，全网唯一</li><li>CREATED：镜像构建时间</li><li>SIZE：镜像大小</li></ul><p>docker 命令提供类似 Linux 的管道功能，如删除所有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker rmi -f $(docker images -q)<br></code></pre></td></tr></table></figure><h2 id="2-3-容器命令"><a href="#2-3-容器命令" class="headerlink" title="2.3 容器命令"></a>2.3 容器命令</h2><p>通常我们准备下载一个镜像不会通过 docker search，因为展示出来的信息不包含分支信息，即版本号，一般会在<a href="https://hub.docker.com/">dockerhub</a>网站搜索我们需要的镜像的具体分支，比如：下载tomcat</p><p>选择适合的版本复制命令下载镜像 <code>docker pull tomcat:latest</code></p><p><strong>运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>后台运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d tomcat:latest <br></code></pre></td></tr></table></figure><p>此时容器已经启动，尝试访问本机 8080 端口，发现拒绝连接，这是因为 docker 的特点：线程级隔离，相当于此时 tomcat 独自运行在本机的一个虚拟机中，若要实现容器和宿主机的通信，需要映射容器端口。</p><p><strong>映射容器端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8080:8080 tomcat:latest<br></code></pre></td></tr></table></figure><p>格式：-p 宿主机端口:容器端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker ps                <br>CONTAINER IDIMAGECOMMANDCREATEDSTATUSPORTSNAMES<br></code></pre></td></tr></table></figure><ul><li>CONTAINER ID：容器ID，唯一</li><li>IMAGE：容器基于的镜像</li><li>COMMAND：容器启动执行的命令</li><li>CREATED：容器创建的时间</li><li>STATUS：容器此时的状态</li><li>PORTS：容器端口信息</li><li>NAMES：容器名称，唯一</li></ul><p>基于容器的操作不仅可以使用 CONTAINER ID 也可以使用 NAMES</p><p>拓展参数：</p><ul><li>-a:查看所有容器(正在运行和历史运行过的容器)</li><li>-q:静默模式，只显示容器ID</li></ul><p><strong>运行容器指定名称</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8081:8080 --name tomcat01 tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>停止|关闭|重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br>docker start 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭容器</span><br>docker stop 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">立刻停止容器</span><br>docker kill 容器名字或者容器ID<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>上述这些命令搭配 <code>docker ps -q</code> 可实现批量操作</p><blockquote><p>docker run 和 docker start 区别：run 运行镜像，创建一个新的容器；start 仅启动一个历史容器</p></blockquote><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>正在运行的容器不可以被删除，使用 -f 可以强制删除，额外：<code>docker rm -f $(docker ps -aq)</code> 删除所有容器！！！</p><p><strong>查看容器内的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>和 top 命令效果一样</p><p><strong>查看容器的运行日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs [options] 容器名字或者容器ID<br></code></pre></td></tr></table></figure><p>options:</p><ul><li>-t:加入时间戳</li><li>-f:阻塞实时打印日志</li><li>–tail int:打印日志最后n条</li></ul><p><strong>进入容器内部</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [options] 容器名字或者容器ID 容器内命令<br></code></pre></td></tr></table></figure><p>options:</p><ul><li>-i:以交互式运行容器</li><li>-t:分配一个 tty</li></ul><p>通常这个命令是固定写法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it tomcat01 bash<br></code></pre></td></tr></table></figure><p>这个镜像搭载着一个轻量级的 linux 系统，支持一些常用的命令(exit退出)</p><p><strong>容器与宿主机传输文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">宿主机文件(夹) -&gt; 容器</span><br>docker cp 宿主机文件(夹) 容器id|名称:容器路径<br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器 -&gt; 宿主机文件(夹)</span><br>docker cp 容器id|名称:容器路径 宿主机文件(夹)<br></code></pre></td></tr></table></figure><p>注：宿主机文件(夹)一定要是绝对路径</p><p>回到上面访问宿主机 8080 端口 404 问题，这是因为容器中 tomcat&#x2F;webapps 下没有文件。我们可以借助这个命令将本机的一些 war 包，或者官网 tomcat 目录下的东西放进去即可</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">➜  ~ docker cp ~/<span class="hljs-keyword">env</span>/tomcat/webapps tomcat01:/usr/local/tomcat<br></code></pre></td></tr></table></figure><p>再次访问即可出现经典的劈叉猫</p><p><strong>容器与宿主机共享目录</strong></p><p>尝试删除运行的tomcat容器，以相同的方式再次运行一个容器，发现 webapps 下依然是空的，这说明容器被删除后容器内所有文件都会被删除，当一些重要的数据我们就不能放在容器里面，因此 docker 提供<strong>数据卷</strong>的功能将容器的目录挂载到宿主机的目录，实现数据的持久化(更多数据卷的内容见后面的高级部分)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v 宿主机的绝对路径|任意别名:/容器内的路径 镜像名<br></code></pre></td></tr></table></figure><ol><li>如果是宿主机路径：必须是绝对路径，宿主机目录会覆盖容器内目录内容</li><li>如果是别名：运行容器时自动在宿主机中创建一个目录，并将容器目录文件复制到宿主机中；若别名存在宿主机目录会覆盖容器内目录内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载宿主机目录</span><br>➜  ~ docker run -d -p 8081:8080 --name tomcat04 -v ~/env/tomcat/webapps:/usr/local/tomcat/webapps tomcat:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动创建数据卷(如果不存在的话)</span><br>➜  ~ docker run -d -p 8083:8080 --name tomcat07 -v v_t:/usr/local/tomcat/webapps tomcat:latest<br></code></pre></td></tr></table></figure><p><strong>打包镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save 镜像名 -o 路径/名称.tar<br></code></pre></td></tr></table></figure><p><strong>载入镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i 名称.tar<br></code></pre></td></tr></table></figure><p><strong>将容器打包成镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交dockerhub(一般不提交，需要登录dockerhub)</span><br>docker push 镜像名称:标签<br></code></pre></td></tr></table></figure><h1 id="三、docker-高级"><a href="#三、docker-高级" class="headerlink" title="三、docker 高级"></a>三、docker 高级</h1><h2 id="3-1-镜像原理"><a href="#3-1-镜像原理" class="headerlink" title="3.1 镜像原理"></a>3.1 镜像原理</h2><h3 id="3-1-1-什么是镜像"><a href="#3-1-1-什么是镜像" class="headerlink" title="3.1.1 什么是镜像"></a>3.1.1 什么是镜像</h3><p>Docker 镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p><h3 id="3-1-2-为什么镜像这么大"><a href="#3-1-2-为什么镜像这么大" class="headerlink" title="3.1.2 为什么镜像这么大"></a>3.1.2 为什么镜像这么大</h3><p>可以看到 docker 中一个 tomcat 镜像居然高达 670M，这是为什么？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker images                             <br>REPOSITORY       TAG       IMAGE ID       CREATED        SIZE<br>tomcat           latest    eadaf4390f32   29 hours ago   670MB<br>kpretty/tomcat   v1.0      3c447801519f   2 days ago     674MB<br>debian           latest    a331823f8665   2 days ago     118MB<br>hello-world      latest    18e5af790473   6 days ago     9.14kB<br>centos           centos7   dfc30428e163   2 weeks ago    301MB<br></code></pre></td></tr></table></figure><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像，就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。因此对于 tomcat 镜像来说，不仅包含 tomcat 程序包，还包含 tomcat 运行所依赖的所有环境。</p><h3 id="3-1-3-镜像原理"><a href="#3-1-3-镜像原理" class="headerlink" title="3.1.3 镜像原理"></a>3.1.3 镜像原理</h3><p><strong>UnionFs(联合文件系统)</strong></p><p>UnionFs 是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFs 是Docker 镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p><blockquote><p>Docker 的镜像实际是由一层一层的文件系统组成</p></blockquote><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p><p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</p><p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p><img src="https://s3.jpg.cm/2021/09/30/ImfzH5.png?raw=true" style="zoom:100%;" /><p>但docker的镜像不包含操作系统，因为docker与宿主机共享内核。</p><h3 id="3-1-4-分层结构"><a href="#3-1-4-分层结构" class="headerlink" title="3.1.4 分层结构"></a>3.1.4 分层结构</h3><p>这种分层结构在 pull 镜像是会体现出来，一份镜像会分好几几个分支下载，同时有的分支还提示已存在。</p><p>这种分层结构最大的好处就是资源共享，多个镜像都是从相同的 base 镜像构建而来，那么宿主机只需要保存一份 base 镜像；同时内存也只需要加载一份 base 镜像即可。</p><h2 id="3-2-网络原理"><a href="#3-2-网络原理" class="headerlink" title="3.2 网络原理"></a>3.2 网络原理</h2><p>当 docker 启动时，会自动在主机上创建一个 bridge 的虚拟网桥，可以理解为一个软件交换机，它会在挂载到它的网口之间进行转发。同时，docker 随机分配一个本地未占用的私有网段中的一个地址给 bridge 接口，此后启动的容器内的网口也会自动分配一个同网段的地址。</p><p>当创建一个 docker 容器的时候，同时会创建一对 veth pair 接口，这一对接口一段在容器内为 eth0；另一端在本地被挂载到 bridge 网桥以 veth 开头，通过这种方式，主机可以跟容器通信，挂载在同一网桥的容器也可以互相通信，docker就创建了在主机和所有容器之间的一个虚拟网络共享，这种方式为<strong>桥接模式</strong>，是docker默认的网络模式也是推荐的网络模式。</p><h3 id="3-2-1-查看网络信息"><a href="#3-2-1-查看网络信息" class="headerlink" title="3.2.1 查看网络信息"></a>3.2.1 查看网络信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network ls            <br>NETWORK ID     NAME      DRIVER    SCOPE<br>63893e5e4e77   bridge    bridge    local<br>2c90c0c62179   host      host      local<br>8347580e4ecb   none      null      local<br></code></pre></td></tr></table></figure><p>这里的 bridge 就是上面所说的默认网桥，运行容器默认挂载在这个网桥上</p><h3 id="3-2-2-创建一个网桥"><a href="#3-2-2-创建一个网桥" class="headerlink" title="3.2.2 创建一个网桥"></a>3.2.2 创建一个网桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network create 网桥名称<br></code></pre></td></tr></table></figure><h3 id="3-2-3-删除一个网桥"><a href="#3-2-3-删除一个网桥" class="headerlink" title="3.2.3 删除一个网桥"></a>3.2.3 删除一个网桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network rm 网桥名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-2-4-查看网桥细节"><a href="#3-2-4-查看网桥细节" class="headerlink" title="3.2.4 查看网桥细节"></a>3.2.4 查看网桥细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect 网桥名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-2-5-容器之间通信"><a href="#3-2-5-容器之间通信" class="headerlink" title="3.2.5 容器之间通信"></a>3.2.5 容器之间通信</h3><p>根据 docker 的网络原因，实现容器间的通信，只需要保证容器挂载在相同网桥上即可，其实默认直接启动容器之间就可以直接通信，但通常我们会一个业务创建一个网桥，将相同业务的容器挂载到一个网桥，业务与业务之间网络是隔离的防止干扰</p><p>创建一个网桥 docker0 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network create docker0<br></code></pre></td></tr></table></figure><p>查看网桥信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect docker0<br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;docker0&quot;,<br>        &quot;Id&quot;: &quot;e283a82de3852629506a0b1e2957560109ca22d49b1c1708d90af17385da7839&quot;,<br>        &quot;Created&quot;: &quot;2021-10-01T09:37:57.434314302Z&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: &#123;&#125;,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;172.22.0.0/16&quot;,<br>                    &quot;Gateway&quot;: &quot;172.22.0.1&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: false,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        &quot;Containers&quot;: &#123;&#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;&#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>发现这个网桥分配了一个 172.22 的子网端，之后挂载在这个网桥上的容器都会是这个网段内</p><p>运行容器指定挂载的网桥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker run -d -p 8080:8080 --name tomcat01 --network docker0 tomcat:latest<br>c17deed4f99312568f8189217b78254f58f27fc992e019bce90f2e908d4a3f07<br>➜  ~ docker run -d -p 8081:8080 --name tomcat02 --network docker0 tomcat:latest<br>ab4b13fd2b78f7610a1d71d3b1ea4a26bac82fde15fbd025bdcd07e69c6bc5c2<br></code></pre></td></tr></table></figure><p>再次查看网桥信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ docker network inspect docker0                                            <br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;docker0&quot;,<br>        &quot;Id&quot;: &quot;e283a82de3852629506a0b1e2957560109ca22d49b1c1708d90af17385da7839&quot;,<br>        &quot;Created&quot;: &quot;2021-10-01T09:37:57.434314302Z&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: &#123;&#125;,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;172.22.0.0/16&quot;,<br>                    &quot;Gateway&quot;: &quot;172.22.0.1&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: false,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        &quot;Containers&quot;: &#123;<br>            &quot;ab4b13fd2b78f7610a1d71d3b1ea4a26bac82fde15fbd025bdcd07e69c6bc5c2&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat02&quot;,<br>                &quot;EndpointID&quot;: &quot;61e0436bc9b437eb65989b2a1de22d44cae6dcea8cff862b97308167d9f7988a&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:16:00:03&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.22.0.3/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;,<br>            &quot;c17deed4f99312568f8189217b78254f58f27fc992e019bce90f2e908d4a3f07&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat01&quot;,<br>                &quot;EndpointID&quot;: &quot;beb19cd9621e9cd98a8654555a59b8753b3d014c788f229d76f320569dab264d&quot;,<br>                &quot;MacAddress&quot;: &quot;02:42:ac:16:00:02&quot;,<br>                &quot;IPv4Address&quot;: &quot;172.22.0.2/16&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;<br>        &#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;&#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>两个容器分别被分配了 172.22.0.3、172.22.0.2，下面进入其中一个容器 curl 另一个容器的8080端口(因为tomcat构建的容器只支持基本的一些命令，没有ping)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@c17deed4f993:/usr/local/tomcat# curl http://172.22.0.3:8080<br></code></pre></td></tr></table></figure><p>同时 docker 会自动的对容器的名称和ip做映射，即：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@c17deed4f993:/usr/local/tomcat# curl http://tomcat02:8080<br></code></pre></td></tr></table></figure><h2 id="3-3-数据卷"><a href="#3-3-数据卷" class="headerlink" title="3.3 数据卷"></a>3.3 数据卷</h2><p>数据卷是一个可供一个或者多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认还一直存在，集市容器被删除</li></ol><blockquote><p>数据卷的使用，类似 Liunx 下对目录或者文件进行 mount，镜像中的被指定为挂载点的目录中的文件恢复至到数据卷中(仅数据卷为空)</p></blockquote><h3 id="3-3-1-创建数据卷"><a href="#3-3-1-创建数据卷" class="headerlink" title="3.3.1 创建数据卷"></a>3.3.1 创建数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume create 数据卷名称<br></code></pre></td></tr></table></figure><h3 id="3-3-2-查看数据卷"><a href="#3-3-2-查看数据卷" class="headerlink" title="3.3.2 查看数据卷"></a>3.3.2 查看数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume inspect 数据卷名称|ID<br>如：<br>➜  ~ docker volume inspect volume1 <br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2021-10-01T11:43:33Z&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: &#123;&#125;,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/volume1/_data&quot;,<br>        &quot;Name&quot;: &quot;volume1&quot;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>其中，Mountpoint 为挂载在宿主机的目录</p><h3 id="3-3-3-挂载数据卷"><a href="#3-3-3-挂载数据卷" class="headerlink" title="3.3.3 挂载数据卷"></a>3.3.3 挂载数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~ docker run -d -p 8081:8080 --name tomcat03 -v volume01:/usr/local/tomcat/webapps/ tomcat:latest<br></code></pre></td></tr></table></figure><h3 id="3-3-4-删除数据卷"><a href="#3-3-4-删除数据卷" class="headerlink" title="3.3.4 删除数据卷"></a>3.3.4 删除数据卷</h3><p>正在被使用的数据卷无法被删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume rm 数据卷名称|ID<br></code></pre></td></tr></table></figure><h3 id="3-3-5-Mac下的数据卷"><a href="#3-3-5-Mac下的数据卷" class="headerlink" title="3.3.5 Mac下的数据卷"></a>3.3.5 Mac下的数据卷</h3><p>Linux下数据卷的Mountpoint路径真实存在，直接 cd 即可看到容器内的文件，但对于 mac 来说</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cd /var/lib/docker/volumes/volume1/_data  <br>cd: no such file or directory: /var/lib/docker/volumes/volume1/_data<br></code></pre></td></tr></table></figure><p>网上很多人给的方法是通过 screen，如数据卷会被放在下面的 tty 中，但实际是没有的，很多人也反馈没有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cd Library/Containers/com.docker.docker/Data/vms/0/<br>➜  0 pwd                  <br>/Users/wjun/Library/Containers/com.docker.docker/Data/vms/0<br>➜  0 ll<br>total 0<br>srwxr-xr-x  1 wjun  staff   0  9 28 14:45 00000002.00001003<br>srwxr-xr-x  1 wjun  staff   0  9 28 14:45 console.sock<br>drwxr-xr-x@ 3 wjun  staff  96  9 30 11:12 data<br>drwxr-xr-x  2 wjun  staff  64  9 27 18:30 log<br></code></pre></td></tr></table></figure><p>经过不懈努力终于在墙外找到了解决方案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh<br></code></pre></td></tr></table></figure><p>运行这个镜像，进入容器中 cd 到指定路径就能看到 mac 的挂载点，原理未知，知道原理的可以私信我，感谢！！！</p><h1 id="四、Dockerfile"><a href="#四、Dockerfile" class="headerlink" title="四、Dockerfile"></a>四、Dockerfile</h1><p>Dockerfile 是 Docker 镜像的描述文件，是由一系列命令和参数构成的脚本，主要作用是用来构建 docker 镜像的构建文件。</p><h2 id="4-1-Dockerfile解析过程"><a href="#4-1-Dockerfile解析过程" class="headerlink" title="4.1 Dockerfile解析过程"></a>4.1 Dockerfile解析过程</h2><p>通常这个描述文件就叫 Dockerfile，该文件所在的目录称之为 docker 的上下文目录，当基于 Dockerfile 开始构建镜像时，首先将上下文目录里的所有文件发送给 docker server，在服务端完成构建；在构建镜像过程中，Dockerfile 中每一个命令都会生成一个镜像层，下一个的命令基于上一个命令生成的镜像继续构建，形成一个个的镜像层，同时每个镜像层都会被缓存，当遇到相同的命令会直接使用，最终构建完成后体现给用户的只有最终的镜像。</p><p>根据上面的解释，一般在构建镜像时会新建一个空白目录，该目录仅放置 Dockerfile 和与构建镜像所必须的文件；无关紧要的文件会影响构建速度，但 docker 也提供类似 gitignore 的作用，在上下文目录中新建 .dockerignore 文件，docker 会忽略该文件里面指定的内容。</p><img src="https://s3.jpg.cm/2021/10/01/ImyooX.png?raw=true" style="zoom:100%;" /><h2 id="4-2-Dockerfile保留命令"><a href="#4-2-Dockerfile保留命令" class="headerlink" title="4.2 Dockerfile保留命令"></a>4.2 Dockerfile保留命令</h2><p>常用命令如下(官方说明：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>)</p><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td><strong>RUN</strong></td><td><strong>构建镜像时需要运行的指令</strong></td></tr><tr><td><strong>EXPOSE</strong></td><td><strong>当前容器对外暴露出的端口号</strong></td></tr><tr><td><strong>WORKDIR</strong></td><td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td></tr><tr><td><strong>ENV</strong></td><td><strong>用来在构建镜像过程中设置环境变量</strong></td></tr><tr><td><strong>ADD</strong></td><td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td></tr><tr><td><strong>COPY</strong></td><td><strong>类似于ADD，拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td></tr><tr><td><strong>VOLUME</strong></td><td><strong>容器数据卷，用于数据保存和持久化工作</strong></td></tr><tr><td><strong>CMD</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td></tr><tr><td><strong>ENTRYPOINT</strong></td><td><strong>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td></tr></tbody></table><blockquote><p>上述命令必须大写</p></blockquote><h3 id="4-2-1-FROM"><a href="#4-2-1-FROM" class="headerlink" title="4.2.1 FROM"></a>4.2.1 FROM</h3><p>基于哪个镜像进行构建新的镜像，在构建中基于的镜像会自动从dockerhub进行拉取，且必须保证该命令作为 Dockerfile 第一个指令出现</p><p>语法如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]<br></code></pre></td></tr></table></figure><p>TAG 不写默认 latest</p><h3 id="4-2-2-MAINTAINER"><a href="#4-2-2-MAINTAINER" class="headerlink" title="4.2.2 MAINTAINER"></a>4.2.2 MAINTAINER</h3><p>镜像维护者的姓名和邮箱地址[废弃]</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-RUN"><a href="#4-2-3-RUN" class="headerlink" title="4.2.3 RUN"></a>4.2.3 RUN</h3><p>RUN 指定将在当前镜像层中执行指定的命令并提交结果，其格式有两种 shell 和 exec</p><p>shell：RUN &lt;命令&gt;如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello docker&quot;</span> &gt;&gt; /README</span><br></code></pre></td></tr></table></figure><p>exec: RUN [“可执行文件”,”参数1”,”参数2”,…]如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;&#x27;hello docker&#x27;&quot;</span>,<span class="hljs-string">&quot;&gt;&gt;&quot;</span>,<span class="hljs-string">&quot;/README&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注：上面说过每一个指令都会构建一层因此不建议写多个 RUN，多个 RUN 的结果会显得臃肿、形成非常多的镜像层，不仅增加了镜像构建的时间，也容易出错，同时 UnionFs 有最大层的显示，现版本是 127 层；要时刻提醒自己 Dockerfile 不是在写 shell 脚本，而是定义每一层的构建规则；对于多条 shell 参考写法如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -x; buildDeps=<span class="hljs-string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="language-bash">    &amp;&amp; apt-get update \</span><br><span class="language-bash">    &amp;&amp; apt-get install -y <span class="hljs-variable">$buildDeps</span> \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> redis.tar.gz \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -r /usr/src/redis \</span><br><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="hljs-variable">$buildDeps</span></span><br></code></pre></td></tr></table></figure><blockquote><p>stretch 是一个空白镜像，基于此镜像构建意味着你不以任何镜像为基础，意味着你的镜像并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧</p></blockquote><h3 id="4-2-4-EXPOSE"><a href="#4-2-4-EXPOSE" class="headerlink" title="4.2.4 EXPOSE"></a>4.2.4 EXPOSE</h3><p>用于声明构建的镜像在运行为容器时对外暴露的端口，这只是一个声明，在容器运行时不会因为这而产生任何影响，该命令的好处是：帮助镜像使用者理解这个镜像服务守护端口，一方面配置映射，同时在运行是随机端口映射(-P)，会自动随机映射 EXPOSE 的端口</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 默认 TCP</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/tcp<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>/udp<br></code></pre></td></tr></table></figure><h3 id="4-2-5-ENV"><a href="#4-2-5-ENV" class="headerlink" title="4.2.5 ENV"></a>4.2.5 ENV</h3><p>用来为构建镜像设置环境变量，该值可以在出现在后续指令环境中。</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> key value<br><span class="hljs-keyword">ENV</span> key=value<br><span class="hljs-keyword">ENV</span> k1=· k2=v2 k3=v3<br></code></pre></td></tr></table></figure><p>如官方 node 镜像就出现类似代码</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span><br><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="language-bash">  &amp;&amp; grep <span class="hljs-string">&quot; node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="hljs-built_in">sha256sum</span> -c - \</span><br><span class="language-bash">  &amp;&amp; tar -xJf <span class="hljs-string">&quot;node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span><br><span class="language-bash">  &amp;&amp; <span class="hljs-built_in">rm</span> <span class="hljs-string">&quot;node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="language-bash">  &amp;&amp; <span class="hljs-built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></code></pre></td></tr></table></figure><h3 id="4-2-6-WORKDIR"><a href="#4-2-6-WORKDIR" class="headerlink" title="4.2.6 WORKDIR"></a>4.2.6 WORKDIR</h3><p>用于为 Dockerfile 中后续指令设置工作目录，如果 WORKDIR 指定的目录不存在会被自动创建</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> PATH</span><br></code></pre></td></tr></table></figure><p>该命令的好处如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>基于上述构建完的镜像发现并没有 &#x2F;app&#x2F;world.txt 文件，因为每个命令都会产生一个镜像层，第一个 RUN 仅仅是一个内存上的变化，不会对文件产生任何影响，到第二层又是一个新的镜像层自然不会继承上一层的内存变化，而 WORKDIR 会改变以后各层的工作目录位置，多个 WORKDIR 使用相对路径，则该路径与之前 WORKDIR 的路径相对即：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><p>RUN pwd 的工作路径是 &#x2F;a&#x2F;b&#x2F;c</p><h3 id="4-2-7-COPY"><a href="#4-2-7-COPY" class="headerlink" title="4.2.7 COPY"></a>4.2.7 COPY</h3><p>用于将上下文指定的文件(夹)复制到镜像的指定目录中</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> src dest</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [<span class="hljs-string">&quot;src&quot;</span>,...,<span class="hljs-string">&quot;dest&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>其 src 支持统配符，其通配规则满足 Go 的 filepath.Math，此外 COPY 会保留源文件的各种元数据信息如：读写权限，用户用户组，修改时间等；若要修改该添加 –chown 如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=bin files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=1 files* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=10:11 files* /mydir/</span><br></code></pre></td></tr></table></figure><blockquote><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p></blockquote><h3 id="4-2-8-ADD"><a href="#4-2-8-ADD" class="headerlink" title="4.2.8 ADD"></a>4.2.8 ADD</h3><p>更高级的 COPY，用于从上下文中复制文件，支持链接下载，自动解压压缩包</p><p>语法：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> url </span><br></code></pre></td></tr></table></figure><p>但是该语法语义不明，不建议使用；该语法仅限需要自动解压的场合使用，该语法可以被 COPY 配合 RUN 替代</p><h3 id="4-2-9-VOLUME"><a href="#4-2-9-VOLUME" class="headerlink" title="4.2.9 VOLUME"></a>4.2.9 VOLUME</h3><p>在数据卷章节说过，容器中重要的数据需要挂载到宿主机实现持久化，该命令可以在运行容器且没有指定数据卷时自动将 VOLUME 指定的文件目录挂载到一个自动创建的匿名数据卷中，当然在运行时指定 -v 会覆盖这个命令</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> path</span><br></code></pre></td></tr></table></figure><h3 id="4-2-10-CMD"><a href="#4-2-10-CMD" class="headerlink" title="4.2.10 CMD"></a>4.2.10 CMD</h3><p>用于启动容器指定执行的命令，在 Dockerfile 中只能有一条 CMD，多条命令只有最后一条生效</p><p>语法格式与 RUN 一致，在指令格式上推荐使用 exec 格式，如果使用 shell 格式实际命令会被包装成 sh -c 的参数进行执行如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-comment"># 实际上</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo <span class="hljs-variable">$PATH</span>&quot;</span> ]</span><br></code></pre></td></tr></table></figure><p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 CMD 写为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> service nginx start</span><br></code></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 service nginx start 命令，则是希望以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”] ，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="4-2-11-ENTRYPOINT"><a href="#4-2-11-ENTRYPOINT" class="headerlink" title="4.2.11 ENTRYPOINT"></a>4.2.11 ENTRYPOINT</h3><p>用来指定容器启动时执行命令和CMD类似</p><p>格式与 CMD 一致，ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p><p>如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;ls&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这种情况最终的执行效果是 ENTRYPOINT “$CMD”，但 CMD 在启动容器时会被覆盖，假如构建的镜像名为 itest</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run itest<br></code></pre></td></tr></table></figure><p>运行结果其实是 ls &#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run itest /bin<br></code></pre></td></tr></table></figure><p>此时 CMD 命令被覆盖最终运行 ls &#x2F;bin</p><h1 id="五、Docker-Compose"><a href="#五、Docker-Compose" class="headerlink" title="五、Docker Compose"></a>五、Docker Compose</h1><p>Compose 项目是 Docker 官方的开源项目，实现对 Docker 容器集群的快速编排，其定位是：定义和运行多个 Docker 容器应用。</p><p>上一节，Dockerfile 末班文件，可以让用户很方便的定义一个单独的应用容器，然后在日常工作中经常需要多个容器相互配合。例如实现一个 web 项目，除了 web 服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p>Compose 恰好满足这样的需求，它允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个<strong>项目</strong>。</p><p>Compose 中两个重要的概念：</p><ul><li>服务：一个应用容器就是一个服务</li><li>项目：由一组关联的应用容器组合的完整业务单元，在 docker-compose.yml 中定义</li></ul><h2 id="5-1-安装与卸载"><a href="#5-1-安装与卸载" class="headerlink" title="5.1 安装与卸载"></a>5.1 安装与卸载</h2><h6 id="1-linux"><a href="#1-linux" class="headerlink" title="1.linux"></a>1.linux</h6><ul><li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose<br>$ sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h6 id="2-macos、window"><a href="#2-macos、window" class="headerlink" title="2.macos、window"></a>2.macos、window</h6><ul><li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li></ul><h6 id="3-bash命令补全"><a href="#3-bash命令补全" class="headerlink" title="3.bash命令补全"></a>3.bash命令补全</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></code></pre></td></tr></table></figure><h6 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4.卸载"></a>4.卸载</h6><ul><li>如果是二进制包方式安装的，删除二进制文件即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> /usr/local/bin/docker-compose</span><br></code></pre></td></tr></table></figure><h6 id="5-测试安装成功"><a href="#5-测试安装成功" class="headerlink" title="5.测试安装成功"></a>5.测试安装成功</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose --version</span><br> docker-compose version 1.25.5, build 4667896b<br></code></pre></td></tr></table></figure><h2 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h2><p>docker-compose 模板：<a href="https://docker_practice.gitee.io/zh-cn/compose/compose_file.html">https://docker_practice.gitee.io/zh-cn/compose/compose_file.html</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysqldb:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.19</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/conf:/etc/mysql/conf.d</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/logs:/logs</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/mysql/data:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:4.0.14</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/root/redis/data:/data</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span><br>    <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">ems:</span><br></code></pre></td></tr></table></figure><p>通过 docker-compose.yml 运行一组容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos ~]# docker-compose up    //前台启动一组服务<br>[root@centos ~]# docker-compose up -d //后台启动一组服务<br></code></pre></td></tr></table></figure><h2 id="5-3-模板文件"><a href="#5-3-模板文件" class="headerlink" title="5.3 模板文件"></a>5.3 模板文件</h2><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">examples/web</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/data&quot;</span><br></code></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p><p>下面分别介绍各个指令的用法。</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./dir</span><br></code></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./dir</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile-alternate</span><br>      <span class="hljs-attr">args:</span><br>        <span class="hljs-attr">buildno:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">command:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">container_name:</span> <span class="hljs-string">docker-web-container</span><br></code></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">env_file: .<span class="hljs-built_in">env</span><br><br>env_file:<br>  - ./common.env<br>  - ./apps/web.env<br>  - /opt/secrets.env<br></code></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># common.env: Set development environment</span><br>PROG_ENV=development<br></code></pre></td></tr></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">RACK_ENV:</span> <span class="hljs-string">development</span><br>  <span class="hljs-attr">SESSION_SECRET:</span><br><br><span class="hljs-attr">environment:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">RACK_ENV=development</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">SESSION_SECRET</span><br></code></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">y|Y|<span class="hljs-built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="hljs-literal">true</span>|True|TRUE|<span class="hljs-literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF<br></code></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>]<br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">1m30s</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">orchardup/postgresql</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">a4bc65fd</span><br></code></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h4><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">some-service:</span><br>    <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">some-network</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">other-network</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">some-network:</span><br>  <span class="hljs-attr">other-network:</span><br></code></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ports:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:8000&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;49100:22&quot;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span><br></code></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h4><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-attr">net.core.somaxconn:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">net.ipv4.tcp_syncookies:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.core.somaxconn=1024</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.ipv4.tcp_syncookies=0</span><br></code></pre></td></tr></table></figure><h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ulimits:</span><br>  <span class="hljs-attr">nproc:</span> <span class="hljs-number">65535</span><br>  <span class="hljs-attr">nofile:</span><br>    <span class="hljs-attr">soft:</span> <span class="hljs-number">20000</span><br>    <span class="hljs-attr">hard:</span> <span class="hljs-number">40000</span><br></code></pre></td></tr></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">/var/lib/mysql</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">cache/:/tmp/cache</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">~/configs:/etc/configs/:ro</span><br></code></pre></td></tr></table></figure><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my_src:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data:/var/lib/mysql</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data:</span><br></code></pre></td></tr></table></figure><h2 id="5-4-常用命令"><a href="#5-4-常用命令" class="headerlink" title="5.4 常用命令"></a>5.4 常用命令</h2><h5 id="1-命令对象与格式"><a href="#1-命令对象与格式" class="headerlink" title="1. 命令对象与格式"></a>1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]<br></code></pre></td></tr></table></figure><h5 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h5><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h5 id="3-命令使用说明"><a href="#3-命令使用说明" class="headerlink" title="3.命令使用说明"></a>3.命令使用说明</h5><h5 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><ul><li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p></li><li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p></li><li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p></li><li><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p></li><li><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p></li><li><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p></li><li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p></li></ul><hr><h5 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h5><ul><li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li></ul><hr><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h5><ul><li>进入指定的容器。</li></ul><hr><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><hr><h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><hr><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><hr><h5 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><hr><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><hr><h5 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h5><p>查看各个服务容器内运行的进程。</p><hr><h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s基础</title>
    <link href="/2024/05/27/docker/k8s%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/27/docker/k8s%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s基础"><a href="#k8s基础" class="headerlink" title="k8s基础"></a>k8s基础</h1><hr><h2 id="1、关于-k8s-的基本架构"><a href="#1、关于-k8s-的基本架构" class="headerlink" title="1、关于 k8s 的基本架构"></a>1、关于 k8s 的基本架构</h2><p>K8s 全称 kubernets，希腊语意为：舵手，是一种可自动实施 Linux容器操作的开源平台。前期由 Google 的工程师开发和设计，中期由红帽等一系列公司参与合作开发，后期由云原生计算基金会进行更新、迭代。其提供了应用部署、规划、更新、维护的一种机制，可以省去应用容器化过程的许多手动部署和扩展操作，将运行 Linux 容器的多组主机聚集在一起，轻松高效地管理集群。</p><p>要学习使用K8s，首先要了解K8s的架构、组件以及特点，说到集群，我们不免会想到master、slaver 或者 node，k8s集群也是这样，由多台 master 和 node 组成，由 master 控制 node，由node（也可以是master）提供服务，如图一所示：</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520111740567.png?raw=true" alt="image-20240520111740567"></p><p><strong>什么是 master：</strong> master 的组件包括 apiserver、controller-manager、scheduler 和 etcd，那么这几个组件是用来做什么的呢？我做了个简单的比喻： 图</p><ul><li><strong>Apiserver（房子入口）:</strong> K8S 对外的唯一接口，提供 HTTP&#x2F;HTTPS RESTful API，即所有的请求都需要经过这个接口进行通信</li><li><strong>Etcd （后勤人员）：</strong> 负责保存 k8s 集群的配置信息和各种资源的状态信息，当数据发生变化时，etcd会快速地通知k8s相关组件</li><li><strong>Controller Manager（管理者）：</strong> 负责管理集群各种资源，保证资源处于预期的状态</li><li><strong>Schedule （负责调度）：</strong> 资源调度，负责决定将 Pod 放到哪个 Node 上运行</li></ul><p><strong>什么是 node:</strong> 那么 Node 又是什么呢？说透了 Node 就是干活的。Node的组件包括 Kubelet、Container Runtime、Kube-proxy。</p><ul><li><strong>Kubelet（来料加工生产）：</strong> kubelet 是 node 的 agent，kubelet 会根据 pod 信息创建和运行容器，并向master报告运行状态</li><li><strong>Container Runtime （下载运行）：</strong> 每个Node都需要提供一个容器运行（Container Runtime）环境，它负责下载镜像并运行容器。</li><li><strong>Kube-proxy（传输纽带）：</strong> 用户通过 service（即将介绍）访问Pod，每个Node都会运行kube-proxy服务，将访问的service的TCP&#x2F;UDP数据流转发到后端的容器</li></ul><p>如此，我们也形象地了解了 node 和 node 组件的作用，与此同时，文中提到了 pod 和 service，那么这两个英文单词在K8S中表示什么呢？ <strong>Pod 资源对象</strong>是一种集合了一个或多个应用容器、存储资源、专用ip、以及支撑运行的其他选项的逻辑组件，用大白话讲，pod好比一场舞台剧，是导演、编剧编排好以后由演员、灯光、道具、场务等协作完成的一场戏。 <strong>Service资源</strong>就是在被访问的Pod对象中添加一个有着固定IP地址的中间层，Service资源将客户访问进行调度并代理到后端的Pod对象，Service 起到了通道的作用。Service就好比是个向导，负责将客户带到pod这场舞台剧来观看。</p><h2 id="2、k8s-和kubesphere介绍"><a href="#2、k8s-和kubesphere介绍" class="headerlink" title="2、k8s 和kubesphere介绍"></a>2、k8s 和kubesphere介绍</h2><p>后续操作基于kubesphere 对k8s进行使用</p><p><a href="https://www.kubesphere.io/zh/docs/v3.3/introduction/what-is-kubesphere/">k8s官方文档</a></p><p><a href="https://kubernetes.io/zh-cn/docs/home/">kubesphere官方文档</a></p><p><a href="https://helm.sh/zh/docs/">helm官方文档</a></p><p>简单的更好理解的类比:</p><p>​docker，一个容器对应一个服务</p><p>​docker-compose，多个容器服务的集合，每个服务都是standalone模式，负载性能有上限</p><p>​k8s&#x2F;docker swarm，将这里面的每个服务集群化，集群规模动态可控</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520113012594.png?raw=true" alt="image-20240520113012594"></p><p><strong>kubernetes(k8s):</strong> </p><p>​     开源容器编排平台</p><p>​     自动化部署、扩展和管理容器化应用程序</p><p><strong>kubesphere:</strong> </p><p>​     基于k8s构建的开源多云容器管理平台</p><p>​     可视化管理界面、应用商店、应用程序监控和日志管理等功能</p><p><strong>Helm Chart:</strong>   </p><p>​     k8s的包管理工具， 配置，打包k8s应用程序</p><h2 id="3、安装kubesphere"><a href="#3、安装kubesphere" class="headerlink" title="3、安装kubesphere"></a>3、安装kubesphere</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> KKZONE=cn<br>curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.7 sh -<br></code></pre></td></tr></table></figure><p>备注</p><p>在您下载 KubeKey 后，如果您将其传至新的机器，且访问 Googleapis 同样受限，在您执行以下步骤之前请务必再次执行 <code>export KKZONE=cn</code> 命令。</p><p>执行以上命令会下载最新版 KubeKey，您可以修改命令中的版本号下载指定版本。</p><p>为 <code>kk</code> 添加可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x kk<br></code></pre></td></tr></table></figure><p>在本快速入门教程中，您只需执行一个命令即可进行安装，其模板如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./kk create cluster [--with-kubernetes version] [--with-kubesphere version]<br><br>若要同时安装 Kubernetes 和 KubeSphere，可参考以下示例命令：<br>./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.3.2<br></code></pre></td></tr></table></figure><ul><li>安装 KubeSphere 3.3 的建议 Kubernetes 版本：v1.20.x、v1.21.x、* v1.22.x、* v1.23.x 和 * v1.24.x。带星号的版本可能出现边缘节点部分功能不可用的情况。因此，如需使用边缘节点，推荐安装 v1.21.x。如果不指定 Kubernetes 版本，KubeKey 将默认安装 Kubernetes v1.23.10。有关受支持的 Kubernetes 版本的更多信息，请参见<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/introduction/kubekey/#%E6%94%AF%E6%8C%81%E7%9F%A9%E9%98%B5">支持矩阵</a>。</li><li>一般来说，对于 All-in-One 安装，您无需更改任何配置。</li><li>如果您在这一步的命令中不添加标志 <code>--with-kubesphere</code>，则不会部署 KubeSphere，KubeKey 将只安装 Kubernetes。如果您添加标志 <code>--with-kubesphere</code> 时不指定 KubeSphere 版本，则会安装最新版本的 KubeSphere。</li><li>KubeKey 会默认安装 <a href="https://openebs.io/">OpenEBS</a> 为开发和测试环境提供 LocalPV 以方便新用户。对于其他存储类型，请参见<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-linux/persistent-storage-configurations/understand-persistent-storage/">持久化存储配置</a>。</li></ul><p>执行该命令后，KubeKey 将检查您的安装环境，结果显示在一张表格中。有关详细信息，请参见<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/#%E8%8A%82%E7%82%B9%E8%A6%81%E6%B1%82">节点要求</a>和<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/all-in-one-on-linux/#%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%A6%81%E6%B1%82">依赖项要求</a>。输入 <code>yes</code> 继续安装流程。</p><blockquote><p>KubeKey 是用 Go 语言开发的一款全新的安装工具，代替了以前基于 ansible 的安装程序。KubeKey 为用户提供了灵活的安装选择，可以分别安装 KubeSphere 和 Kubernetes 或二者同时安装，既方便又高效。</p></blockquote><p>安装完成提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#####################################################</span><br><span class="hljs-comment">###              Welcome to KubeSphere!           ###</span><br><span class="hljs-comment">#####################################################</span><br><br>Console: http://192.168.0.164:30880<br>Account: admin<br>Password: P@88w0rd<br>NOTES：<br>  1. After you <span class="hljs-built_in">log</span> into the console, please check the<br>     monitoring status of service components <span class="hljs-keyword">in</span><br>     <span class="hljs-string">&quot;Cluster Management&quot;</span>. If any service is not<br>     ready, please <span class="hljs-built_in">wait</span> patiently <span class="hljs-keyword">until</span> all components <br>     are up and running.<br>  2. Please change the default password after login.<br><br><span class="hljs-comment">#####################################################</span><br>https://kubesphere.io             2024-05-20 15:53:41<br><span class="hljs-comment">#####################################################</span><br>15:53:44 CST success: [super]<br>15:53:44 CST Pipeline[CreateClusterPipeline] execute successfully<br>Installation is complete.<br><br>Please check the result using the <span class="hljs-built_in">command</span>:<br><br>kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="hljs-string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f<br><br></code></pre></td></tr></table></figure><p><strong>验证安装结果</strong></p><p>输入以下命令以检查安装结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="hljs-string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f<br><br></code></pre></td></tr></table></figure><p>输出信息会显示 Web 控制台的 IP 地址和端口号，默认的 NodePort 是 <code>30880</code>。现在，您可以使用默认的帐户和密码 (<code>admin/P@88w0rd</code>) 通过 <code>&lt;NodeIP&gt;:30880</code> 访问控制台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#####################################################</span><br><br><span class="hljs-comment">###              Welcome to KubeSphere!           ###</span><br><br><span class="hljs-comment">#####################################################</span><br><br><br><br>Console: http://192.168.0.164:30880<br><br>Account: admin<br><br>Password: P@88w0rd<br><br><br><br>NOTES：<br><br>  1. After you <span class="hljs-built_in">log</span> into the console, please check the<br><br>     monitoring status of service components <span class="hljs-keyword">in</span><br><br>     <span class="hljs-string">&quot;Cluster Management&quot;</span>. If any service is not<br><br>     ready, please <span class="hljs-built_in">wait</span> patiently <span class="hljs-keyword">until</span> all components <br><br>     are up and running.<br><br>  2. Please change the default password after login.<br><br><br><br><span class="hljs-comment">#####################################################</span><br><br>https://kubesphere.io             20xx-xx-xx xx:xx:xx<br><br><span class="hljs-comment">#####################################################</span><br><br></code></pre></td></tr></table></figure><p>录至控制台后，您可以在<strong>系统组件</strong>中查看各个组件的状态。如果要使用相关服务，您可能需要等待部分组件启动并运行。您也可以使用 <code>kubectl get pod --all-namespaces</code> 来检查 KubeSphere 相关组件的运行状况。</p><h2 id="4、k8s基础资源介绍"><a href="#4、k8s基础资源介绍" class="headerlink" title="4、k8s基础资源介绍"></a>4、k8s基础资源介绍</h2><h3 id="4-1-容器组（pod）"><a href="#4-1-容器组（pod）" class="headerlink" title="4.1 容器组（pod）"></a>4.1 容器组（pod）</h3><ul><li>K8s中最小的可部署对象</li><li>一个或多个容器的运行环境</li><li>容器间共享网络和存储资源</li></ul><h3 id="4-2-工作负载（deployment、statefulset、daemonset）"><a href="#4-2-工作负载（deployment、statefulset、daemonset）" class="headerlink" title="4.2 工作负载（deployment、statefulset、daemonset）"></a>4.2 工作负载（deployment、statefulset、daemonset）</h3><ul><li>pod 的控制器</li><li>管理pod副本数，配置，滚动更新，回滚pod</li><li>部署（deployment）管理控制无状态的容器组，如后端，前端等</li><li>有状态副本集（statefulset）管理控制有状态的容器组，如mysql，kafka，es等</li><li>守护进程集（daemonset）,管理一个节点只运行一个的容器组副本，如fluentd，logstash, Prometheus Node Exporter</li></ul><h3 id="4-3-服务（service"><a href="#4-3-服务（service" class="headerlink" title="4.3 服务（service)"></a>4.3 服务（service)</h3><ul><li>访问入口（分内部访问和外部访问）</li><li>负载均衡到多个pod副本</li></ul><h3 id="4-4-任务（job"><a href="#4-4-任务（job" class="headerlink" title="4.4 任务（job)"></a>4.4 任务（job)</h3><ul><li>访问入口（分内部访问和外部访问）</li><li>负载均衡到多个pod副本</li></ul><h3 id="4-5-持久卷和持久卷声明（pv-pvc"><a href="#4-5-持久卷和持久卷声明（pv-pvc" class="headerlink" title="4.5  持久卷和持久卷声明（pv &amp; pvc)"></a>4.5  持久卷和持久卷声明（pv &amp; pvc)</h3><ul><li>pv 是一块存储资源 </li><li>pvc 是对PV的声明式请求，描述了Pod需要的存储资源的需求，包括存储容量、读写模式、访问模式等</li><li>pv 和pvc 一一对应</li></ul><h3 id="4-6-配置-secret-configmap-serviceaccount"><a href="#4-6-配置-secret-configmap-serviceaccount" class="headerlink" title="4.6 配置(secret,configmap,serviceaccount)"></a>4.6 配置(secret,configmap,serviceaccount)</h3><ul><li>保密字典（secret）: 用于存储和管理密码、OAuth 令牌和 SSH 保密字典等敏感信息</li><li>配置字典（configmap）: 用于向容器组中注入配置数据</li><li>服务账号（serviceaccount）: 为 Pod 中运行的进程提供了标识。当用户访问集群时，API 服务器将用户认证为特定的用户帐户</li></ul><h2 id="5、资源之间的关系"><a href="#5、资源之间的关系" class="headerlink" title="5、资源之间的关系"></a>5、资源之间的关系</h2><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/image-20240520152157424.png?raw=true" alt="image-20240520152157424"></p><h2 id="6、新建自定义服务暴露mysql服务"><a href="#6、新建自定义服务暴露mysql服务" class="headerlink" title="6、新建自定义服务暴露mysql服务"></a>6、新建自定义服务暴露mysql服务</h2><blockquote><p>仓库地址:</p><p> bitnami 官网： <a href="https://charts.bitnami.com/bitnami">https://charts.bitnami.com/bitnami</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm repo add bitnami https://charts.bitnami.com/bitnami<br>$ helm search repo bitnami<br>$ helm install my-release bitnami/&lt;chart&gt;<br></code></pre></td></tr></table></figure><blockquote><p>第一步 创建企业空间</p><p>第二步 添加应用仓库</p></blockquote><h3 id="1-新建mysql数据库服务"><a href="#1-新建mysql数据库服务" class="headerlink" title="1 新建mysql数据库服务"></a><strong>1 新建mysql数据库服务</strong></h3><p>应用负载 -&gt; 服务 -&gt; 创建 -&gt; 选择有状态服务</p><h4 id="第一步-基本信息"><a href="#第一步-基本信息" class="headerlink" title="第一步 基本信息"></a><strong>第一步 基本信息</strong></h4><p>填写服务名称 -&gt; 下一步</p><h4 id="第二步-容器组设置"><a href="#第二步-容器组设置" class="headerlink" title="第二步 容器组设置"></a><strong>第二步 容器组设置</strong></h4><p>1 添加容器 -&gt;2 选择镜像仓库 -&gt;3 填写镜像名称和版本 -&gt;4 填写容器名称 -&gt;5 使用默认端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5f58e604-f78d-49d3-924a-c0df0952e5b3.png?raw=true" alt="img"></p><p>滚轮下划，添加环境变量，设置初始root密码</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4e06eee2-d151-4e48-9ba5-9df0d609b15f.png?raw=true" alt="img"></p><h4 id="第三步-存储设置"><a href="#第三步-存储设置" class="headerlink" title="第三步 存储设置"></a><strong>第三步 存储设置</strong></h4><p>存储设置，添加持久卷申明模板</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4dd6494e-97d2-45d1-b674-d06468a94deb.png?raw=true" alt="img"></p><p>1 填写持久卷申明名称前缀 -&gt; 2 选择存储类（默认local） -&gt; 3 选择访问模式（默认）-&gt; 4 设置存储空间大小 -&gt;</p><p>5 选择读写模式 -&gt; 6 填写容器内数据所在目录 -&gt; 确定 -&gt; 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/6694c3e2-2492-4968-9066-284977513e97.png?raw=true" alt="img"></p><h4 id="第四步-高级设置"><a href="#第四步-高级设置" class="headerlink" title="第四步 高级设置"></a><strong>第四步 高级设置</strong></h4><p>会话保持：一般在后端服务中可以设置，同一个用户连续访问，会在一段时间内负载到同一个容器组副本</p><p>选择节点：可以选择将容器部署至k8s集群中的某个节点</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/06a335af-81fa-49df-8203-813a57beda34.png?raw=true" alt="img"></p><p>有状态服务新建完只能内部使用</p><h4 id="第五步-新建自定义服务暴露mysql服务"><a href="#第五步-新建自定义服务暴露mysql服务" class="headerlink" title="第五步 新建自定义服务暴露mysql服务"></a><strong>第五步 新建自定义服务暴露mysql服务</strong></h4><p>1 应用负载 -&gt; 2 服务 -&gt;3 创建 -&gt; 4 自定义服务 -&gt;5 指定工作负载 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/84fc16e6-7888-4a67-ae10-0bcbb6be5e34.png?raw=true" alt="img"></p><p>6 填写服务名称 -&gt; 7 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/0907b73e-5e1b-40e8-85e8-2656fd543acb.png?raw=true" alt="img"></p><p>8 指定工作负载 -&gt; 9 有状态副本集 -&gt; 10 选择之前创建的mysql -&gt;11 确定 </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/cf1c4ccc-dd26-4009-85ac-2b26f1430005.png?raw=true" alt="img"></p><p>12 选择服务端口协议 -&gt;13 填写名称 -&gt;14 填写容器端口 -&gt;15 服务端口 -&gt;16 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/74be5fde-79ae-4e1a-a173-e39dec04c508.png?raw=true" alt="img"></p><p>17 勾选外部访问（如果不配置，那该服务只能k8s集群节点内部访问）-&gt; 18 选择访问模式 -&gt; 19 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/93bec419-be27-4915-b98d-23811b5ac078.png?raw=true" alt="img"></p><h4 id="第六步-mysql-服务使用方法"><a href="#第六步-mysql-服务使用方法" class="headerlink" title="第六步 mysql 服务使用方法"></a><strong>第六步 mysql 服务使用方法</strong></h4><p>1 内部ip加端口: 10.233.4.60:3306</p><p>2 内部域名加端口：</p><p>  同一个项目内，mysql-ex:3306</p><p>  不同项目使用，mysql-ex.superlab.svc.cluster.local:3306</p><p>3 外部ip加端口: 192.168.0.104:10419</p><p>用户名：root</p><p>密码：第二步填写的环境变量值</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5be003b4-4830-4c98-954c-995b5a3a5476.png?raw=true" alt="img"></p><h3 id="2-新建后端服务"><a href="#2-新建后端服务" class="headerlink" title="2 新建后端服务"></a><strong>2 新建后端服务</strong></h3><h4 id="第零步-配置镜像仓库信息"><a href="#第零步-配置镜像仓库信息" class="headerlink" title="第零步 配置镜像仓库信息"></a><strong>第零步 配置镜像仓库信息</strong></h4><p>配置 -&gt; 保密字典 -&gt; 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/6c1fd5df-5a05-4b01-8952-adfa55d01302.png?raw=true" alt="img"></p><p>3 填写名称 -&gt; 下一步 -&gt; 选择类型-&gt; 镜像服务信息</p><p>4 填写镜像服务地址-&gt; 用户名 -&gt; 密码 -&gt; 创建 （镜像仓库信息找各自代码仓库管理员要）</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/77d02f21-7d72-4f4b-b081-07ffe2f4a638.png?raw=true" alt="img"></p><h4 id="第一步-基本信息-1"><a href="#第一步-基本信息-1" class="headerlink" title="第一步 基本信息"></a><strong>第一步 基本信息</strong></h4><p>应用负载 -&gt; 服务 -&gt; 创建 -&gt; 选择无状态服务</p><p>1 填写服务名称 -&gt;2 下一步</p><h4 id="第二步-容器组设置-1"><a href="#第二步-容器组设置-1" class="headerlink" title="第二步 容器组设置"></a><strong>第二步</strong> <strong>容器组设置</strong></h4><p>3 添加容器 -&gt;4 选择镜像仓库 -&gt;5 填写镜像名称和版本 -&gt;6 填写容器名称 -&gt;7 使用默认端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/1fe9ab97-15f7-4cbd-99c0-bcdbf753fe02.png?raw=true" alt="img"></p><p>8 滚轮下滑 -&gt;9 勾选环境变量 -&gt;10 填写mysql地址，端口，账号，密码（建议将这些配置配成根据环境变量动态获取）-&gt; 11 确定 -&gt; 12 下一步</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c7c860bb-6460-4920-87ef-67fc973d419f.png?raw=true" alt="img"></p><p><strong>第三步 存储设置</strong></p><p>如需挂载数据文件，选择“挂载卷”</p><p>如需挂载配置文件，选择“挂载配置字典或保密字典”</p><p>无需挂载，直接”下一步”</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/bcb65ce3-b69e-49ed-820c-40825623dcb8.png?raw=true" alt="img"></p><h4 id="第四步-高级设置-1"><a href="#第四步-高级设置-1" class="headerlink" title="第四步 高级设置"></a><strong>第四步 高级设置</strong></h4><p>根据需要设置外部访问，会话保持，选择节点</p><p>无需要则“下一步”</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/2a2ea879-6a0a-4131-a03d-89147528b8e3.png?raw=true" alt="img"></p><h4 id="第五步-往部署配置中加入镜像仓库信息"><a href="#第五步-往部署配置中加入镜像仓库信息" class="headerlink" title="第五步 往部署配置中加入镜像仓库信息"></a><strong>第五步 往部署配置中加入镜像仓库信息</strong></h4><p>1 进入部署信息页面，应用负载 -&gt; 工作负载 -&gt; 点击部署名称（以<a href="http://192.168.0.104:30880/supertech/clusters/default/projects/superlab/deployments/classification-workers-v1"><strong>classification-workers-v1</strong></a><strong>为例</strong>） </p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/ad92fbaf-3064-4520-9c35-f0a8f8ff0f1a.png?raw=true" alt="img"></p><p>2 编辑yaml ,添加第零步配置的镜像服务保密字典的名称</p><p>更多操作 -&gt; 编辑yaml ， 在spec.template.spec下添加镜像服务保密字典名称</p><p>imagePullSecrets:</p><p>​    - name: hangzhou-aliyuncs-com（这里换成自己创建的镜像服务保密字典的名称）</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/907a9a99-dae4-4a59-b12f-6704bc564624.png?raw=true" alt="img"></p><h4 id="第六步-后端服务如何调用"><a href="#第六步-后端服务如何调用" class="headerlink" title="第六步 后端服务如何调用"></a><strong>第六步 后端服务如何调用</strong></h4><p>按目前公司前后端分离的开发模式（nginx+前端静态文件+后端服务端口）</p><p>在nginx中配置内部ip+端口，负载后端服务</p><p>1 前端负载配置</p><p>2 后端负载配置</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/eeee85a1-5c7c-418d-aac7-a7dd6b17db90.png?raw=true" alt="img"></p><p>应用负载 -&gt; 服务 -&gt; 进入后端服务</p><p>查看对应的内部服务ip 和服务端口</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/4bb8696b-a8b3-405f-86b7-589c1c222b38.png?raw=true" alt="img"></p><h3 id="3-新建前端服务"><a href="#3-新建前端服务" class="headerlink" title="3  新建前端服务"></a>3  <strong>新建前端服务</strong></h3><p>步骤与后端服务创建过程一样</p><p>只是将镜像换成了前端镜像</p><p>前端镜像的dockerfile本质是基于nginx，</p><p>然后在nginx的配置文件里配置了</p><p>前端静态文件负载和</p><p>后端接口服务负载</p><p>新建完以后需要暴露前端服务</p><p>应用负载 -&gt; 服务 -&gt; 更多 -&gt; 编辑外部访问</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/a11ddcd9-4f05-4ab3-bf2a-db221bc03f0f.png?raw=true" alt="img"></p><p>选择访问模式 -&gt; 确定</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/38897e5b-fcf1-4dba-8874-79cb5c887140.png?raw=true" alt="img"></p><p>在浏览器中，用ip+端口即可访问前端页面</p><p>192.168.0.104:42064</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/14d3c33b-fa55-45b1-8a49-72a0f2e4bf56.png?raw=true" alt="img"></p><h2 id="7、kebectl常用命令"><a href="#7、kebectl常用命令" class="headerlink" title="7、kebectl常用命令"></a>7、kebectl常用命令</h2><p><code>kubectl</code> 是 Kubernetes 的命令行工具，用于与 Kubernetes 集群进行交互，包括部署应用、检查和管理各种资源。一些基本的 <code>kubectl</code> 命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get ns<span class="hljs-comment"># 查看命名空间</span><br>kubectl get pods  -n &lt;namespace-name&gt;<span class="hljs-comment"># 查看命名空间所有Pod列表</span><br>kubectl describe pods/&lt;pod-name&gt;<span class="hljs-comment"># 显示Pod的详细信息</span><br>kubectl config set-context --current --namespace=production      <span class="hljs-comment"># 切换到不同的命名空间</span><br>kubectl config view --minify | grep namespace: <span class="hljs-comment"># 查看当前所属命名空间</span><br>kubectl get service     <span class="hljs-comment"># 查看service列表</span><br>kubectl get deployments <span class="hljs-comment"># 查看所有命名空间中的Deployments</span><br>kubectl create -f my-service.yaml   <span class="hljs-comment"># 根据yaml配置文件一次性创建service</span><br>kubectl create -f &lt;directory&gt; <span class="hljs-comment"># 根据目录下所有.yaml、.yml、.json文件的定义进行创建操作</span><br>kubectl delete -f pod.yaml <span class="hljs-comment"># 删除基于pod.yaml文件定义的Pod</span><br>kubectl delete pods --all <span class="hljs-comment"># 删除所有Pod</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; <span class="hljs-built_in">date</span> <span class="hljs-comment"># 在Pod的容器里执行date命令，默认使用Pod中的第1个容器执行</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; <span class="hljs-built_in">date</span> <span class="hljs-comment"># 指定Pod中某个容器执行date命令</span><br>kubectl <span class="hljs-built_in">exec</span> -it &lt;pod-name&gt; -c &lt;container-name&gt; /bin/bash        <span class="hljs-comment"># 以bash方式登陆到Pod中的某个容器里</span><br>kubectl logs -f &lt;pod-name&gt; -c &lt;container-name&gt; <span class="hljs-comment"># 跟踪查看容器的日志，相当于tail -f命令的结果</span><br></code></pre></td></tr></table></figure><h2 id="8、kubeadm常用命令"><a href="#8、kubeadm常用命令" class="headerlink" title="8、kubeadm常用命令"></a>8、kubeadm常用命令</h2><p><code>kubeadm</code> 是 Kubernetes 的一个简化集群初始化和管理工具，它旨在提供一种快速、可靠的方式来引导最小化的 Kubernetes 控制平面以及加入工作节点到集群中。一些常用的 <code>kubeadm</code> 命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init <span class="hljs-comment"># 启动引导一个 Kubernetes 主节点</span><br>kubeadm <span class="hljs-built_in">join</span> <span class="hljs-comment"># 启动引导一个 Kubernetes 工作节点并且将其加入到集群</span><br>kubeadm upgrade <span class="hljs-comment"># 更新 Kubernetes 集群到新版本</span><br>kubeadm config <span class="hljs-comment"># 如果你使用 kubeadm v1.7.x 或者更低版本，你需要对你的集群做一些配置以便使用 kubeadmupgrade 命令</span><br>kubeadm token <span class="hljs-comment"># 使用 kubeadm join 来管理令牌</span><br>kubeadm reset  <span class="hljs-comment"># 还原之前使用 kubeadm init 或者 kubeadm join 对节点所作改变</span><br>kubeadm version <span class="hljs-comment"># 打印出 kubeadm 版本</span><br>kubeadm alpha <span class="hljs-comment"># 预览一组可用的新功能以便从社区搜集反馈</span><br></code></pre></td></tr></table></figure><h2 id="9-、kubelet"><a href="#9-、kubelet" class="headerlink" title="9 、kubelet"></a>9 、kubelet</h2><p><code>kubelet</code> 是在每个节点上运行的主要守护进程，负责与Master通信、管理Pods、容器以及其他相关任务。通常，kubelet不是直接通过命令行与之交互，而是通过配置文件（如 <code>/var/lib/kubelet/kubelet-config.yaml</code>）和环境变量来设定。不过，了解其功能很重要，因为它负责：</p><ul><li><strong>Pod 和容器的生命周期管理</strong>：根据从apiserver接收到的指令来创建、更新、删除Pod和容器。</li><li><strong>资源监控和报告</strong>：收集节点资源使用情况，向Master报告。</li><li><strong>日志和监控</strong>：管理容器日志，支持与日志收集系统的集成。</li></ul><h2 id="10、打包helm部署流程"><a href="#10、打包helm部署流程" class="headerlink" title="10、打包helm部署流程"></a>10、打包helm部署流程</h2><h3 id="1、添加公司helm-chart-仓库"><a href="#1、添加公司helm-chart-仓库" class="headerlink" title="1、添加公司helm chart 仓库"></a>1、<strong>添加公司helm chart 仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add helm-repo-115 http://115.231.236.115:8081/nexus/repository/helm-repo-115/<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/8057ec28-197d-4b46-ac2d-be3fadef95a7.png?raw=true" alt="img"></p><h3 id="2、创建一个应用目录"><a href="#2、创建一个应用目录" class="headerlink" title="2、创建一个应用目录"></a>2、创建一个应用目录</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/19b5ab45-a0b2-49d0-a624-5437aaa2a102.png?raw=true" alt="img"></p><h3 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c48b3afe-b905-4f20-8531-f6ce9c6eaeda.png?raw=true" alt="img"></p><h3 id="4、目录结构介绍"><a href="#4、目录结构介绍" class="headerlink" title="4、目录结构介绍"></a>4、目录结构介绍</h3><p>harts: 目录包含了依赖的其他Helm Charts，可以让您在应用程序中引入其他的Helm Charts</p><p>Chart.yaml: 元数据文件，包含了应用程序的名称、版本、描述、维护人员等信息</p><p>templates: 目录包含了应用程序的Kubernetes资源配置文件，例如Deployment、Service、Configmap等</p><p>values.yaml：应用程序的默认配置文件，用于设置应用程序的默认参数值</p><h3 id="5-初步打包介绍"><a href="#5-初步打包介绍" class="headerlink" title="5 初步打包介绍"></a>5 初步打包介绍</h3><p><strong>第一步 删除 templates 下所有文件</strong></p><p><strong>第二步 获取要打包的完整应用在k8s 上的所有资源配置文件，包含服务，工作负载，配置项等</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/bd4c8502-9c3b-4b49-92f5-2263119821e8.png?raw=true#764" alt="img"></p><p><strong>第三步 将配置文件放入templates 目录</strong></p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c9723cc5-7eb1-48cc-b332-03a313e25a90.png?raw=true" alt="img"></p><p><strong>第四步 根据版本号打包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm package mychart --version 1.0.0<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/eff431f6-c344-4425-9a79-217005de1f32.png?raw=true" alt="img"></p><p><strong>第五步 推送到仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm nexus-push helm-repo-115 mychart-1.0.0.tgz -u admin -p  &#123;密码&#125;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/8dfcb80c-6d9f-4bad-9986-3c94e0708309.png?raw=true" alt="img"></p><h2 id="11、使用helm包部署完整应用流程"><a href="#11、使用helm包部署完整应用流程" class="headerlink" title="11、使用helm包部署完整应用流程"></a>11、<strong>使用helm包部署完整应用流程</strong></h2><h3 id="1-添加helm仓库"><a href="#1-添加helm仓库" class="headerlink" title="1 添加helm仓库"></a><strong>1 添加helm仓库</strong></h3><p>平台管理 -&gt; 访问控制 -&gt; 进入企业空间</p><p>应用管理 -&gt; 应用仓库 -&gt; 添加</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/5a3a662d-741b-4d77-bd15-8bc2f4c1617c.png?raw=true" alt="img"></p><p>填写仓库信息</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/1dec1227-804c-492f-b74e-84d750147789.png?raw=true" alt="img"></p><h3 id="2-一键部署应用"><a href="#2-一键部署应用" class="headerlink" title="2 一键部署应用"></a><strong>2 一键部署应用</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 基于模板的应用 -&gt; 创建</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/a17c75e3-2223-4008-8c29-55515a8b453f.png?raw=true" alt="img"></p><p>选择应用仓库helm-repo-115 -&gt; 选择应用模板mychart -&gt;安装</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/dfb34fc6-d82c-4dd2-837d-afc3581dfb36.png?raw=true" alt="img"></p><h3 id="3-点击查看应用内资源运行情况"><a href="#3-点击查看应用内资源运行情况" class="headerlink" title="3 点击查看应用内资源运行情况"></a><strong>3 点击查看应用内资源运行情况</strong></h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/71a619b2-8ea5-4366-9801-6cfc9e2ccc89.png?raw=true" alt="img"></p><h2 id="12、日常运维流程"><a href="#12、日常运维流程" class="headerlink" title="12、日常运维流程"></a><strong>12、日常运维流程</strong></h2><h3 id="1-升级镜像，修改容器配置等"><a href="#1-升级镜像，修改容器配置等" class="headerlink" title="1 升级镜像，修改容器配置等"></a><strong>1 升级镜像，修改容器配置等</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 工作负载 -&gt; 点击对应工作负载</p><p>更多操作 -&gt; 编辑设置</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/d27ed6e2-2e81-46dd-90fb-2d871e75581c.png?raw=true" alt="img"></p><h3 id="2-查看容器日志"><a href="#2-查看容器日志" class="headerlink" title="2 查看容器日志"></a><strong>2 查看容器日志</strong></h3><p>进入项目 -&gt; 应用负载 -&gt; 工作负载 -&gt; 点击对应工作负载 -&gt; 点击容器组</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/ed7cb4ef-681d-4e4f-b04b-f2be0649591c.png?raw=true" alt="img"></p><p>实时查看&#x2F;停止，刷新日志，下载日志</p><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/42bb22e8-b48a-4d34-bd8c-a44c5680d352.png?raw=true" alt="img"></p><h3 id="3-进入容器-默认非root用户"><a href="#3-进入容器-默认非root用户" class="headerlink" title="3 进入容器(默认非root用户)"></a><strong>3 进入容器(默认非root用户)</strong></h3><p><img src="https://github.com/gondmhd/blogImage/blob/main/img/c7aecdad-99dc-48e7-a2d3-f4f9af68c624.png?raw=true" alt="img"></p><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/XJ9LnWvP9VvWlvDe/img/fda98b1f-5f56-49d3-85a1-f982a6c0a61e.png?raw=true" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
